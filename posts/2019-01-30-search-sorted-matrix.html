<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Art Gallery Guardian">
    <meta name="author" content="Chao Xu">
    <meta name="google-site-verification" content="YE2oeW4OwVOPdVVfdpYIakOuD0A2Qo80W_sUbMJDGok" />
    <meta name="referrer" content="origin">
    <title>Search in a sorted matrix with an oracle</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          var macros={
                  "\\C":"\\mathbb{C}",
                  "\\F":"\\mathbb{F}",
                  "\\e": "\\varepsilon",
                  "\\eps": "\\varepsilon",
                  "\\argmin": "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits",
                  "\\argmax": "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits",
                  "\\mex": "\\mathop{\\operatorname{mex}}",
                  "\\lcm": "\\mathop{\\operatorname{lcm}}",
                  "\\dist": "\\mathop{\\operatorname{dist}}",
                  "\\bigtriangleright": "{\\mathop{\\Large \\triangleright}}",
                  "\\bigtriangleleft": "{\\mathop{\\Large \\triangleleft}}",
                  '\\set':'\\left\\{ #1 \\right\\}',
                  '\\floor':'\\left\\lfloor #1 \\right\\rfloor',
                  '\\ceil':'\\left\\lceil #1 \\right\\rceil',
                  '\\abs':'\\left\\| #1 \\right\\|'
                  }
        var mathElements = document.getElementsByClassName("math");
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false, macros:macros} );
        }}});
    </script>
  <!-- Fathom - simple website analytics - https://github.com/usefathom/fathom -->
  <script>
  if(window.location.hostname === "chaoxuprime.com"){
    (function(f, a, t, h, o, m){
      a[h]=a[h]||function(){
        (a[h].q=a[h].q||[]).push(arguments)
      };
      o=f.createElement('script'),
      m=f.getElementsByTagName('script')[0];
      o.async=1; o.src=t; o.id='fathom-script';
      m.parentNode.insertBefore(o,m)
    })(document, window, '//track.chaoxuprime.com/tracker.js', 'fathom');
    fathom('set', 'siteId', 'DNRQY');
    fathom('trackPageview');
  }
  </script>
  <!-- / Fathom -->

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-4171915-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-4171915-2');
  </script>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
  <link rel="stylesheet" href="/css/default.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/blog.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml" title="RSS"
      href="https://chaoxuprime.com/rss.xml">
  </head>
  <body>
    <header class="hide-on-print">
        <div id="site-title">
            <a href="/blog.html">The Art Gallery Guardian</a>
        </div>
    </header>
    <nav class="hide-on-print">
      <ul>
        <li><a href="/">About</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/files/cv.pdf">CV</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
    <main>
      <article>
        <h1 id="article-title">Search in a sorted matrix with an oracle</h1>
        <br />
<div>
<p>Consider a infinite matrix <span class="math inline">M</span>. Another way to think about it is a function <span class="math inline">f:\N\to \N\to X</span>. A matrix <span class="math inline">M</span> is sorted if <span class="math inline">M_{i,j}\leq M_{i,j+1}</span> and <span class="math inline">M_{i,j}\leq M_{i+1,j}</span>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a sorted matrix <span class="math inline">M</span>, and an oracle that takes <span class="math inline">\lambda</span> returns if a value is <span class="math inline">\lambda &lt;\lambda^*</span> or <span class="math inline">\lambda \geq \lambda^*</span>. Find the largest value no larger than <span class="math inline">\lambda^*</span>.</p>
</section>
<p>Assuming there are at most <span class="math inline">k</span> elements no larger than <span class="math inline">\lambda^*</span>, and we know the smallest <span class="math inline">n</span> and <span class="math inline">m</span> such that <span class="math inline">M_{i,j}&gt;\lambda^*</span> if <span class="math inline">i&gt;n</span> or <span class="math inline">j&gt;m</span>. Also, let <span class="math inline">t</span> be the smallest number such that <span class="math inline">M_{t,t}&gt;\lambda^*</span>. One can see that <span class="math inline">t\leq \min(n,m)</span> and <span class="math inline">k=O(\max(n,m)^2)</span>.</p>
<p>Let's first consider the case when <span class="math inline">n</span> and <span class="math inline">m</span> is known and <span class="math inline">n\leq m</span>. It is <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">Leetcode 240. Search a 2D Matrix II</a>. However, our problem is more general, because comparison with <span class="math inline">\lambda^*</span> can only be done through the oracle. Craig Gidney wrote about an <a href="http://twistedoakstudios.com/blog/Post5365_searching-a-sorted-matrix-faster">optimal algorithm</a> with <span class="math inline">O(n\log \frac{m}{n})</span> running time, matrix access algorithm. However, the oracle access is too large. There are times where the oracle access is slow. For example, when using it as a subroutine for finding a <a href="https://chaoxuprime.com/posts/2019-01-31-bottleneck-k-link-path.html">bottleneck <span class="math inline">k</span>-link path</a>. There is an algorithm with optimal running time and <span class="math inline">O(\log(nm))</span> oracle access.</p>
<p>Let's consider a special case, where <span class="math inline">n=m=2^k</span> for some <span class="math inline">k</span>. This case was shown in <span class="citation" data-cites="FredericksonZ17">[<a href="#ref-FredericksonZ17">1</a>]</span>. For each submatrix, the two vertices on the opposite diagonal indicates the largest and smallest element in the submatrix. Hence each matrix can be represented by two numbers, indicate the maximum and minimum. These numbers are called the representative of the matrix. The idea is we keep two numbers <span class="math inline">\lambda_1</span> and <span class="math inline">\lambda_2</span>, such that we know <span class="math inline">\lambda^*\in [\lambda_1,\lambda_2]</span>. The algorithm keep partition the matrix into small matrices, updating <span class="math inline">\lambda_1</span> and <span class="math inline">\lambda_2</span>, and discard matrices outside the range. We apply the following algorithm. Let <span class="math inline">R</span> consists of the multiset of representatives of the matrix, and <span class="math inline">R&#39;</span> be the representatives that lies inside <span class="math inline">[\lambda_1,\lambda_2]</span>. We find <span class="math inline">\lambda</span>, the median of <span class="math inline">R&#39;</span>. Test if <span class="math inline">\lambda&lt;\lambda^*</span>. If so, then <span class="math inline">\lambda_1</span> updates to <span class="math inline">\lambda</span>, otherwise <span class="math inline">\lambda_2</span> updates to <span class="math inline">\lambda</span>. This step is done twice. Now, we split the matrices with more than one element into <span class="math inline">4</span> equally sized matrices, and repeat the algorithm. Recall at all times, the matrices does not contain any element in <span class="math inline">[\lambda_1,\lambda_2]</span> are discarded.</p>
<p>There is at most <span class="math inline">O(\log n)</span> iterations before range shrinks to a single element, hence at most <span class="math inline">O(\log n)</span> oracle calls. The difficulty is to show that the overall time is only <span class="math inline">O(n)</span>. Intuitively, in each iteration we quadruple the number of matrices, but we half it by two calls to the oracle. Therefore in <span class="math inline">\log n</span> steps we obtain roughly <span class="math inline">2^{\log n}=O(n)</span> matrices. However, at this point, the matrices are all singletons, and no more matrix can be created. We will only decrease the number of matrices by each oracle call. Careful reader can trace the whole argument in Lemma 2.1 of <span class="citation" data-cites="FredericksonZ17">[<a href="#ref-FredericksonZ17">1</a>]</span>.</p>
<p>For the more general case, one can find the proof in <span class="citation" data-cites="FredericksonJ84">[<a href="#ref-FredericksonJ84">2</a>]</span>. Note the proof is for selection, but one can easily modify it to work for search.</p>
<p>Now, <span class="math inline">n</span> and <span class="math inline">m</span> is not known, but we can quickly using exponential search to find it. Indeed, we just have to apply exponential search in the first row and first column using the oracle. This gives us an extra <span class="math inline">O(\log n + \log m)=O(\log nm)</span> oracle calls.</p>
<p>Actually, better running time is possible. Use exponential search until we find the first <span class="math inline">i</span> such that <span class="math inline">M_{2^i,2^i}&gt;\lambda^*</span>. So we can upper bound <span class="math inline">t</span>. Then one can solve the problem with <span class="math inline">2</span> matrices. One <span class="math inline">t\times k</span> matrix and a <span class="math inline">k\times t</span> matrix. The total running time is therefore <span class="math inline">O(\log k+t\log k/t)=O(t\log k)</span>. In fact, we get <span class="math inline">O(\log k)</span> oracle calls and <span class="math inline">O(t\log k)</span> running time. Note <span class="math inline">t</span> will never approach <span class="math inline">k</span>. The running time is <span class="math inline">O(t\log k)</span>.</p>
<h1 id="remark"><span class="header-section-number">1</span> Remark</h1>
<p>There is an alternative algorithm which can be found in <span class="citation" data-cites="JacobR08">[<a href="#ref-JacobR08">3</a>]</span>. The alternative algorithm is quite close to a post about <a href="https://chaoxuprime.com/posts/2014-04-02-selection-in-a-sorted-matrix.html">selection in a sorted matrix</a>.</p>
<p>The careful reader might observe the known search algorithms follow the exact same structure as algorithms for selection. Indeed, we <em>are</em> doing selection but we do not know the rank of the element. Intuitively, many selection algorithm, the rank is <em>only used</em> to remove the correct set of candidates. Hence this suggest one can modify the algorithm to use the oracle call in place of the rank.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-FredericksonZ17">
<p>[1] G.N. Frederickson, S. Zhou, <strong>Optimal parametric search for path and tree partitioning</strong>, CoRR. abs/1711.00599 (2017).</p>
</div>
<div id="ref-FredericksonJ84">
<p>[2] G. Frederickson, D. Johnson, <strong>Generalized selection and ranking: Sorted matrices</strong>, SIAM Journal on Computing. 13 (1984) 14–30 <a href="https://doi.org/10.1137/0213002">10.1137/0213002</a>.</p>
</div>
<div id="ref-JacobR08">
<p>[3] R. Jacob, <strong>Binary search on two-dimensional data</strong>, Technische Universität München, 2008.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-30. </div>
    <div class="info">Tags: algorithm, data structure.</div>

</div>
      </article>
    </main>
    <footer class="hide-on-print">© 2010 - <time><script>document.write(new Date().getFullYear())</script></time> <a href="https://chaoxuprime.com">Chao Xu</a>. Licensed under <a href="http://www.wtfpl.net/txt/copying/">WTFPL v2</a> unless otherwise specified. <a href="/README.html">Blog README</a>.</footer>
  </body>
</html>
