<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Art Gallery Guardian">
    <meta name="author" content="Chao Xu">
    <meta name="google-site-verification" content="YE2oeW4OwVOPdVVfdpYIakOuD0A2Qo80W_sUbMJDGok" />
    <meta name="referrer" content="origin">
    <title>Lexicographic Bottleneck Shortest Path in Undirected Graphs</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          var macros={
                  "\\C":"\\mathbb{C}",
                  "\\F":"\\mathbb{F}",
                  "\\e": "\\varepsilon",
                  "\\eps": "\\varepsilon",
                  "\\argmin": "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits",
                  "\\argmax": "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits",
                  "\\mex": "\\mathop{\\operatorname{mex}}",
                  "\\lcm": "\\mathop{\\operatorname{lcm}}",
                  "\\dist": "\\mathop{\\operatorname{dist}}",
                  "\\bigtriangleright": "{\\mathop{\\Large \\triangleright}}",
                  "\\bigtriangleleft": "{\\mathop{\\Large \\triangleleft}}",
                  '\\set':'\\left\\{ #1 \\right\\}',
                  '\\floor':'\\left\\lfloor #1 \\right\\rfloor',
                  '\\ceil':'\\left\\lceil #1 \\right\\rceil',
                  '\\abs':'\\left\\| #1 \\right\\|'
                  }
        var mathElements = document.getElementsByClassName("math");
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false, macros:macros} );
        }}});
    </script>
  <!-- Fathom - simple website analytics - https://github.com/usefathom/fathom -->
  <script>
  (function(f, a, t, h, o, m){
    a[h]=a[h]||function(){
      (a[h].q=a[h].q||[]).push(arguments)
    };
    o=f.createElement('script'),
    m=f.getElementsByTagName('script')[0];
    o.async=1; o.src=t; o.id='fathom-script';
    m.parentNode.insertBefore(o,m)
  })(document, window, '//track.chaoxuprime.com/tracker.js', 'fathom');
  fathom('set', 'siteId', 'DNRQY');
  fathom('trackPageview');
  </script>
  <!-- / Fathom -->

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-4171915-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-4171915-2');
  </script>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
  <link rel="stylesheet" href="/css/default.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/blog.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml" title="RSS"
      href="https://chaoxuprime.com/rss.xml">
  </head>
  <body>
    <header class="hide-on-print">
        <div id="site-title">
            <a href="/blog.html">The Art Gallery Guardian</a>
        </div>
    </header>
    <nav class="hide-on-print">
      <ul>
        <li><a href="/">About</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/files/cv.pdf">CV</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
    <main>
      <article>
        <h1 id="article-title">Lexicographic Bottleneck Shortest Path in Undirected Graphs</h1>
        <br />
<div>
<h1 id="lexicographic-bottleneck-ordering"><span class="header-section-number">1</span> Lexicographic Bottleneck Ordering</h1>
<p>Let <span class="math inline">X</span> be a totally ordered set. Let <span class="math inline">l(S)</span> be the sorted sequence of all the elements in <span class="math inline">S</span>, where <span class="math inline">S\subset X</span>. We can induce an total ordering on the subset of <span class="math inline">X</span>.</p>
<section class="theorem-environment Definition" id="Definition-1">
<span class="theorem-header"><span class="type">Definition</span><span class="index">1</span></span>
<p><span class="math inline">S\preccurlyeq T</span> for <span class="math inline">S,T\subset X</span> if <span class="math inline">l(S)\leq l(T)</span> in lexicographic ordering. <span class="math inline">\preccurlyeq</span> is called the lexicographic bottleneck ordering.</p>
</section>
<section class="theorem-environment Lemma" id="Lemma-2">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">2</span></span>
<p>For nonempty sets <span class="math inline">A</span> and <span class="math inline">B</span>, if <span class="math inline">A\preccurlyeq B</span> , then <span class="math inline">A - min A \preccurlyeq B - min B</span>. Also if <span class="math inline">A\preccurlyeq B</span> then <span class="math inline">A \preccurlyeq A\cup B \preccurlyeq B</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p><span class="math inline">A\preccurlyeq A&#39;</span>, <span class="math inline">B\preccurlyeq B&#39;</span> then <span class="math inline">A\cup B \preccurlyeq A&#39;\cup B&#39;</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">C=A\cup B</span> and <span class="math inline">C&#39; = A&#39;\cup B&#39;</span>.</p>
<p>Since <span class="math inline">\preccurlyeq</span> is a total order, we can prove it by showing if <span class="math inline">C&#39;\preccurlyeq C</span> then <span class="math inline">C&#39; = C</span>.</p>
<p>We prove it by structural induction on <span class="math inline">C&#39;</span>. The base case when <span class="math inline">C&#39; = \emptyset</span> is trivial, since it must mean <span class="math inline">A=B=A&#39;=B&#39;=\emptyset</span>.</p>
<p>Consider <span class="math inline">c&#39; = \min C&#39;, c = \min C</span>. <span class="math inline">c&#39;\leq c</span> in order for <span class="math inline">C&#39;\preccurlyeq C</span>. But we know <span class="math inline">c\leq c&#39;</span>. This shows <span class="math inline">c=c&#39;</span>. Given that <span class="math inline">c=c&#39;</span>, <span class="math inline">A&#39;\cup B&#39; = A\cup B</span> if and only if <span class="math inline">(A&#39;-c)\cup (B&#39;-c) = (A-c) \cup (B-c)</span>.</p>
<p>First, we show that <span class="math inline">A-c \preccurlyeq A&#39;-c</span>.</p>
<ol type="1">
<li>Assume <span class="math inline">c\in A</span>, then <span class="math inline">c\in A&#39;</span>, so by previous lemma this is true.</li>
<li>If <span class="math inline">c\not\in A</span> and <span class="math inline">c\not \in A&#39;</span>, then <span class="math inline">A-c=A\preccurlyeq A&#39;=A&#39;-c</span>.</li>
<li>If <span class="math inline">c\not \in A</span> but <span class="math inline">c\in A&#39;</span>, then this implies <span class="math inline">A</span> is empty, and <span class="math inline">\emptyset \preccurlyeq A&#39;-c</span>.</li>
</ol>
<p>Similarly, <span class="math inline">B-c\preccurlyeq B&#39;-c</span>.</p>
<p>Second, we need to show that <span class="math inline">(A&#39;-c)\cup (B&#39;-c) \preccurlyeq (A-c) \cup (B-c)</span>. This is obvious because <span class="math inline">C&#39;\preccurlyeq C</span> implies <span class="math inline">C&#39;-c \preccurlyeq C-c</span>.</p>
<p>By the inductive hypothesis, <span class="math inline">(A&#39;-c)\cup (B&#39;-c) = (A-c) \cup (B-c)</span>, thus completes the proof.</p>
</section>
<p>The theorem intuitively tells us how to partition a set into smaller sets.</p>
<h1 id="lexicographic-bottleneck-path"><span class="header-section-number">2</span> Lexicographic Bottleneck Path</h1>
<p>Given a undirected graph <span class="math inline">G=(V,E)</span>, and an ordering of the edges <span class="math inline">e_1,\ldots,e_m</span>. Let <span class="math inline">w(e_i)=i</span>.</p>
<section class="theorem-environment Problem" id="Problem-4">
<span class="theorem-header"><span class="type">Problem</span><span class="index">4</span><span class="name">Bottleneck Shortest Path</span></span>
<p>Find a <span class="math inline">st</span>-path that maximizes the minimum edge weight on the path.</p>
</section>
<p>Any <span class="math inline">st</span>-path that maximizes the minimum edge weight over all <span class="math inline">st</span>-paths is a <span class="math inline">st</span>-bottleneck shortest path(BSP). We are interested in a more general version of this problem. Find a path from <span class="math inline">s</span> to <span class="math inline">t</span> that is maximum with respect to the lexicographic bottleneck ordering <span class="math inline">\preccurlyeq</span> of the path.</p>
<section class="theorem-environment Problem" id="Problem-5">
<span class="theorem-header"><span class="type">Problem</span><span class="index">5</span><span class="name">Lexicographic Bottleneck Shortest Path</span></span>
<p>Find a <span class="math inline">st</span>-path <span class="math inline">P</span> such that <span class="math inline">P&#39;\preccurlyeq P</span> for all <span class="math inline">st</span>-path <span class="math inline">P&#39;</span>.</p>
</section>
<p>The unique <span class="math inline">st</span>-path that is maximum in lexicographic bottleneck order among all <span class="math inline">st</span>-paths is called the <span class="math inline">st</span>-lexicographic bottleneck shortest path(LBSP).</p>
<p>In order to find a BSP, we can first compute the maximum spanning tree <span class="math inline">T</span> of <span class="math inline">G</span>, as show in Lemma 4.1 of <span class="citation" data-cites="vertexbottle">[<a href="#ref-vertexbottle">1</a>]</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-6">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">6</span></span>
<p>If <span class="math inline">T</span> is a maximum spanning tree of <span class="math inline">G</span>(under the weight <span class="math inline">w</span>), then the unique <span class="math inline">st</span>-path in <span class="math inline">T</span> is a <span class="math inline">st</span>-BSP in <span class="math inline">G</span>.</p>
</section>
<p>It's interesting this theorem actually extends to LBSP.</p>
<section class="theorem-environment Theorem" id="Theorem-7">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p>If <span class="math inline">T</span> is a maximum spanning tree of <span class="math inline">G</span>(under the weight <span class="math inline">w</span>), then the unique <span class="math inline">st</span>-path in <span class="math inline">T</span> is the <span class="math inline">st</span>-LBSP in <span class="math inline">G</span>.</p>
</section>
<p>Before proving the theorem, we consider a useful lemma.</p>
<section class="theorem-environment Lemma" id="Lemma-8">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">8</span></span>
<p><span class="math inline">P</span> is a <span class="math inline">st</span>-BSP with bottleneck edge <span class="math inline">xy</span>. If removing edge <span class="math inline">xy</span> result a <span class="math inline">sx</span>-LBSP and <span class="math inline">yt</span>-LBSP, then <span class="math inline">P</span> is a <span class="math inline">st</span>-LBSP.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math inline">P</span> is a bottleneck <span class="math inline">st</span>-path implies the <span class="math inline">st</span>-LBSP has to reach either <span class="math inline">x</span> or <span class="math inline">y</span> before <span class="math inline">t</span>.</p>
<p>If it reaches <span class="math inline">y</span> before <span class="math inline">x</span>, then the subpath from <span class="math inline">s</span> to <span class="math inline">y</span> then from <span class="math inline">y</span> to <span class="math inline">t</span> using the <span class="math inline">yt</span>-LBSP would imply <span class="math inline">xy</span> is not in <span class="math inline">st</span>-LBSP, a contradiction.</p>
<p>Thus, we must have the <span class="math inline">st</span>-LBSP is a concatenation of <span class="math inline">3</span> paths, a <span class="math inline">sx</span>-path <span class="math inline">P_{sx}</span>, edge <span class="math inline">xy</span> and a <span class="math inline">yt</span>-path <span class="math inline">P_{ty}</span>. Using <a href="#Theorem-3">Theorem 3</a>, we notice <span class="math inline">P</span> is a LBSP.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span><span class="name"><a href="#Theorem-7">Theorem 7</a></span></span>
<p>We prove by induction on the distance between the two vertices on the maximum spanning tree <span class="math inline">T</span>.</p>
<p><strong>Base Case:</strong> If the length of a <span class="math inline">uv</span> on <span class="math inline">T</span> is <span class="math inline">1</span>, then the edge <span class="math inline">uv</span> is a BSP, and also a LBSP.</p>
<p><strong>Inductive Step:</strong> Consider two vertices <span class="math inline">s</span> and <span class="math inline">t</span>. The tree induces a <span class="math inline">st</span>-BSP with bottleneck edge <span class="math inline">xy</span>. By the inductive hypothesis, removing <span class="math inline">xy</span> result a <span class="math inline">sx</span>-LBSP and <span class="math inline">yt</span>-LBSP in <span class="math inline">G</span>. The previous lemma demonstrates that <span class="math inline">st</span>-BSP in <span class="math inline">T</span> is a <span class="math inline">st</span>-LBSP in <span class="math inline">G</span>.</p>
</section>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-vertexbottle">
<p>[1] A. Shapira, R. Yuster, U. Zwick, <strong>All-pairs bottleneck paths in vertex weighted graphs</strong>, Algorithmica. 59 (2011) 621–633 <a href="https://doi.org/10.1007/s00453-009-9328-x">10.1007/s00453-009-9328-x</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-05-10. </div>
    <div class="info">Tags: algorithm.</div>

</div>
      </article>
    </main>
    <footer class="hide-on-print">© 2010 - <time><script>document.write(new Date().getFullYear())</script></time> <a href="https://chaoxuprime.com">Chao Xu</a>. Licensed under <a href="http://www.wtfpl.net/txt/copying/">WTFPL v2</a> unless otherwise specified. <a href="/README.html">Blog README</a>.</footer>
  </body>
</html>
