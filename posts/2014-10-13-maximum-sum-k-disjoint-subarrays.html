<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Art Gallery Guardian">
    <meta name="author" content="Chao Xu">
    <meta name="google-site-verification" content="YE2oeW4OwVOPdVVfdpYIakOuD0A2Qo80W_sUbMJDGok" />
    <meta name="referrer" content="origin">
    <title>Maximum sum $k$-disjoint subarrays</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          var macros={
                  "\\C":"\\mathbb{C}",
                  "\\F":"\\mathbb{F}",
                  "\\e": "\\varepsilon",
                  "\\eps": "\\varepsilon",
                  "\\argmin": "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits",
                  "\\argmax": "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits",
                  "\\mex": "\\mathop{\\operatorname{mex}}",
                  "\\lcm": "\\mathop{\\operatorname{lcm}}",
                  "\\dist": "\\mathop{\\operatorname{dist}}",
                  "\\bigtriangleright": "{\\mathop{\\Large \\triangleright}}",
                  "\\bigtriangleleft": "{\\mathop{\\Large \\triangleleft}}",
                  '\\set':'\\left\\{ #1 \\right\\}',
                  '\\floor':'\\left\\lfloor #1 \\right\\rfloor',
                  '\\ceil':'\\left\\lceil #1 \\right\\rceil',
                  '\\abs':'\\left\\| #1 \\right\\|'
                  }
        var mathElements = document.getElementsByClassName("math");
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false, macros:macros} );
        }}});
    </script>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
  <link rel="stylesheet" href="/css/default.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/blog.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml" title="RSS"
      href="https://chaoxuprime.com/rss.xml">
  </head>
  <body>
    <header class="hide-on-print">
        <div id="site-title">
            <a href="/blog.html">The Art Gallery Guardian</a>
        </div>
    </header>
    <nav class="hide-on-print">
      <ul>
        <li><a href="/">About</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/files/cv.pdf">CV</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
    <main>
      <article>
        <h1 id="article-title">Maximum sum <span class="math inline">k</span>-disjoint subarrays</h1>
        <br />
<div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>A common problem, the <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem">maximum subarray problem</a> asks the subarray with the maximum sum.</p>
<p>There are many generalizations, for example into higher dimensions. In 2D, a <span class="math inline">n\times n</span> matrix, a common solution takes <span class="math inline">O(n^3)</span> time<span class="citation" data-cites="TamakiT98 Takaoka02">[<a href="#ref-TamakiT98">1</a>,<a href="#ref-Takaoka02">2</a>]</span>. There is no <span class="math inline">O(n^{3-\e})</span> algorithm assuming All-Pairs Shortest Paths cannot be solved in <span class="math inline">O(n^{3-\e})</span> for some constant <span class="math inline">\e&gt;0</span> <span class="citation" data-cites="BackursDT16">[<a href="#ref-BackursDT16">3</a>]</span>.</p>
<p>Another way is to understand it as a graph problem. We are given a path, and there are weights on the vertices. We require a maximum weight connected subgraph. The problem is NP-hard even for planar graphs. However, it is solvable in polynomial time for bounded treewidth graphs <span class="citation" data-cites="Álvarez-MirandaLM13">[<a href="#ref-Álvarez-MirandaLM13">4</a>]</span>.</p>
<p>We consider a similar problem where instead of a single subarray, we want at most <span class="math inline">k</span> disjoint subarrays, such that the sum together is maximized. In fact, this is the <a href="http://www.lintcode.com/en/problem/maximum-subarray-iii/">Maximum Subarray III problem on LintCode</a>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Maximum <span class="math inline">k</span>-Disjoint Subarray Problem</span></span>
<p>Given array <span class="math inline">A[1..n]</span>, find a non-decreasing sequence of indices <span class="math inline">i_1,\ldots,i_{2k}</span>, such that <span class="math inline">\sum_{i=1}^k \sum_{j=i_{2i-1}}^{2i} A[j]</span> is maximized.</p>
</section>
<p>There is obviously an <span class="math inline">O(nk)</span> algorithm by extending the dynamic programming algorithm for the <span class="math inline">k=1</span> case.</p>
<h1 id="solutions"><span class="header-section-number">2</span> Solutions</h1>
<h2 id="dynamic-programming"><span class="header-section-number">2.1</span> Dynamic Programming</h2>
<p>Let <span class="math inline">f(i,k)</span> to be the maximum value obtainable by <span class="math inline">k</span> subarray of <span class="math inline">A[1..i]</span>. Let <span class="math inline">g(i,k)</span> to be the maximum value obtainable by <span class="math inline">k</span> subarray of <span class="math inline">A[1..i]</span>, that uses the <span class="math inline">i</span>th value in the last subarray. The recurrence <span class="math inline">f(i,k) = \min(f(i,k-1),f(i-1,k),g(i,k))</span>, and <span class="math inline">g(i,k) = \min(g(i-1,k)+A[i],f(i-1,k-1)+A[i])</span> solves the problem.</p>
<h2 id="greedy"><span class="header-section-number">2.2</span> Greedy</h2>
<p>This kind of solution would possibly work on interviews. But can we do better? It is in fact possible to get <span class="math inline">O(n\log n)</span> with some care.</p>
<p>wlog, let's assume the array is alternating, where all odd index are positive and all even index are negative. If we have the solution for the <span class="math inline">k</span> case, we can get a solution for <span class="math inline">k-1</span> case by either discard one of the arrays or &quot;merge&quot; two adjacent arrays by taking a negative piece in the middle.</p>
<p>This shows that once we have the solution for the <span class="math inline">k</span> case, we can just &quot;contract&quot; a entire subarray into one single value. Csűrös showed that we can just use one merge operation<span class="citation" data-cites="Csuros04">[<a href="#ref-Csuros04">5</a>]</span>. It find a array element with minimum absolute value, say it's <span class="math inline">A[i]</span>, then it is replaced by <span class="math inline">A[i-1]+A[i]+A[i+1]</span>, and then we remove <span class="math inline">A[i-1]</span> and <span class="math inline">A[i+1]</span> from the array. (For boundary cases, assume <span class="math inline">A[0]=A[n+1]=0</span>). The idea is a merge can &quot;discard&quot; a value, and a merge is also adding a negative piece and then do contraction. This operation is done until there are exactly <span class="math inline">k</span> positive numbers, which in that case, the best solution is to just take all <span class="math inline">k</span> of them.</p>
<p>Thus this implies a <span class="math inline">O(n\log n)</span> greedy algorithm, by keep merging and keep track of min absolute value item using a heap. Interestingly, this algorithm was also suggested by students in <a href="https://courses.engr.illinois.edu/cs473/">CS 473</a>. <a href="http://web.engr.illinois.edu/~hchang17/">Hsien-Chih</a> and I discovered it is correct by failing to find counterexamples to the greedy approach.</p>
<h2 id="speed-up-greedy"><span class="header-section-number">2.3</span> Speed up greedy</h2>
<p>One can see the smallest absolute value does not decrease throughout the algorithm, so instead of just keep finding and merging the item with smallest absolute value, what if one just keep merge merge item with absolute value smaller than <span class="math inline">t</span>? There are three possibilities: we picked <span class="math inline">t</span> so nicely that after all the merges, we get exactly <span class="math inline">k</span> positive elements left. We picked <span class="math inline">t</span> too large, we get less than <span class="math inline">k</span> positive elements. We picked <span class="math inline">t</span> too small, and we get more than <span class="math inline">k</span> positive elements.</p>
<p>Bengtsson and Chen uses this idea<span class="citation" data-cites="Bengtsson06">[<a href="#ref-Bengtsson06">6</a>]</span>. They showed they can guess <span class="math inline">t</span> in a way such that the some measure of the problem size gets smaller by at least <span class="math inline">2/3</span>, and also shows how to keep track of the merges so it takes <span class="math inline">O(n\alpha(n))</span> time. Later on, they removed the need of the union-find data structure improved the time bound to the optimal <span class="math inline">O(n)</span> time <span class="citation" data-cites="Bengtsson07">[<a href="#ref-Bengtsson07">7</a>]</span>.</p>
<h2 id="optimal-running-time-reducing-to-k1-queries"><span class="header-section-number">2.4</span> Optimal running time reducing to <span class="math inline">k=1</span> queries</h2>
<p>There are other approaches to obtain the same running time. We can consider a query version of the problem when <span class="math inline">k=1</span>. Given indices <span class="math inline">i</span> and <span class="math inline">j</span>, find indices <span class="math inline">i&#39;</span> and <span class="math inline">j&#39;</span> such that <span class="math inline">i\leq i&#39;\leq j&#39;\leq j</span>, and sum of the elements in <span class="math inline">A[i&#39;..j&#39;]</span> is maximized. Chen and Chao showed how to use a data structure that can be built in <span class="math inline">O(n)</span> time, and return the solution to the above query in <span class="math inline">O(1)</span> time <span class="citation" data-cites="ChenC07">[<a href="#ref-ChenC07">8</a>]</span>. It is not a simple data structure. Gawrychowski and Nicholson showed such data structure can be used to solve the <a href="#Problem-1">Problem 1</a> in <span class="math inline">O(n)</span> time <span class="citation" data-cites="GawrychowskiN15">[<a href="#ref-GawrychowskiN15">9</a>]</span>. The reduction is easy, but again the bottleneck is the heavy hammers to build the data structure.</p>
<h2 id="a-very-simple-solution"><span class="header-section-number">2.5</span> A very simple solution</h2>
<p>Recently, I've seen a truly simple result. A related problem is the following.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given array <span class="math inline">B[1..n]</span>, find a non-decreasing sequence of indices <span class="math inline">i_1,\ldots,i_{2k}</span>, such that <span class="math inline">\sum_{i=1}^k B[i_{2i}]-B[i_{2i-1}]</span> is maximized.</p>
</section>
<p>This problem is featured in interviews, and is also <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">on leetcode as Best time to buy an sell stock IV</a> and showed up in codeforces as <a href="http://codeforces.com/contest/391/problem/F3">stock trading</a>. <a href="#Problem-1">Problem 1</a> and <a href="#Problem-2">Problem 2</a> can be reduced to each other in linear time. For one direction, we can define <span class="math inline">B[i]=\sum_{j=1}^i A[j]</span>. The other direction, we let <span class="math inline">A[i]=B[i]-B[i-1]</span> for all <span class="math inline">i</span>. The editorial in codeforces showed <a href="http://codeforces.com/blog/entry/10727">a solution similar to <span class="citation" data-cites="Bengtsson07">[<a href="#ref-Bengtsson07">7</a>]</span></a> for <a href="#Problem-2">Problem 2</a>.</p>
<p>A surprising algorithm for <a href="#Problem-2">Problem 2</a> was found by <a href="https://zhiqingxiao.weebly.com">Zhiqing Xiao</a> that claims to solve the problem in <span class="math inline">O(n)</span> time by building upon the <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54118/C%2B%2B-Solution-with-O(n-%2B-klgn)-time-using-Max-Heap-and-Stack">observation of leetcode user yishiluo</a>. Hence it shows <a href="#Problem-1">Problem 1</a> can be solved in linear time, and the only (a bit) heavy hammer is the <a href="https://en.wikipedia.org/wiki/Selection_algorithm">selection algorithm</a>. Although the solution is simple, it is fairly unclear how to prove correctness. <a href="http://maskray.me">Fangrui Song</a> wrote <a href="http://maskray.me/blog/2015-03-27-leetcode-best-time-to-buy-and-sell-stock-iv">a better explanation</a> in Chinese. Although it still does not fully prove correctness, it is a step toward a proof.</p>
<h1 id="open-problem"><span class="header-section-number">3</span> Open problem</h1>
<p>Can we find a linear time algorithm for trees? (either weights on edges or on vertices)</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-TamakiT98">
<p>[1] H. Tamaki, T. Tokuyama, Algorithms for the maximum subarray problem based on matrix multiplication, in: Proceedings of the Ninth Annual Acm-Siam Symposium on Discrete Algorithms, Society for Industrial; Applied Mathematics, Philadelphia, PA, USA, 1998: pp. 446–452.</p>
</div>
<div id="ref-Takaoka02">
<p>[2] T. Takaoka, <strong>Efficient algorithms for the maximum subarray problem by distance matrix multiplication</strong>, Electronic Notes in Theoretical Computer Science. 61 (2002) 191–200 <a href="https://doi.org/10.1016/S1571-0661(04)00313-5">10.1016/S1571-0661(04)00313-5</a>.</p>
</div>
<div id="ref-BackursDT16">
<p>[3] A. Backurs, N. Dikkala, C. Tzamos, Tight Hardness Results for Maximum Weight Rectangles, in: I. Chatzigiannakis, M. Mitzenmacher, Y. Rabani, D. Sangiorgi (Eds.), 43rd International Colloquium on Automata, Languages, and Programming (Icalp 2016), Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany, 2016: pp. 81:1–81:13 <a href="https://doi.org/10.4230/LIPIcs.ICALP.2016.81">10.4230/LIPIcs.ICALP.2016.81</a>.</p>
</div>
<div id="ref-Álvarez-MirandaLM13">
<p>[4] E. Álvarez-Miranda, I. Ljubić, P. Mutzel, The maximum weight connected subgraph problem, in: M. Jünger, G. Reinelt (Eds.), Facets of Combinatorial Optimization: Festschrift for Martin Grötschel, Springer Berlin Heidelberg, Berlin, Heidelberg, 2013: pp. 245–270 <a href="https://doi.org/10.1007/978-3-642-38189-8_11">10.1007/978-3-642-38189-8_11</a>.</p>
</div>
<div id="ref-Csuros04">
<p>[5] M. Csürös, <strong>Maximum-scoring segment sets</strong>, IEEE/ACM Trans. Comput. Biology Bioinform. 1 (2004) 139–150 <a href="https://doi.org/10.1109/TCBB.2004.43">10.1109/TCBB.2004.43</a>.</p>
</div>
<div id="ref-Bengtsson06">
<p>[6] F. Bengtsson, J. Chen, Computing maximum-scoring segments in almost linear time, in: Computing and Combinatorics, 12th Annual International Conference, COCOON 2006, Taipei, Taiwan, August 15-18, 2006, Proceedings, 2006: pp. 255–264 <a href="https://doi.org/10.1007/11809678_28">10.1007/11809678_28</a>.</p>
</div>
<div id="ref-Bengtsson07">
<p>[7] F. Bengtsson, J. Chen, <strong>Computing maximum-scoring segments optimally</strong>, Luleå University of Technology, 2007.</p>
</div>
<div id="ref-ChenC07">
<p>[8] K.-Y. Chen, K.-M. Chao, <strong>On the range maximum-sum segment query problem</strong>, Discrete Applied Mathematics. 155 (2007) 2043–2052 <a href="https://doi.org/https://doi.org/10.1016/j.dam.2007.05.018">https://doi.org/10.1016/j.dam.2007.05.018</a>.</p>
</div>
<div id="ref-GawrychowskiN15">
<p>[9] P. Gawrychowski, P.K. Nicholson, Encodings of range maximum-sum segment queries and applications, in: F. Cicalese, E. Porat, U. Vaccaro (Eds.), Combinatorial Pattern Matching, Springer International Publishing, Cham, 2015: pp. 196–206.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-10-13. </div>
    <div class="info">Tags: classic, algorithm.</div>

</div>
      </article>
    </main>
    <footer class="hide-on-print">© 2010 - <time><script>document.write(new Date().getFullYear())</script></time> <a href="https://chaoxuprime.com">Chao Xu</a>. Licensed under <a href="http://www.wtfpl.net/txt/copying/">WTFPL v2</a> unless otherwise specified. <a href="/README.html">Blog README</a>.</footer>
  </body>
</html>
