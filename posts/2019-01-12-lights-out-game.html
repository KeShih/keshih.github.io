<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Art Gallery Guardian">
    <meta name="author" content="Chao Xu">
    <meta name="google-site-verification" content="YE2oeW4OwVOPdVVfdpYIakOuD0A2Qo80W_sUbMJDGok" />
    <meta name="referrer" content="origin">
    <title>Lights out game on a grid</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          var macros={
                  "\\C":"\\mathbb{C}",
                  "\\F":"\\mathbb{F}",
                  "\\e": "\\varepsilon",
                  "\\eps": "\\varepsilon",
                  "\\argmin": "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits",
                  "\\argmax": "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits",
                  "\\mex": "\\mathop{\\operatorname{mex}}",
                  "\\lcm": "\\mathop{\\operatorname{lcm}}",
                  "\\dist": "\\mathop{\\operatorname{dist}}",
                  "\\bigtriangleright": "{\\mathop{\\Large \\triangleright}}",
                  "\\bigtriangleleft": "{\\mathop{\\Large \\triangleleft}}",
                  '\\set':'\\left\\{ #1 \\right\\}',
                  '\\floor':'\\left\\lfloor #1 \\right\\rfloor',
                  '\\ceil':'\\left\\lceil #1 \\right\\rceil',
                  '\\abs':'\\left\\| #1 \\right\\|'
                  }
        var mathElements = document.getElementsByClassName("math");
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false, macros:macros} );
        }}});
    </script>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
  <link rel="stylesheet" href="/css/default.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/blog.css" crossorigin="anonymous">
  </head>
  <body>
    <header class="hide-on-print">
        <div id="site-title">
            <a href="/blog.html">The Art Gallery Guardian</a>
        </div>
    </header>
    <nav class="hide-on-print">
      <ul>
        <li><a href="/">About</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/files/cv.pdf">CV</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
    <main>
      <article>
        <h1 id="article-title">Lights out game on a grid</h1>
        <br />
<div>
<h6 id="section" type="Problem" index="1" name=""><span class="header-section-number">0.0.0.0.0.1</span> </h6>
<p>Let <span class="math inline">G</span> be a graph, let <span class="math inline">A</span> be the adjacency matrix of <span class="math inline">G</span>. Solve the equation <span class="math inline">Ax=b</span> in <span class="math inline">\F_2</span>.</p>
<p>The problem is equivalent to the <a href="https://en.wikipedia.org/wiki/Lights_Out_%28game%29">lights out game</a>. Each vertex has state <span class="math inline">0</span> or <span class="math inline">1</span>. Activate a vertex flips the state of itself and all its neighbors. Find a set of activations that turns all state into <span class="math inline">0</span>. Originally I thought this problem can be solved in <span class="math inline">O(n^{\omega/2})</span> when <span class="math inline">G</span> is planar graph on <span class="math inline">n</span> vertices by <a href="https://en.wikipedia.org/wiki/Nested_dissection">nested dissection</a>. However, only recently I found out the matrix must be non-singular. Therefore nested dissection does not apply.</p>
<p>Recently I saw an algorithm that shows if the graph is a <span class="math inline">n\times n</span> grid, then it can be solved in <span class="math inline">O(n^3)</span> time. The solution in Chinese and can be seen <a href="https://zhuanlan.zhihu.com/p/53646257">here</a>.</p>
<p>Given a <span class="math inline">n\times n</span> grid graph. Let <span class="math inline">v_{i,j}</span> be the node on the <span class="math inline">i</span>th row and <span class="math inline">j</span>th column. Let <span class="math inline">b_{i,j}</span> be the state of the vertex <span class="math inline">v_{i,j}</span>. The state is in <span class="math inline">\F_2</span> If we activates a node, the state of the node and its neighbors change by <span class="math inline">1</span>. The set of activated node is called the activation set.</p>
<p>We are interested in finding an activation set <span class="math inline">S</span>, such the state of all nodes after activate <span class="math inline">S</span> is <span class="math inline">0</span>.</p>
<p>Let <span class="math inline">S</span> be the activation set, and <span class="math inline">S_1</span> to be the activation set of the first row.</p>
<h6 id="section-1" type="Theorem" index="2" name=""><span class="header-section-number">0.0.0.0.0.2</span> </h6>
<p><span class="math inline">S_1</span> uniquely determines <span class="math inline">S</span>. Moreover, One can compute <span class="math inline">S</span> from <span class="math inline">S_1</span> in <span class="math inline">O(n^2)</span> time.</p>
<h6 id="section-2" type="Proof" index="" name=""><span class="header-section-number">0.0.0.0.0.3</span> </h6>
<p>Indeed, consider apply activation to the nodes in <span class="math inline">S_1</span>. Consider any vertex in row <span class="math inline">1</span>. If it <span class="math inline">0</span>, then the remaining neighbor (on the second row) cannot be activated. If it is <span class="math inline">1</span>, then the remaining neighbor has to be activated.</p>
<p>Let <span class="math inline">D[i,j]</span> indicates if we activate <span class="math inline">v_{i,j}</span> or not. We create formal variables <span class="math inline">Z=\set{z_1,\ldots,z_n}</span>. Here <span class="math inline">z_i</span> is an indicator variable that represents if <span class="math inline">v_{1,i}</span> is activated or not. The base case <span class="math inline">D[1,j] = z_j</span>. The observation shows that for each <span class="math inline">i</span> and <span class="math inline">j</span>, <span class="math inline">D[i+1,j] = 1 + D[i,j-1]+D[i,j]+D[i,j+1]+D[i-1,j]+b_{i,j}</span>. We can express <span class="math inline">D[i,j]</span> as a sum of elements in <span class="math inline">Z</span> and a constant, and we are summing a constant number of previous states. So it has size <span class="math inline">O(n)</span>. We can compute the expression of <span class="math inline">D[i,j]</span> in <span class="math inline">O(n)</span> time. So computing all <span class="math inline">D[i,j]</span> for <span class="math inline">i\geq 2</span> takes <span class="math inline">O(n^3)</span> time.</p>
<p>We are interested in <span class="math inline">D[n,1],\ldots,D[n,n]</span>. We can see it is of the following form.</p>
<span class="math">\begin{align*}
D[n,1] &= c_{1,1} z_1+\ldots +c_{1,n} z_{n} + u_{1}\\
D[n,2] &= c_{2,1} z_1+\ldots +c_{2,n} z_{n} + u_{2}\\
 \vdots &\qquad  \vdots\\
D[n,n] &= c_{m,1} z_1+\ldots + c_{m,n} z_n + u_{n}\\
\end{align*}</span>
<p>We solve the equation <span class="math inline">Cz=u</span>. Note here <span class="math inline">C</span> is just a <span class="math inline">n\times n</span> matrix. We finds <span class="math inline">z_1,\ldots,z_n</span>. So now we have found the activation set restricted on the first row. We can use it to find the entire activation set.</p>
<p>The total running time is <span class="math inline">O(n^3)</span>. Building the table <span class="math inline">D</span> and solving <span class="math inline">Cz=u</span>. One can generalize this a bit further. We can obtain <span class="math inline">O(m^2n)</span> running time for a <span class="math inline">m\times n</span> grid, where <span class="math inline">m\leq n</span>. Also, there is no reason we have to work in <span class="math inline">\F_2</span>, any arbitrary field is fine.</p>
<h6 id="section-3" type="Theorem" index="3" name=""><span class="header-section-number">0.0.0.0.0.4</span> </h6>
<p>Let <span class="math inline">G</span> be a <span class="math inline">m\times n</span> grid and <span class="math inline">A</span> is a matrix where the non-zero entires are precisely the position of <span class="math inline">1</span>s in the adjacency matrix of <span class="math inline">A</span>. Finding <span class="math inline">Ax=b</span> can be done in <span class="math inline">O(m^2n)</span> time.</p>
<p>I did not think too much into it, but maybe it works for all integral domains too. Interestingly, this algorithm is so special, that we have no idea how to extend it to other graphs. Maybe it works for directed graph, maybe it works for subgraph of the grid graphs.</p>
<p>It would be really interesting to see an algorithm with running time <span class="math inline">O(n^{3/2})</span> for a planar graph of <span class="math inline">n</span> vertices.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-12. </div>
    <div class="info">Tags: algorithm, algebra.</div>

</div>
      </article>
    </main>
    <footer class="hide-on-print">Â© 2010 - <time><script>document.write(new Date().getFullYear())</script></time> <a href="https://chaoxuprime.com">Chao Xu</a>. Licensed under <a href="http://www.wtfpl.net/txt/copying/">WTFPL v2</a> unless otherwise specified. <a href="/README.html">Blog README</a>.</footer>
  </body>
</html>
