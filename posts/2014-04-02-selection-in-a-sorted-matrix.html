<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Art Gallery Guardian">
    <meta name="author" content="Chao Xu">
    <meta name="google-site-verification" content="YE2oeW4OwVOPdVVfdpYIakOuD0A2Qo80W_sUbMJDGok" />
    <meta name="referrer" content="origin">
    <title>Selection in a sorted matrix</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          var macros={
                  "\\C":"\\mathbb{C}",
                  "\\F":"\\mathbb{F}",
                  "\\e": "\\varepsilon",
                  "\\eps": "\\varepsilon",
                  "\\argmin": "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits",
                  "\\argmax": "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits",
                  "\\mex": "\\mathop{\\operatorname{mex}}",
                  "\\lcm": "\\mathop{\\operatorname{lcm}}",
                  "\\dist": "\\mathop{\\operatorname{dist}}",
                  "\\bigtriangleright": "{\\mathop{\\Large \\triangleright}}",
                  "\\bigtriangleleft": "{\\mathop{\\Large \\triangleleft}}",
                  '\\set':'\\left\\{ #1 \\right\\}',
                  '\\floor':'\\left\\lfloor #1 \\right\\rfloor',
                  '\\ceil':'\\left\\lceil #1 \\right\\rceil',
                  '\\abs':'\\left\\| #1 \\right\\|'
                  }
        var mathElements = document.getElementsByClassName("math");
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false, macros:macros} );
        }}});
    </script>
  <!-- Fathom - simple website analytics - https://github.com/usefathom/fathom -->
  <script>
  if(window.location.hostname === "chaoxuprime.com"){
    (function(f, a, t, h, o, m){
      a[h]=a[h]||function(){
        (a[h].q=a[h].q||[]).push(arguments)
      };
      o=f.createElement('script'),
      m=f.getElementsByTagName('script')[0];
      o.async=1; o.src=t; o.id='fathom-script';
      m.parentNode.insertBefore(o,m)
    })(document, window, '//track.chaoxuprime.com/tracker.js', 'fathom');
    fathom('set', 'siteId', 'DNRQY');
    fathom('trackPageview');
  }
  </script>
  <!-- / Fathom -->

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-4171915-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-4171915-2');
  </script>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
  <link rel="stylesheet" href="/css/default.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/blog.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml" title="RSS"
      href="https://chaoxuprime.com/rss.xml">
  </head>
  <body>
    <header class="hide-on-print">
        <div id="site-title">
            <a href="/blog.html">The Art Gallery Guardian</a>
        </div>
    </header>
    <nav class="hide-on-print">
      <ul>
        <li><a href="/">About</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/files/cv.pdf">CV</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
    <main>
      <article>
        <h1 id="article-title">Selection in a sorted matrix</h1>
        <br />
<div>
<p>A matrix is sorted if every row and column are non-increasing.</p>
<p>A common interview problem asks for the <span class="math inline">k</span>th smallest number in a sorted matrix, and usually people give an <span class="math inline">O(k\log k)</span> algorithm. Wlog we can assume all the numbers in the matrix are distinct, as we can always break the ties by factoring in the position of the number in the matrix.</p>
<p>There is a <span class="math inline">O(k)</span> time solution. In fact, <span class="math inline">O(\min(k, m))</span> if it's a <span class="math inline">n\times m</span> matrix and <span class="math inline">n\leq m</span>.</p>
<p>I'm frustrated that there isn't a good description of such an algorithm. The most common reference people provide is <span class="citation" data-cites="Mirzaian198513">[<a href="#ref-Mirzaian198513">1</a>]</span>. However there are a few downsides of that paper. It only works when <span class="math inline">n=m</span> and it is still a bit complicated. So here I will give a short description to a modified version of the algorithm.</p>
<p>One can see the idea closely resemble what happens in fractional cascading, we basically squeeze the unknown values between known values, so we don't have to look at most of the unknown values.</p>
<p>First, we assume the matrix we care about is a <span class="math inline">n\times m</span> matrix <span class="math inline">A</span>. Both <span class="math inline">n</span> and <span class="math inline">m</span> are power of <span class="math inline">2</span> and <span class="math inline">n\leq m</span>.</p>
<p>Let <span class="math inline">A_o</span> be the matrix we get by removing all even index columns from <span class="math inline">A</span>, and add the last column.</p>
<p>In <span class="citation" data-cites="Mirzaian198513">[<a href="#ref-Mirzaian198513">1</a>]</span>, they used <span class="math inline">A_{o,o}</span>, which is defined as only retain positions with odd coordinates, but I found it nicer to consider things by only stripping one coordinate. In particular, it gave a much nicer proof for the following result.</p>
<section class="theorem-environment Definition" id="Definition-1">
<span class="theorem-header"><span class="type">Definition</span><span class="index">1</span></span>
<p><span class="math inline">r(a,A)</span> is the number of elements in matrix <span class="math inline">A</span> smaller or equal to <span class="math inline">a</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Let <span class="math inline">A</span> be a sorted <span class="math inline">n\times m</span> matrix, then <span class="math inline">2(r(a,A_o) - n) \leq r(a,A)\leq 2r(a,A_o)</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>For any fixed <span class="math inline">i</span>, let <span class="math inline">f(i)</span> be the largest <span class="math inline">j</span>, such that <span class="math inline">A_{i,j}\geq a</span>. <span class="math inline">r(a,A)=\sum_{i=1}^n f(i)</span>, <span class="math inline">r(a,A_o)=\sum_{i=1}^n \lceil f(i)/2 \rceil \leq r(a,A)/2 +n</span>. On the other hand <span class="math inline">\sum_{i=1}^n f(i)/2 \leq r(a,A_o)</span>.</p>
</section>
<p>This means if we want to find an element of rank <span class="math inline">k</span> in <span class="math inline">A</span>, we can first find element of rank <span class="math inline">k/2+n</span> and <span class="math inline">k/2</span> in <span class="math inline">A_o</span>, and we know the solution would be in between. The remaining operation takes <span class="math inline">O(m)</span> time:</p>
<ol type="1">
<li>Use a flood fill starting from the position of <span class="math inline">k/2</span>th element in <span class="math inline">A_o</span> and find at most <span class="math inline">2n</span> positions where the element of rank <span class="math inline">k</span> could reside. Namely it select elements in <span class="math inline">A</span> that is in between the <span class="math inline">k/2</span>th element and <span class="math inline">k/2+n</span>th in <span class="math inline">A_o</span>. We can do this because all these elements are connected in a component.</li>
<li>While doing the flood fill, it can also find the rank of the <span class="math inline">k/2</span>th element in <span class="math inline">A_o</span> in the matrix <span class="math inline">A</span> for no extra cost.</li>
<li>A linear time selection algorithm on all the elements resulted from the flood fill.</li>
</ol>
<p>This would give us a recursive algorithm if instead of just finding <span class="math inline">k</span>th number, it finds the <span class="math inline">k_1</span>th and <span class="math inline">k_2</span>th number at the same time. As long as <span class="math inline">|k_1-k_2|=O(m)</span>, we can find them both only with a <span class="math inline">O(m)</span> extra time. <span class="math inline">k_1</span> and <span class="math inline">k_2</span> will be the upper and lower bounds respectively. Some basic algebra shows <span class="math inline">|k_1-k_2|=O(m)</span> inside each recursive step if we start with <span class="math inline">k_1=k_2=k</span>.</p>
<p>Let <span class="math inline">T(n,m)</span> be the time used when the matrix is of size <span class="math inline">n\times m</span>, and <span class="math inline">n\leq m</span>. Certainly <span class="math inline">T(1,m)=1</span>, and the rest follow the recursive relation <span class="math inline">T(n,m) = cm + T(n,m/2)</span> for some constant <span class="math inline">c</span>.</p>
<p>If <span class="math inline">n&gt;m</span>, we can rotate the matrix implicitly to get the same running time.</p>
<p>Solving it gives us the desired running time <span class="math inline">O(m)</span>. This is also a <span class="math inline">O(k)</span> time algorithm because we only need to consider the <span class="math inline">k\times k</span> submatrix in the up-left position.</p>
<p>A Haskell implementation here, it requires a linear time rank selection algorithm <code>selectRank</code>.</p>
<script src="https://gist.github.com/chaoxu/81ab728730e6a65524cc4262c9dd0e80.js?file=MatrixRankSelection.hs"></script>
<p>Note a slightly faster algorithm also exists when <span class="math inline">n</span> and <span class="math inline">m</span> are very different. It was shown selecting the <span class="math inline">k</span>th element can be done in <span class="math inline">O(n\log m/n)</span> time <span class="citation" data-cites="FredericksonJ84">[<a href="#ref-FredericksonJ84">2</a>]</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Mirzaian198513">
<p>[1] A. Mirzaian, E. Arjomandi, <strong>Selection in x + y and matrices with sorted rows and columns</strong>, Information Processing Letters. 20 (1985) 13–17.</p>
</div>
<div id="ref-FredericksonJ84">
<p>[2] G. Frederickson, D. Johnson, <strong>Generalized selection and ranking: Sorted matrices</strong>, SIAM Journal on Computing. 13 (1984) 14–30 <a href="https://doi.org/10.1137/0213002">10.1137/0213002</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-04-02. </div>
    <div class="info">Tags: .</div>

</div>
      </article>
    </main>
    <footer class="hide-on-print">© 2010 - <time><script>document.write(new Date().getFullYear())</script></time> <a href="https://chaoxuprime.com">Chao Xu</a>. Licensed under <a href="http://www.wtfpl.net/txt/copying/">WTFPL v2</a> unless otherwise specified. <a href="/README.html">Blog README</a>.</footer>
  </body>
</html>
