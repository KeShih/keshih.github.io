<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Art Gallery Guardian">
    <meta name="author" content="Chao Xu">
    <meta name="google-site-verification" content="YE2oeW4OwVOPdVVfdpYIakOuD0A2Qo80W_sUbMJDGok" />
    <meta name="referrer" content="origin">
    <title>A Reviewer Assignment Problem</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          var macros={
                  "\\C":"\\mathbb{C}",
                  "\\F":"\\mathbb{F}",
                  "\\e": "\\varepsilon",
                  "\\eps": "\\varepsilon",
                  "\\argmin": "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits",
                  "\\argmax": "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits",
                  "\\mex": "\\mathop{\\operatorname{mex}}",
                  "\\lcm": "\\mathop{\\operatorname{lcm}}",
                  "\\dist": "\\mathop{\\operatorname{dist}}",
                  "\\bigtriangleright": "{\\mathop{\\Large \\triangleright}}",
                  "\\bigtriangleleft": "{\\mathop{\\Large \\triangleleft}}",
                  '\\set':'\\left\\{ #1 \\right\\}',
                  '\\floor':'\\left\\lfloor #1 \\right\\rfloor',
                  '\\ceil':'\\left\\lceil #1 \\right\\rceil',
                  '\\abs':'\\left\\| #1 \\right\\|'
                  }
        var mathElements = document.getElementsByClassName("math");
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false, macros:macros} );
        }}});
    </script>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
  <link rel="stylesheet" href="/css/default.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/blog.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml" title="RSS"
      href="https://chaoxuprime.com/rss.xml">
  </head>
  <body>
    <header class="hide-on-print">
        <div id="site-title">
            <a href="/blog.html">The Art Gallery Guardian</a>
        </div>
    </header>
    <nav class="hide-on-print">
      <ul>
        <li><a href="/">About</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/files/cv.pdf">CV</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
    <main>
      <article>
        <h1 id="article-title">A Reviewer Assignment Problem</h1>
        <br />
<div>
<p>Consider there are some reviewers and some papers. Each reviewer can review exactly one paper, and each reviewer is qualified to review some subset of papers. We are interested in maximizing the number of papers reviewed by at least <span class="math inline">k</span> reviewer, then under that constraint, maximize the paper reviewed by <span class="math inline">k+1</span> reviewer, etc. This make sure we are being fair in evaluating papers. It would try to avoid the case where most paper getting small number of reviews and a few papers getting unreasonable number of reviews.</p>
<p>Formally, we are given a bipartite graph <span class="math inline">G=(A,B,E)</span> of <span class="math inline">n</span> vertices and <span class="math inline">m</span> edges. A subset of edges <span class="math inline">M</span> is called a semi-matching, if <span class="math inline">\deg_M(v)=1</span> for all <span class="math inline">v\in A</span>. For a subset of edges <span class="math inline">M</span>, let <span class="math inline">g_M(i)</span> to be the number of vertices in <span class="math inline">B</span> with degree at least <span class="math inline">i</span>. We want to find a semi-matching <span class="math inline">M</span>, such that <span class="math inline">(g_M(k),g_M(k+1),\ldots,g_M(n))</span> is lexicographically maximum.</p>
<p>When <span class="math inline">k=1</span>, if <span class="math inline">M</span> minimizes the sum of the function <span class="math inline">\sum_{v\in B} f(\deg_M(v))</span> for any strictly convex increasing function <span class="math inline">f</span>, then <span class="math inline">(g_M(1),g_M(2),\ldots,g_M(n))</span> is lexicographically maximum. The problem therefore can be reduced to min-cost flow can be applied here directly, and obtain a polynomial time algorithm <span class="citation" data-cites="HarveyLLT06">[<a href="#ref-HarveyLLT06">1</a>]</span>.</p>
<p>When <span class="math inline">k=3</span>, the problem is NP-hard, since it would imply we have to maximized <span class="math inline">g_M(3)</span>, and this is already NP-hard because exact cover by <span class="math inline">3</span>-sets. That is, given a collection of sets of size <span class="math inline">3</span> each. Decide if there exists a subcollection that forms a partition of the universe.</p>
<p>The only unresolved case is <span class="math inline">k=2</span>. Interestingly, we can show it is also polynomial time solvable. First, one can see that maximizing <span class="math inline">(g_M(2),g_M(3),\ldots,g_M(n))</span> is equivalent to minimize <span class="math inline">\sum_{v, \deg_M(v)\geq 2} f(\deg_M(v))</span> for some strictly convex increasing function <span class="math inline">v</span>, and <span class="math inline">M</span> range through all semi-matchings so each vertex in <span class="math inline">B</span> has degree exactly <span class="math inline">2</span> (Assuming it exists).</p>
<p>Apollonio and Seb≈ë shown the following problem is polynomial time solvable <span class="citation" data-cites="ApollonioS09">[<a href="#ref-ApollonioS09">2</a>]</span>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a graph <span class="math inline">G=(V,E)</span>, a integer <span class="math inline">k</span>, convex functions <span class="math inline">f_v:\N \to \R</span> for each <span class="math inline">v\in V</span>, and an edge cost function <span class="math inline">c:E\to \R</span>. One can find the following in polynomial time. <span class="math display">\displaystyle \min \left\{   \sum_{v\in V} f_v(\deg_M(v)) + \sum_{e\in M} c(e) \middle| M\subseteq E, |M|=k  \right\}</span></p>
</section>
<p>It's not hard to generalize it a bit further by requiring <span class="math inline">M</span> to respect some upper and lower bound on the vertices. Indeed, we can let <span class="math inline">f_v:\N\to \R\cup \set{\infty}</span>, and set <span class="math inline">f_v(x)=\infty</span> if <span class="math inline">x</span> is not between the upper and lower bounds.</p>
<p>Now, we are going to reduce the problem. The reduction is similar to the <a href="https://cstheory.stackexchange.com/questions/33857/is-two-or-zero-matching-in-a-bipartite-graph-np-complete/33859">one for <span class="math inline">2</span>-or-<span class="math inline">0</span> matching</a>.</p>
<p>For each vertex <span class="math inline">v\in B</span>, split into two vertices <span class="math inline">v_1</span> and <span class="math inline">v_2</span>. Define <span class="math inline">B_i=\set{v_1|v\in B}</span>. The new input graph consists of vertices <span class="math inline">B_1\cup B_2 \cup A</span>. <span class="math inline">v_1</span> and <span class="math inline">v_2</span> connects to the same vertices as <span class="math inline">v</span>. We add an edge between <span class="math inline">v_1</span> and <span class="math inline">v_2</span>, with very large cost <span class="math inline">C</span>. Say <span class="math inline">C=mn^2+1</span>. <span class="math inline">v_1</span> has both an upper and lower bound of <span class="math inline">1</span>. <span class="math inline">v_2</span> has a lower bound of <span class="math inline">1</span>. For each vertex in <span class="math inline">A</span>, add an upper and lower bound of <span class="math inline">1</span>. We have a strict convex function <span class="math inline">f_{v_2}(x)=x^2</span> on each vertex <span class="math inline">v_2</span>.</p>
<p>Let <span class="math inline">r=|A|</span>, <span class="math inline">p=|B|</span>. We solve <a href="#Problem-1">Problem 1</a> repeatedly for each <span class="math inline">k</span> from <span class="math inline">r</span> to <span class="math inline">r+p</span>.</p>
<p>Say there exists an optimal solution to the original problem with exactly <span class="math inline">t</span> vertices in <span class="math inline">B</span> with degree smaller than <span class="math inline">2</span>. Find the optimal solution to the new problem with <span class="math inline">k=r+t</span>. Let it be <span class="math inline">M&#39;</span>. We obtain <span class="math inline">M</span> from <span class="math inline">M&#39;</span> by identify pairs of vertices <span class="math inline">v_1</span> and <span class="math inline">v_2</span>. <span class="math inline">M</span> would be the solution to the original problem.</p>
<h1 id="extensions"><span class="header-section-number">1</span> Extensions</h1>
<p>We might add degree upper and lower bounds to all vertices, and only look at subgraphs in <span class="math inline">M</span> that satisfies the upper and lower bounds. That is, we can also make sure no reviewers review too many papers too. Under that constraint, find <span class="math inline">(g_M(k),\ldots,g_M(n))</span> lexicographically. This is possible but more tricky, as we have to do some reduction from capacitated <span class="math inline">b</span>-matching to <span class="math inline">b</span>-matching.</p>
<p>There is a little more generalization. Assume for each paper, we have a lower bound of reviews <span class="math inline">d_v</span>. That is, it has to be reviewed by at least <span class="math inline">d_v</span> person to be useful. So translating to the graph case, we can impose the constraint that <span class="math inline">\deg_M(v)=0</span> or <span class="math inline">\deg_M(v)\geq d_v</span>. One can see maximizing <span class="math inline">(g_M(2),g_M(3),\ldots,g_M(n))</span> is equivalent to maximizing <span class="math inline">(g_M(1),g_M(2),\ldots,g_M(n))</span> where <span class="math inline">d_v=2</span> for all vertices. Again, one can modify the reduction to handle the case when <span class="math inline">d_v</span> is either <span class="math inline">1</span> or <span class="math inline">2</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-HarveyLLT06">
<p>[1] N.J. Harvey, R.E. Ladner, L. Lov√°sz, T. Tamir, <strong>Semi-matchings for bipartite graphs and load balancing</strong>, Journal of Algorithms. 59 (2006) 53‚Äì78 <a href="https://doi.org/10.1016/j.jalgor.2005.01.003">10.1016/j.jalgor.2005.01.003</a>.</p>
</div>
<div id="ref-ApollonioS09">
<p>[2] N. Apollonio, A. Seb≈ë, <strong>Minconvex factors of prescribed size in graphs</strong>, SIAM Journal on Discrete Mathematics. 23 (2009) 1297‚Äì1310 <a href="https://doi.org/10.1137/060651136">10.1137/060651136</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-29. </div>
    <div class="info">Tags: algorithm, matching.</div>

</div>
      </article>
    </main>
    <footer class="hide-on-print">¬© 2010 - <time><script>document.write(new Date().getFullYear())</script></time> <a href="https://chaoxuprime.com">Chao Xu</a>. Licensed under <a href="http://www.wtfpl.net/txt/copying/">WTFPL v2</a> unless otherwise specified. <a href="/README.html">Blog README</a>.</footer>
  </body>
</html>
