<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>The Art Gallery Guardian</title>
        <link>https://chaoxuprime.com</link>
        <description><![CDATA[Mostly notes on algorithms]]></description>
        <atom:link href="https://chaoxuprime.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 15 Jun 2019 00:00:00 UT</lastBuildDate>
        <item>
    <title>An algorithm for covert back-to-back ticketing</title>
    <link>https://chaoxuprime.com/posts/2019-06-15-covert-back-to-back-ticketing.html</link>
    <description><![CDATA[<br />
<div>
<p>Airline booking ploys are ways to circumventing airlines ticket rules in order to spend less on the ticket. A fairly nice <a href="https://en.wikipedia.org/wiki/Airline_booking_ploys">Wikipedia article on airline booking ploys</a>. We consider a special case, the back-to-back ticketing/nested ticketing. <a href="https://www.tripsavvy.com/back-to-back-ticketing-468287">TripSavvy has a good article on back-to-back ticketing</a>.</p>
<p>For many airlines, back-to-back ticketing is explicitly forbidden, this includes <a href="https://www.aa.com/i18n/customer-service/support/conditions-of-carriage.jsp?anchorEvent=false&amp;from=footer?#ticketvalidity">American Airlines</a>, <a href="https://www.delta.com/us/en/booking-information/fare-classes-and-tickets/ticket-rules-restrictions">Delta</a> and <a href="https://www.united.com/ual/en/us/fly/contract-of-carriage.html">United</a>.</p>
<p>We want to model back-to-back ticketing into an algorithmic problem. There is a sequence of trips between two locations, and it can be grouped into different round trips. Each round trip itinerary has a different cost. A round trip itinerary is no more than a matching between two trips.</p>
<p>This can be seen as simple matching problem. The vertices are trips, which we can assume a trip means &quot;traveling from A to B on date x&quot;. There is an edge between two trips, if there is a round trip itinerary containing the trips. The cost of the edge is the cost of buying a round trip for those two trips. Since it is also possible that we buy a one-way ticket, there are also self-loops. Also, we can consider a multigraph, where the edges are colored. Each color class represents an airline.</p>
<p>If one does not care about the airline finding out. Hence one can see this is a minimum weight perfect matching problem allowing self-loops. However, people might actually care about airline not happy about this practice. Hence we are interested in making sure in each airline, we have no overlapping itineraries. However, we allow overlapping itineraries across airlines.</p>
<p>For two edges <span class="math inline">\set{a,b}</span> and <span class="math inline">\set{c,d}</span> defined over integers, it is <em>independent</em> if <span class="math inline">[a,b]\cap [c,d]= \emptyset</span>. A set of edges is <em>independent</em> if the edges are pairwise independent.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Covert back-to-back ticketing problem</span></span>
<p><strong>Input:</strong> A multigraph <span class="math inline">G=(V,E)</span> where <span class="math inline">V\subseteq [n]</span>, edges has <span class="math inline">k</span> different colors, and there is an edge cost function <span class="math inline">c:E\to \R^+</span>.</p>
<p><strong>Output:</strong> A perfect matching <span class="math inline">M</span> (allowing self-loops), such that each color class of <span class="math inline">M</span> is independent, and the cost is minimized.</p>
</section>
<p>I suspect for arbitrary <span class="math inline">k</span>, the problem is NP-hard. We show how to solve the problem in polynomial time for <span class="math inline">k=2</span>.</p>
<p><a href="https://yizhis.github.io/">Yizhi Song</a> stated the idea that if one edge in a color is picked, it forces some edges of the other color to be picked. We can use the idea to obtain an <span class="math inline">O(n^3)</span> time algorithm for this problem.</p>
<p>Since we are only working with <span class="math inline">k=2</span> case, we will let <span class="math inline">\bar{a}</span> to be the color that is not <span class="math inline">a</span>. Recall <span class="math inline">[n]=\set{1,\ldots,n}</span> and <span class="math inline">[a..b] = \set{a,a+1,\ldots,b}</span>. We assume the vertices <span class="math inline">V=[n]</span>. For a graph with <span class="math inline">k</span> color classes, we define <span class="math inline">G_a</span> to be the subgraph consists of all edges of color <span class="math inline">a</span>. <span class="math inline">c_a(x,y)</span> is the cost of a color <span class="math inline">a</span> edge <span class="math inline">xy</span>. We define <span class="math inline">D(a,y,z)</span> as the optimal solution when the input graph is <span class="math inline">G_{\bar{a}}[[z-1]\setminus \set{y}] \cup G_a[[y-1]]</span>. We also define <span class="math inline">C_{a}(x,y)</span> to be the optimal solution when the input graph is <span class="math inline">G_a[[x..y]]</span>.</p>
<p>The optimal solution is <span class="math inline">D(a,n+1,n+1)</span> for either color <span class="math inline">a</span>.</p>
<p>We express the recursive relation. For <span class="math inline">y&lt;z</span>, we have the following. <span class="math display">\displaystyle 
D(a,y,z) =\min \begin{cases}
\min_{x&lt;y} \set{ C_{\bar{a}}(y+2,z-1) + c_{\bar{a}}(x,y+1) + D(\bar{a},x,y)}\\
C_{\bar{a}}(y+1,z-1) + D(\bar{a},y,y)
\end{cases}
</span> It might be beneficial to see the intuition behind the two cases through the following pictures.</p>
<figure>
<img src="/files/ticketing_case1.png" alt="First case." /><figcaption>First case.</figcaption>
</figure>
<figure>
<img src="/files/ticketing_case2.png" alt="Second case." /><figcaption>Second case.</figcaption>
</figure>
<p>On the other hand, when <span class="math inline">y=z</span> <span class="math display">\displaystyle 
D(a,y,y) =\min_{x&lt;y} \set{
D(a,x,y) + c_a(x,y),
D(\bar{a},x,y) + c_{\bar{a}}(x,y)}
</span> One can easily infer the base case through definition. Note that all values of <span class="math inline">C_a</span> can be computed in <span class="math inline">O(n^2)</span> time. It takes <span class="math inline">O(n)</span> time to compute one value in <span class="math inline">D</span>. Therefore, the total running time is <span class="math inline">O(n^3)</span>.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-06-15">2019-06-15</time>. </div>
    <div class="info">Tags: Optimization.</div>
</div>]]></description>
    <pubDate>Sat, 15 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-06-15-covert-back-to-back-ticketing.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Arrays and permutation</title>
    <link>https://chaoxuprime.com/posts/2019-06-15-array-and-permutation.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="permutation-functional-form"><span class="header-section-number">1</span> Permutation, functional form</h1>
<p>It is often where we are tasked with permuting an array. We can abstract out and ask what exactly is an array. In functional form, an array just have to support the following two operations in constant time.</p>
<ol type="1">
<li><span class="math inline">get(A,i)</span>: returns <span class="math inline">A[i]</span>.</li>
<li><span class="math inline">set(A,i,x)</span>: update the array <span class="math inline">A</span> such that <span class="math inline">A[i]</span> returns <span class="math inline">x</span>.</li>
</ol>
<p>So in some sense, array is just encoding a function <span class="math inline">f:[n]\to X</span>. A permutation would be a bijective function <span class="math inline">\pi:[n]\to [n]</span>. If we are interested in applying a permutation <span class="math inline">\pi</span>, then to program it is easy, we need to output a new function <span class="math inline">g</span> such that <span class="math inline">g(i) = f(\pi(i))</span>.</p>
<p>This allows us to apply permutations pretty easily by composing functions and cache outputs. In the purely functional view, the layout of the array in memory and the indexing can be different.</p>
<h1 id="permutation-physically"><span class="header-section-number">2</span> Permutation, physically</h1>
<p>Sometimes one might ask to physically apply the permutation to an array. That is, the <span class="math inline">i</span>th position in the array contains the element in <span class="math inline">\pi(i)</span>. This is helpful because it helps with cache locality: accessing consecutive elements would be in the same location. Although if the ordering of loops does not matter, there is no harm considering the functional view.</p>
<p>Often, one is tasked to apply permutation to an array physically. It usually ask for <span class="math inline">O(n)</span> running time and <span class="math inline">O(1)</span> space. Unfortunately, there is no way to obtain this running time for all permutations. There are some permutations where this is impossible. [cite]</p>
<h1 id="mix-and-match"><span class="header-section-number">3</span> Mix and match</h1>
<p><a href="https://www.linkedin.com/in/lingyu-xu-9b87a565/">Lingyu Xu</a> asked me about <a href="https://leetcode.com/problems/wiggle-sort-ii/">Wiggle Sort</a>, where the actual <strong>physical layout</strong> has to be changed, but it takes both the functional and physical view of the array.</p>
<p>Let's consider the simple case where every element is distinct. One simple solution is the following. Partition the numbers into the median, elements smaller than median, and elements larger than the median. We map the smallest <span class="math inline">n/2</span> elements into even positions, and remaining elements into the odd position. The algorithm has <span class="math inline">O(n)</span> time. The problem is how to get constant extra place. Because it is unclear how to apply the following permutation in place. The permutation <span class="math inline">\sigma(i) = (1+2i) \% (n|1)</span>.</p>
<p>However, one we take the functional view, the problem can be solved, physically too. The <a href="https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/ono1-after-median-virtual-indexing/81756">answer by</a> <a href="http://www.stefan-pochmann.info/">Stefan Pochmann</a> shows one can simply do the mapping in place.</p>
<p>What is happening in the physical location. If we applied index transform <span class="math inline">\pi</span>, then apply physical permutation <span class="math inline">\sigma</span> on the index, what happens for the physical array? It is the same as applying <span class="math inline">\pi^{-1}\sigma\pi</span> to the physical array.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-06-15">2019-06-15</time>. </div>
    <div class="info">Tags: Permutation.</div>
</div>]]></description>
    <pubDate>Sat, 15 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-06-15-array-and-permutation.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Union of intervals in SQL</title>
    <link>https://chaoxuprime.com/posts/2019-04-27-union-of-intervals-in-sql.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>We given a collection of <span class="math inline">n</span> intervals, and we want to find its union, represented by a set of disjoint intervals. Assume the intervals are of the form <span class="math inline">[a,b)</span>, where <span class="math inline">a&lt;b</span>. However, I have to solve this problem in Hive. So this is a problem I have to solve in Hive's SQL variant.</p>
<p>First, here is the schema of the table and some sample inputs.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> t (
  a <span class="dt">int</span>,
  b <span class="dt">int</span>
);
<span class="kw">INSERT</span> <span class="kw">INTO</span> t <span class="kw">VALUES</span>
  (<span class="dv">0</span>,<span class="dv">10</span>),
  (<span class="dv">20</span>,<span class="dv">30</span>),
  (<span class="dv">5</span>,<span class="dv">15</span>);</code></pre></div>
<p>The correct output should be the following.</p>
<pre><code>a    b
-------
0    15
20   30</code></pre>
<p>We do not allow empty intervals, so we cannot have <span class="math inline">a=b</span>.</p>
<h1 id="previous-works"><span class="header-section-number">2</span> Previous Works</h1>
<p>Note this is a common interview problem, <a href="https://leetcode.com/problems/merge-intervals/">LeetCode 56. Merge Intervals</a>. There is a <span class="math inline">\Omega(n\log n)</span> running time lower bound. There is an <span class="math inline">O(n\log p)</span> upper bound, where <span class="math inline">p</span> is the number of points required to stab all intervals. In higher dimension, this is called the <a href="https://en.wikipedia.org/wiki/Klee%27s_measure_problem">Klee's measure problem</a>.</p>
<p>However, one would wonder how efficient can we solve the problem in SQL. I was surprised find a <a href="https://stackoverflow.com/a/8120432/303863">very short solution on stackoverflow</a>.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> 
       t1.a,
       <span class="fu">MIN</span>(t2.b) <span class="kw">AS</span> b
<span class="kw">FROM</span> t t1 
<span class="kw">INNER</span> <span class="kw">JOIN</span> t t2 <span class="kw">ON</span> t1.a &lt;= t2.b
  <span class="kw">AND</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span>(<span class="kw">SELECT</span> * <span class="kw">FROM</span> t 
                 <span class="kw">WHERE</span> t2.b &gt;= t.a <span class="kw">AND</span> t2.b &lt; t.b) 
<span class="kw">WHERE</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span>(<span class="kw">SELECT</span> * <span class="kw">FROM</span> t
                 <span class="kw">WHERE</span> t1.a &gt; t.a <span class="kw">AND</span> t1.a &lt;= t.b) 
<span class="kw">GROUP</span> <span class="kw">BY</span> t1.a
<span class="kw">ORDER</span> <span class="kw">BY</span> t1.a</code></pre></div>
<p>Unfortunately, once you know how the entire algorithm goes, one can see its performance does not look promising. Indeed, this is a <span class="math inline">O(n^2)</span> time algorithm. After generating <span class="math inline">10000</span> random intervals in PostgreSQL, it took 13 seconds to run. Also making it work in Hive is next to impossible due to Hive's limitations on joins and subqueries.</p>
<p><a href="http://tsql.solidq.com/">Itzik Ben-Gan</a> has <a href="https://www.itprotoday.com/development-techniques-and-management/packing-date-intervals">written</a> <a href="https://blogs.solidq.com/en/sqlserver/packing-intervals/">multiple</a> <a href="https://www.itprotoday.com/sql-server/new-solution-packing-intervals-problem">articles</a> on how to solve this problem. I recommend reading them to learn various tricks. In fact, my solution here is quite similar to one of Ben-Gan's.</p>
<p>Thanks to <a href="https://scholar.google.com/citations?user=jB4qJYEAAAAJ&amp;hl=en">Peng Yu</a> who pointed out this kind of queries is very common in sessionization.</p>
<h1 id="using-basic-sql"><span class="header-section-number">3</span> Using basic SQL</h1>
<p>Here we will try to implement an algorithm using the most basic of SQL, so it would even work in Hive.</p>
<h2 id="solution-by-simulate-the-standard-sweep-line-algorithm"><span class="header-section-number">3.1</span> Solution by simulate the standard sweep-line algorithm</h2>
<p>We first build a table, such that <span class="math inline">(a,c)</span> is in the table shows that there are <span class="math inline">c</span> intervals the endpoint directly before <span class="math inline">a</span>. Next, we notice that <span class="math inline">c=0</span> if and only if <span class="math inline">a</span> is the start of a new interval in the union. Hence we can assign everything between consecutive <span class="math inline">c=0</span> a name.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> 
  weighted_endpoints <span class="kw">AS</span> (
    <span class="kw">SELECT</span> a, <span class="fu">Sum</span>(d) <span class="kw">AS</span> d
    <span class="kw">FROM</span>   (<span class="kw">SELECT</span> a,  <span class="dv">1</span> <span class="kw">AS</span> d <span class="kw">FROM</span> t
            <span class="kw">UNION</span> <span class="kw">ALL</span>
            <span class="kw">SELECT</span> b, -<span class="dv">1</span> <span class="kw">AS</span> d <span class="kw">FROM</span> t) e
    <span class="kw">GROUP</span>  <span class="kw">BY</span> a),
  endpoints_with_coverage <span class="kw">AS</span> (
    <span class="kw">SELECT</span> *, <span class="fu">Sum</span>(d) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) - d <span class="kw">AS</span> c
    <span class="kw">FROM</span> weighted_endpoints),
  equivalence_classes <span class="kw">AS</span> (
    <span class="kw">SELECT</span> a, <span class="fu">COUNT</span>(<span class="kw">CASE</span> <span class="kw">WHEN</span> c=<span class="dv">0</span> <span class="kw">THEN</span> <span class="dv">1</span> <span class="kw">END</span>) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> <span class="kw">class</span>
    <span class="kw">FROM</span> endpoints_with_coverage)
<span class="kw">SELECT</span> <span class="fu">min</span>(a) <span class="kw">AS</span> a, <span class="fu">max</span>(a) <span class="kw">AS</span> b
<span class="kw">FROM</span> equivalence_classes
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">class</span>;</code></pre></div>
<p>The equivalence classes idea is from Peng Yu. This code took 100ms to handle 10000 random intervals in PostgreSQL. You can find <a href="https://www.db-fiddle.com/f/aVaF6NDTVYmxBpifsHDFBf/9">the example in DB-fiddle</a>. I am interested to seeing simpler and faster code using the simplest of SQL.</p>
<h2 id="solution-through-gaps"><span class="header-section-number">3.2</span> Solution through gaps</h2>
<p>There is another solution, which uses the idea of gaps. Interestingly, gaps are much easier to compute. Here we modify <a href="https://stackoverflow.com/a/53163029/303863">Oleg K's solution</a>.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> largest_prev <span class="kw">AS</span> (<span class="kw">SELECT</span> 
                      <span class="fu">MAX</span>(b) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> b,
                      <span class="fu">LEAD</span>(a) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> a 
                      <span class="kw">FROM</span> t),
     gaps <span class="kw">AS</span> (<span class="kw">SELECT</span> * <span class="kw">FROM</span> largest_prev <span class="kw">WHERE</span> b&lt;a
              <span class="kw">UNION</span> <span class="kw">ALL</span>
              <span class="kw">SELECT</span> <span class="fu">min</span>(a), <span class="fu">min</span>(a) <span class="kw">from</span> t
              <span class="kw">UNION</span> <span class="kw">ALL</span>
              <span class="kw">SELECT</span> <span class="fu">max</span>(b), <span class="kw">null</span> <span class="kw">from</span> t),
     intervals <span class="kw">AS</span> (<span class="kw">SELECT</span> a, <span class="fu">LEAD</span>(b) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> b) <span class="kw">as</span> b <span class="kw">FROM</span> gaps)
<span class="kw">SELECT</span> * <span class="kw">FROM</span> intervals <span class="kw">WHERE</span> a <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">null</span>;</code></pre></div>
<p>This one can also be tested on <a href="https://www.db-fiddle.com/f/k1GTRiRgaiPmRfxZoWBhTs/1">DB-fiddle</a>. This code took 70ms to handle 10000 random intervals in PostgreSQL.</p>
<p>As a real application, for example, if we want to know the length of union of intervals grouped by some keys. The following is how we do it in hive. Note in this application, we don't have to remove the null rows because we are taking a sum.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SET</span> hivevar<span class="ch">:key</span>=id1,id2;
<span class="kw">SET</span> hivevar<span class="ch">:input</span>=t;
<span class="kw">WITH</span> largest_prev <span class="kw">AS</span> (<span class="kw">SELECT</span>
                      ${<span class="kw">key</span>},
                      <span class="fu">MAX</span>(b) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> ${<span class="kw">key</span>} <span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> b,
                      <span class="fu">LEAD</span>(a) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> ${<span class="kw">key</span>} <span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> a
                      <span class="kw">FROM</span> ${input}),
     gaps <span class="kw">AS</span> (<span class="kw">SELECT</span> * <span class="kw">FROM</span> largest_prev <span class="kw">WHERE</span> b&lt;a
              <span class="kw">UNION</span> <span class="kw">ALL</span>
              <span class="kw">SELECT</span> ${<span class="kw">key</span>}, <span class="fu">min</span>(a), <span class="fu">min</span>(a) <span class="kw">from</span> ${input} <span class="kw">GROUP</span> <span class="kw">BY</span> ${<span class="kw">key</span>}
              <span class="kw">UNION</span> <span class="kw">ALL</span>
              <span class="kw">SELECT</span> ${<span class="kw">key</span>}, <span class="fu">max</span>(b), <span class="kw">null</span> <span class="kw">from</span> ${input} <span class="kw">GROUP</span> <span class="kw">BY</span> ${<span class="kw">key</span>}),
     intervals <span class="kw">AS</span> (<span class="kw">SELECT</span> ${<span class="kw">key</span>}, 
                          a,
                          <span class="fu">LEAD</span>(b) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> ${<span class="kw">key</span>} <span class="kw">ORDER</span> <span class="kw">BY</span> b) <span class="kw">as</span> b
                   <span class="kw">FROM</span> gaps)
<span class="kw">SELECT</span> ${<span class="kw">key</span>}, <span class="fu">SUM</span>(b-a) <span class="kw">as</span> score
<span class="kw">FROM</span> intervals
<span class="kw">GROUP</span> <span class="kw">BY</span> ${<span class="kw">key</span>};</code></pre></div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-04-27">2019-04-27</time>. </div>
    <div class="info">Tags: SQL, algorithm.</div>
</div>]]></description>
    <pubDate>Sat, 27 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-04-27-union-of-intervals-in-sql.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Maximum weight hierarchical <span class="math inline">b</span>-matching</title>
    <link>https://chaoxuprime.com/posts/2019-04-27-maximum-weight-hierarchical-b-matching.html</link>
    <description><![CDATA[<br />
<div>
<p>We consider the following problem, which appeared in <span class="citation" data-cites="EmekKSZ19">[<a href="#ref-EmekKSZ19">1</a>]</span>.</p>
<p>Let <span class="math inline">\mathcal{L}</span> be a laminar family consists of sets <span class="math inline">F_1,\ldots,F_k</span>. Let <span class="math inline">u_1,\ldots,u_k</span> to be positive integers. Consider a graph <span class="math inline">G=(V,E)</span> with a weight function <span class="math inline">w:E\to \N</span> and capacity function <span class="math inline">c:E\to \N</span>. We are interested in finding a <span class="math inline">y\leq c</span>, such that for every <span class="math inline">F_i\in \mathcal{L}</span>, we have <span class="math inline">\sum_{v\in F_i} \sum_{e:v\in e\in E} y_e \leq u_i</span>, and <span class="math inline">\sum_{e\in E} y_ew_e</span> is maximized.</p>
<p>Formally, it is the following integer program.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
&amp; \max_{y\in \Z^m} &amp; &amp; \sum_{e} w_e y_e &amp; \\
&amp; \text{s.t.} &amp; &amp; \sum_{v\in F_i} \sum_{e:v\in e\in E} y_e \leq u_i &amp; i\in [k] \\
&amp; &amp; &amp;  0\leq y_e \leq c_e &amp; \forall e\in E \\
\end{aligned}
</span></p>
<p>This is a generalization of the maximum weight <span class="math inline">c</span>-capacitated <span class="math inline">b</span>-matching problem. Indeed, we can simply set <span class="math inline">F_i = \set{v_i}</span> and <span class="math inline">u_i=b_i</span>. However, this problem is actually no more general than the maximum weight <span class="math inline">c</span>-capacitated <span class="math inline">b</span>-matching problem.</p>
<p>Let <span class="math inline">A \in \Z^{m\times n}</span> be a matrix such that <span class="math inline">\sum_{i=1}^m |A_{i,j}|\leq 2</span> for every <span class="math inline">j</span>. We call <span class="math inline">A</span> a bidirected matrix.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>Given <span class="math inline">A \in \Z^{m\times n}</span> a bidirected matrix and vectors <span class="math inline">a,b\in \Z^m</span>, <span class="math inline">c,d,w\in \Z^n</span>. The integer program <span class="math inline">\max_{x\in \Z^n} \set{wx \mid a\leq Ax\leq b, c\leq x\leq d}</span> can be solved in polynomial time. In particular, it is equivalent to the maximum weight <span class="math inline">b</span>-matching problem on graph of size <span class="math inline">poly(m,n)</span>.</p>
</section>
<p>The above theorem can be found in <span class="citation" data-cites="Schrijver03">[<a href="#ref-Schrijver03">2</a>]</span>. Note that in Schrijver's book, one requires <span class="math inline">\sum_{i=1}^m |A_{i,j}|=2</span>. It is not hard to see the statement still holds even if we have <span class="math inline">\leq</span> in place of <span class="math inline">=</span>.</p>
<p>We will express the maximum weight hierarchical <span class="math inline">b</span>-matching problem as an integer program over a polytope defined over a bidirected matrix. The integer program is a modification of the integer program in <span class="citation" data-cites="KaparisLM17">[<a href="#ref-KaparisLM17">3</a>]</span>. The integer program here is simpler, because we are not trying to reduce to <em>perfect</em> <span class="math inline">b</span>-matching.</p>
<p>We define <span class="math inline">F_i&#39; = F_i \setminus \bigcup_{j: F_j\subsetneq F_i} F_j</span>. We also define <span class="math inline">C_i</span> to be the indices <span class="math inline">j</span>, such that for all <span class="math inline">k</span>, <span class="math inline">F_j\subseteq F_k \subsetneq F_i</span> implies <span class="math inline">j=k</span>. <span class="math inline">y_e</span> denote the amount of capacities we assign to <span class="math inline">e</span>, <span class="math inline">x_v</span> denotes the capacitated degree, hence <span class="math inline">x_v = \sum_{e:v\in e\in E} y_e</span>. We define <span class="math inline">z_i = \sum_{v\in F_i} x_v</span>, which can be transformed to <span class="math inline">z_i = \sum_{v\in F_i&#39;} x_v + \sum_{j\in C_i} z_j</span>. Therefore we obtain the following integer program by directly applying substitutions.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
&amp; \max_{x\in \Z^n,y\in \Z^m, z\in \Z^k} &amp; &amp; \sum_{e} w_e y_e &amp; \\
&amp; \text{s.t.} &amp; &amp; \sum_{v\in F_i&#39;} x_v + \sum_{j\in C_i} z_j - z_i= 0 &amp; i\in [k] \\
&amp; &amp; &amp;  \sum_{e: v\in e\in E} y_e -x_v = 0 &amp; \forall v\in V \\
&amp; &amp; &amp;  0\leq y_e \leq c_e &amp; \forall e\in E \\
&amp; &amp; &amp;  0\leq z_i \leq u_i &amp; \forall i\in [k] \\
\end{aligned}
</span></p>
<p>The matrix here is a bidirected matrix. This shows the original problem can be solved in polynomial time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-EmekKSZ19">
<p>[1] Y. Emek, S. Kutten, M. Shalom, S. Zaks, <strong>Hierarchical b-Matching</strong>, arXiv E-Prints. (2019) arXiv:1904.10210.</p>
</div>
<div id="ref-Schrijver03">
<p>[2] A. Schrijver, <strong>Combinatorial Optimization (3 volume, A, B, &amp; C)</strong>, Springer, 2003.</p>
</div>
<div id="ref-KaparisLM17">
<p>[3] I.M. Konstantinos Kaparis Adam N. Letchford, <strong>On matroid parity and matching polytopes</strong>, Department of Management Science, Lancaster University, 2017.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-04-27">2019-04-27</time>. </div>
    <div class="info">Tags: combinatorial optimization, matching, matroid.</div>
</div>]]></description>
    <pubDate>Sat, 27 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-04-27-maximum-weight-hierarchical-b-matching.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Misleading while being honest</title>
    <link>https://chaoxuprime.com/posts/2019-04-06-misleading-while-being-honest.html</link>
    <description><![CDATA[<br />
<div>
<p>Given a set of data <span class="math inline">A</span>, we can plot it on a <a href="https://en.wikipedia.org/wiki/Radar_chart">radar chart</a>. One can permute the axis to make sure the area of the radar chart is maximized. This was explored in <a href="https://chaoxuprime.com/posts/2012-08-08-maximize-the-area-of-a-radar-chart.html">a previous article</a>.</p>
<p>More interesting problem. Given two sets of data <span class="math inline">A</span> and <span class="math inline">B</span>, we are interested in finding a common radar chart, that make <span class="math inline">A</span> look as good as possible compared to <span class="math inline">B</span>. We might want to optimize the area ratio, area difference, or something else. Again, we are thinking of permuting the axis of the radar chart.</p>
<p>I once mentioned this problem to <a href="https://www.contrib.andrew.cmu.edu/~ravi/">R Ravi</a>, and he suggest I could ask the same question for all kind of different graphs. How to mislead people with graphs while being completely honest? Indeed, this looks like a fun research project. There is a <a href="https://en.wikipedia.org/wiki/Misleading_graph">wikipedia article completely devoted to it</a>. In my <a href="https://chaoxuprime.com/posts/2019-03-28-l1-linear-regression.html">previous post</a>, I've discussed how to fitting two seemingly not that related data points through simple transformation.</p>
<p>I'm interested in are algorithmic problems where one want to compute the most misleading chart, I think it would be a great fun project.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-04-06">2019-04-06</time>. </div>
    <div class="info">Tags: data visualization.</div>
</div>]]></description>
    <pubDate>Sat, 06 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-04-06-misleading-while-being-honest.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title><span class="math inline">L_1</span> linear regression</title>
    <link>https://chaoxuprime.com/posts/2019-03-28-l1-linear-regression.html</link>
    <description><![CDATA[<br />
<div>
<p>I read an article on the <a href="https://medium.economist.com/mistakes-weve-drawn-a-few-8cdd8a42d368">errors in visualization</a>. The example of forcing a relationship by cherry-picking scales is delightful. I recommend reading it.</p>
<p>I am interested in misleading people while being completely honest. The article inspires the following problem. Given 2 vectors <span class="math inline">\bm{x},\bm{y}\in \R^n</span>. Let <span class="math inline">\bm{1}</span> be the all <span class="math inline">1</span> vector in <span class="math inline">\R^n</span>. We are interested in finding <span class="math inline">a,b\in \R</span>, such that <span class="math inline">\|\bm{y}-(a\bm{x}+b\bm{1})\|_p</span> is minimized. Here <span class="math inline">p</span> is either <span class="math inline">1,2</span> or <span class="math inline">\infty</span>.</p>
<p>Note the problem is precisely the same as the linear regression problem. In the linear regression problem, we are given a point set <span class="math inline">S\subset \R^2</span> of size <span class="math inline">n</span> and we are interested in find a line <span class="math inline">f(x) = ax+b</span>, such that it minimizes the <em>error</em>, defined as</p>
<p><span class="math display">\displaystyle 
\sum_{(x,y)\in S} \|y - f(x)\|_p
</span></p>
<p>For <span class="math inline">p=2</span>, there is a <span class="math inline">O(n)</span> time algorithm because there is a closed formula. For <span class="math inline">p=\infty</span>, the problem can be rewritten as a linear program with <span class="math inline">3</span> variables and <span class="math inline">n</span> constraints. Using Megiddo's result <span class="citation" data-cites="Megiddo84">[<a href="#ref-Megiddo84">1</a>]</span>, there is a <span class="math inline">O(n)</span> time algorithm to solve this problem.</p>
<p>It is hard to find the worst case complexity when <span class="math inline">p=1</span>. This case is called the <em>least absolute deviations</em>. Statisticians just don't care about worst case running time as CS people do.</p>
<p>There are a few methods I found. One is to write it as a linear program on <span class="math inline">n+2</span> variables and <span class="math inline">n</span> constraints and solve it using the simplex method. The linear program is as follows.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
&amp; \min_{a,b,t_1,\ldots,t_n}
&amp; &amp; \sum_{i=1}^n t_i &amp; \\
&amp; \text{s.t.} &amp; &amp;  t_i \geq (ax_i+b)-y_i &amp; \forall 1 \leq i \leq n \\
&amp; &amp; &amp;  t_i \leq y_i-(ax_i+b) &amp; \forall 1 \leq i \leq n \\
\end{aligned}
</span></p>
<p>There are a bunch of other algorithms that specializes the simplex algorithm on this particular problem. There are also some iterative methods. Unfortunately, those algorithms depends on the actual numbers in the input. I want a running time that only depends on <span class="math inline">n</span>.</p>
<p>There exists an optimal solution that contains two points in <span class="math inline">S</span>. The native algorithm is to try all possible <span class="math inline">O(n^2)</span> lines. For each line, the algorithm can compute the error in <span class="math inline">O(n)</span> time. The naive algorithm's running time is <span class="math inline">O(n^3)</span>. There is a smarter algorithm. The optimal line that contains the point can actually be found in <span class="math inline">O(n)</span> time. Indeed, consider the line passes through the point <span class="math inline">(x,y)</span>. We consider changing the slope of the line, while maintaining it still contain <span class="math inline">(x,y)</span>. One can see a minimum will be reached at some line. Indeed, assume we reorder the points, so <span class="math inline">\frac{y_i-y}{x_i-x}\leq \frac{y_{i+1}-y}{x_{i+1}-x}</span> (namely, increasing slope). Let <span class="math inline">k</span> be the smallest integer such that the sum of <span class="math inline">\sum_{i=1}^k |x_i-x|\geq \sum_{i=k+1}^n |x_i-x|</span>. The line determined by <span class="math inline">(x,y)</span> and <span class="math inline">(x_k,y_k)</span> is the desired line. This can be computed in linear time by finding weighted median. Hence one can show the running time is <span class="math inline">O(n^2)</span>. This is the idea of <span class="citation" data-cites="BloomfieldS80">[<a href="#ref-BloomfieldS80">2</a>]</span>. As far as I know, this seems to be the state of the art in terms of worst case complexity.</p>
<p>After discussing with <a href="https://sites.google.com/site/qizhenghe96/home">Qizheng He</a>, he suggested the following approach. Consider the function <span class="math inline">g_p(s)</span> for <span class="math inline">p\in S</span>. It is defined as the error for the line of slope <span class="math inline">s</span> that contains <span class="math inline">p</span>. The function is bitonic, therefore we can do a ternary search to find the minimum. There are only <span class="math inline">n-1</span> possible slopes, hence the ternary search will take <span class="math inline">O(\log n)</span> queries, where each query asks for the error of the line that goes through <span class="math inline">p</span> and some other point.</p>
<p>Given a line <span class="math inline">f(x)=ax+b</span>, can one compute the error quickly? It is possible to decompose it to few halfspace range counting queries (allowing weights). In halfspace counting queries problem, we are given <span class="math inline">n</span> points with weights, we can preprocess it and obtain a data structure. Each query to a data structure is a halfspace, the output is the sum of all elements in the halfspace. In <span class="math inline">2</span>D, there exists a preprocessing time <span class="math inline">\tilde{O}(n^{4/3})</span> and query time <span class="math inline">\tilde{O}(n^{1/3})</span> data structure <span class="citation" data-cites="Matousek93">[<a href="#ref-Matousek93">3</a>]</span>. Let <span class="math inline">S^+</span> be the set of points above <span class="math inline">f</span>, and <span class="math inline">S^-</span> be the set of points below <span class="math inline">f</span>. The result is precisely the following.</p>
<p><span class="math display">\displaystyle 
\sum_{(x,y)\in S^+} y - ax-b + \sum_{(x,y)\in S^-} ax+b - y
</span></p>
<p>Let's consider the second sum, <span class="math inline">\sum_{(x,y)\in S^-} ax+b - y = a\sum_{(x,y)\in S^-}x + |S^-|b -\sum_{(x,y)\in S^-}y</span>. Note the <span class="math inline">3</span> terms can each be solved with a halfspace counting query, consider all points lies below <span class="math inline">f</span>. This shows in <span class="math inline">6</span> halfspace counting queries.</p>
<p>How can one do ternary search? This would need us to be able to pick the point that gives us the <span class="math inline">i</span>th largest slope with <span class="math inline">p</span>. We need a data structure such that it can return the <span class="math inline">i</span>th largest point in the radial ordering of the points in <span class="math inline">S</span> around <span class="math inline">p</span>. It is equivalent to <a href="https://cstheory.stackexchange.com/questions/42609/data-structure-for-radial-orderings-of-points-on-the-plane">halfspace range counting up to polylog factors</a>.</p>
<p>Thus, the total running time after building the data structure in <span class="math inline">\tilde{O}(n^{4/3})</span> is <span class="math inline">n</span> times ternary search over <span class="math inline">n</span> elements, where each decision process takes <span class="math inline">\tilde{O}(n^{1/3})</span> time. Therefore the final running time is <span class="math inline">\tilde{O}(n^{4/3})</span> time.</p>
<p>Qizheng mentioned the problem to <a href="http://tmc.web.engr.illinois.edu">Timothy Chan</a>, who gave us some references. There is an easy solution that obtains <span class="math inline">O(n\log^2 n)</span> time algorithm using simple parametric search <span class="citation" data-cites="MegiddoT83">[<a href="#ref-MegiddoT83">4</a>]</span>. Consider the following linear program. Let <span class="math inline">k</span> be a constant. We are given <span class="math inline">a_1,\ldots,a_k,b_1,\ldots,b_n</span>, <span class="math inline">k</span>D vectors <span class="math inline">\beta_1,\ldots,\beta_m</span> and reals <span class="math inline">\alpha_1,\ldots,\alpha_m</span>. Sets <span class="math inline">J_1,\ldots,J_n</span> a partition of <span class="math inline">[m]</span>.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
&amp; \min_{w_1,\ldots,w_k,x_1,\ldots,x_n}
&amp; &amp; \sum_{i=1}^k a_iw_i + \sum_{i=1}^n b_ix_i &amp; \\
&amp; \text{s.t.} &amp; &amp;  x_i \geq (\sum_{d=1}^k \beta_{j,d} w_d) - \alpha_j &amp; \forall 1 \leq i \leq n, j\in J_i
\end{aligned}
</span></p>
<p>Zemel showed such linear program can be solved in <span class="math inline">O(m)</span> time for constant <span class="math inline">k</span> <span class="citation" data-cites="Zemel84">[<a href="#ref-Zemel84">5</a>]</span>. The idea is a similar algorithm to Megiddo's linear time constant dimension LP algorithm <span class="citation" data-cites="Megiddo84">[<a href="#ref-Megiddo84">1</a>]</span>. For linear regression problem in <span class="math inline">L_1</span> with <span class="math inline">n</span> data points. The linear program we derived is a special case of the above linear program when <span class="math inline">k=2</span> and <span class="math inline">m=O(n)</span>. In fact, Zemel use the same linear program to show constant dimension <span class="math inline">L_1</span> regression can be solved in linear time.</p>
<h1 id="open-problem"><span class="header-section-number">1</span> Open problem</h1>
<p>One can also define another metric, the lexicographical minimum. Such idea was already present in fairness related linear regression <span class="citation" data-cites="KoeppenYO14">[<a href="#ref-KoeppenYO14">6</a>]</span>. Once we sort the values of <span class="math inline">|y - f(x)|</span> for <span class="math inline">(x,y)\in S</span>, say obtaining <span class="math inline">a_1,\ldots,a_n</span>, where <span class="math inline">a_1\geq a_2 \geq \ldots \geq a_n</span>. We are interested in finding a <span class="math inline">f</span> that minimizes the sequence <span class="math inline">a_1,\ldots,a_n</span>, lexicographically. Can this problem be solved in <span class="math inline">O(n)</span> time?</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Megiddo84">
<p>[1] N. Megiddo, <strong>Linear programming in linear time when the dimension is fixed</strong>, J. ACM. 31 (1984) 114–127 <a href="https://doi.org/10.1145/2422.322418">10.1145/2422.322418</a>.</p>
</div>
<div id="ref-BloomfieldS80">
<p>[2] P. Bloomfield, W. Steiger, <strong>Least absolute deviations curve-fitting</strong>, SIAM Journal on Scientific and Statistical Computing. 1 (1980) 290–301 <a href="https://doi.org/10.1137/0901019">10.1137/0901019</a>.</p>
</div>
<div id="ref-Matousek93">
<p>[3] J. Matoušek, <strong>Range searching with efficient hierarchical cuttings</strong>, Discrete &amp; Computational Geometry. 10 (1993) 157–182 <a href="https://doi.org/10.1007/BF02573972">10.1007/BF02573972</a>.</p>
</div>
<div id="ref-MegiddoT83">
<p>[4] N. Megiddo, A. Tamir, <strong>Finding Least-Distances Lines</strong>, SIAM Journal on Algebraic Discrete Methods. 4 (1983) 207–211 <a href="https://doi.org/10.1137/0604021">10.1137/0604021</a>.</p>
</div>
<div id="ref-Zemel84">
<p>[5] E. Zemel, <strong>An O(n) algorithm for the linear multiple choice knapsack problem and related problems</strong>, 18 (1984) 123–128 <a href="https://doi.org/10.1016/0020-0190(84)90014-0">10.1016/0020-0190(84)90014-0</a>.</p>
</div>
<div id="ref-KoeppenYO14">
<p>[6] M. Köeppen, K. Yoshida, K. Ohnishi, Evolving fair linear regression for the representation of human-drawn regression lines, in: 2014 International Conference on Intelligent Networking and Collaborative Systems, 2014: pp. 296–303 <a href="https://doi.org/10.1109/INCoS.2014.89">10.1109/INCoS.2014.89</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-03-28">2019-03-28</time>. </div>
    <div class="info">Tags: combinatorial optimization.</div>
</div>]]></description>
    <pubDate>Thu, 28 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-03-28-l1-linear-regression.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Densest subgraph variation</title>
    <link>https://chaoxuprime.com/posts/2019-03-24-densest-subgraph-variation.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">G=(V,E)</span> be a graph. Consider an edge weight function <span class="math inline">w:E\to \R^+</span> and a vertex cost function <span class="math inline">c:V\to \R^+</span>.</p>
<p>We are interested in finding <span class="math inline">S\subset V</span>, such that <span class="math inline">w(E(S))-c(S)</span> is maximized.</p>
<p>This is very close to the densest subgraph problem, as it is basically the Lagrangian relaxation of the problem.</p>
<p>This problem is equivalent to a min-<span class="math inline">st</span>-cut computation on a suitable graph. Indeed, minimizing <span class="math inline">w(E(S))-c(S)</span> is equivalent to minimizing <span class="math inline">c(S) + \frac{1}{2} w(E(S,\bar{S})) + \frac{1}{2} \sum_{v\in \bar{S}} \deg(v)</span>. This can be solved easily by modeling it as a min-<span class="math inline">st</span>-cut.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-03-24">2019-03-24</time>. </div>
    <div class="info">Tags: combinatorial optimization.</div>
</div>]]></description>
    <pubDate>Sun, 24 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-03-24-densest-subgraph-variation.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Finger tree allowing apply functions to each element</title>
    <link>https://chaoxuprime.com/posts/2019-03-10-finger-tree-apply-function-to-each-element.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">(M,+)</span> be a monoid. We are interested in maintaining a sequence <span class="math inline">a = a_1,\ldots,a_n\in M</span> under all updates currently supported by finger tree. However, we are also interested in adding another update, which we call the function update.</p>
<p>Let <span class="math inline">f = f_1,\ldots,f_n\in M\to M</span>.</p>
<p>The functions satisfies the following property.</p>
<p><span class="math inline">f_1(x_1)+\ldots+f_n(x_n) = f_1(y_1)+\ldots+f_n(y_n)</span> if <span class="math inline">\sum_{i=1}^n x_i = \sum_{i=1}^n y_i</span>.</p>
<p>The sequence <span class="math inline">f</span> is given implicitly, where it has two methods:</p>
<ul>
<li><code>evaluate(X)</code>: It returns <span class="math inline">f_1(x_1) + \ldots +f_n(x_n)</span> for any sequence <span class="math inline">x_1,\ldots,x_n</span> such that <span class="math inline">\sum_{i=1}^n x_i = X</span>.</li>
<li><code>split(j)</code>: returns a representation for <span class="math inline">f_1,\ldots,f_j</span> and <span class="math inline">f_{j+1},\ldots,f_n</span>.</li>
</ul>
<p>We are interested in implementing <code>FunctionUpdate(a,f)</code>, the output would be a representation of the sequence <span class="math inline">f_1(a_1),\ldots,f_n(a_n)</span>.</p>
<p>Many problems actually require update to a entire interval of the sequence, which makes this extremely valuable. For example, consider the following simple problem.</p>
<p>Maintain a sequence of integers <span class="math inline">a_1,\ldots,a_n</span>, such that we can do the operation <span class="math inline">inc(i,j)</span>, which increment all numbers from <span class="math inline">i</span>th to <span class="math inline">j</span>th index by <span class="math inline">1</span>. That is, the new sequence is <span class="math inline">a_1,\ldots,a_{i-1},a_i+1,\ldots,a_j+1,a_{j+1},\ldots,a_n</span>. Also, it has a function <span class="math inline">value(i)</span> which returns <span class="math inline">a_i</span>. This problem can be solved by finger tree with function update operation.</p>
<p>I want an actual implementation of such data structure so I can implement the min-cost flow algorithm for series-parallel graphs <span class="citation" data-cites="Booth1993416">[<a href="#ref-Booth1993416">1</a>]</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Booth1993416">
<p>[1] H. Booth, R. Tarjan, <strong>Finding the minimum-cost maximum flow in a series-parallel network</strong>, Journal of Algorithms. 15 (1993) 416–446 <a href="https://doi.org/10.1006/jagm.1993.1048">10.1006/jagm.1993.1048</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-03-10">2019-03-10</time>. </div>
    <div class="info">Tags: data structure, lazy propagation.</div>
</div>]]></description>
    <pubDate>Sun, 10 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-03-10-finger-tree-apply-function-to-each-element.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Find the period of a nice eventually periodic sequence</title>
    <link>https://chaoxuprime.com/posts/2019-02-05-eventually-periodic.html</link>
    <description><![CDATA[<br />
<div>
<p>A sequence is periodic if <span class="math inline">s_i = s_{i+p}</span> for all <span class="math inline">i</span>, where <span class="math inline">p&gt;0</span> is called a period. A sequence is eventually periodic if there exists a <span class="math inline">n</span> and <span class="math inline">p</span>, such that <span class="math inline">s_i = s_{i+p}</span> for all <span class="math inline">i&gt;n</span>. The sequence with index above <span class="math inline">n</span> is the <em>periodic part</em>.</p>
<p>A sequence is called <em><span class="math inline">u</span>-normal</em>, if there exists <span class="math inline">s_i=s_{i+p}</span> for some <span class="math inline">p&gt;0</span> for all <span class="math inline">i</span> in a interval of length <span class="math inline">u</span>, then the sequence starting at <span class="math inline">s_i</span> is part of the periodic part.</p>
<p>When does <span class="math inline">u</span>-normal sequence comes up? Consider we have a recurrence relation that produces a sequence. Say it is of the form <span class="math inline">a_n = f(a_{n-1},a_{n-2},\ldots,a_{n-u})</span>. The sequence <span class="math inline">a_1,\ldots</span> is <span class="math inline">u</span>-normal.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a oracle that can take input <span class="math inline">i</span> and return the <span class="math inline">i</span>th element in a <span class="math inline">u</span>-normal eventually periodic sequence <span class="math inline">a</span>. Find the smallest lexicographic pair <span class="math inline">(n,p)</span> where <span class="math inline">p&gt;0</span>, such that <span class="math inline">a_i=a_{i+p}</span> for all <span class="math inline">i&gt;n</span>.</p>
</section>
<p>One can solve this problem in <span class="math inline">O(u \log \frac{n}{u})</span> time. First, consider the subsequence <span class="math inline">a_u,a_{2u},\ldots</span>. We guess an upper bound on <span class="math inline">n</span> through exponential search in the subsequence. There is a <span class="math inline">O(u)</span> time algorithm to decide if <span class="math inline">n&#39;\geq n</span>. For example using the <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KMP algorithm</a>. We can quickly locate a <span class="math inline">n&#39;</span> such that <span class="math inline">n\in [n&#39;-u,n&#39;]</span>.</p>
<p>Let's take the sequence <span class="math inline">a_{n&#39;-u},\ldots,a_{n&#39;+3u}</span>. We just need to solve the following problem. Given a <span class="math inline">O(u)</span> length string, find the longest suffix that appears at least twice in the sequence. Let such suffix be <span class="math inline">s</span>. We know <span class="math inline">|s|\geq 3u</span>, which <span class="math inline">s</span> has to overlap with any other occurrence of the sequence. The claim is that the partial match table in the KMP algorithm would give us such information. Hence we can obtain <span class="math inline">n</span>. <span class="math inline">p</span> can also be obtained in the same time. Note that KMP algorithm only uses the fact one can check equality of two elements. So the sequence can contain elements from very general space.</p>
<p>The total running time is <span class="math inline">O(\log \frac{n}{u})</span> calls to <span class="math inline">O(u)</span> time string matching. The total running time is therefore <span class="math inline">O(u\log \frac{n}{u})</span>.</p>
<p>In many applications, we do not get oracle access to <span class="math inline">i</span>th index of the sequence. But we can read the sequence from the beginning as a list. In that case, we don't do binary search, but linear search. Advance the index by <span class="math inline">u</span> and obtain <span class="math inline">n&#39;</span>, and test if <span class="math inline">n</span> is no larger than the current point. If so, again we have <span class="math inline">n\in [n&#39;-u,n&#39;]</span> and reduce to the previous problem. If not, advance the index by <span class="math inline">u</span> again and repeat. This gives us a <span class="math inline">O(n+u)</span> time algorithm.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-02-05">2019-02-05</time>. </div>
    <div class="info">Tags: algorithms, infinite sequence.</div>
</div>]]></description>
    <pubDate>Tue, 05 Feb 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-02-05-eventually-periodic.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Bottleneck <span class="math inline">k</span>-link path</title>
    <link>https://chaoxuprime.com/posts/2019-01-31-bottleneck-k-link-path.html</link>
    <description><![CDATA[<br />
<div>
<p>A DAG is called complete, if there are vertices <span class="math inline">v_1,\ldots,v_n</span>, and <span class="math inline">v_iv_j</span> is an edge if and only if <span class="math inline">i&lt;j</span>. Let <span class="math inline">w(i,j)</span> be the edge weights from <span class="math inline">i</span> to <span class="math inline">j</span>. The weight is called ordered, if <span class="math inline">w(i,j)&lt;w(i,j+1)</span> and <span class="math inline">w(i+ 1,j)&lt;w(i,j)</span>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Bottleneck <span class="math inline">k</span>-link path problem</span></span>
<p>Find a path consists of <span class="math inline">k</span> edges from <span class="math inline">v_1</span> to <span class="math inline">v_n</span>, such that the maximum weight of the edges in the path is minimized.</p>
</section>
<p>One can formulate a dynamic programming algorithm, which takes <span class="math inline">O(kn^2)</span> time. My <a href="https://chaoxuprime.com/posts/2013-08-16-more-algorithms-on-perfectly-balanced-photo-gallery.html">previous writing</a> shows an <span class="math inline">O(kn)</span> time algorithm using the monge property. Using binary search, there is also an <span class="math inline">O(k\log(n/k)\log M)</span> time algorithm if all weights are positive integers no larger than <span class="math inline">M</span>.</p>
<p>We show there is an <span class="math inline">O(n+k\log(n/k)\log n)</span> time algorithm. Assume <span class="math inline">\lambda^*</span> is the optimal weight. First, there is an oracle that given <span class="math inline">\lambda</span>, decides if <span class="math inline">\lambda\geq \lambda^*</span>. Indeed, we can apply the greedy algorithm. Find the sequence <span class="math inline">a_1,\ldots,a_k</span>, as follows. <span class="math inline">a_0=1</span>, <span class="math inline">a_i</span> is the largest value such that <span class="math inline">w(a_{i-1},a_i)\leq \lambda</span>. If <span class="math inline">a_k=n</span>, then it is clear that <span class="math inline">\lambda \geq \lambda^*</span>. Also, we can show if <span class="math inline">a_k&lt;n</span>, then <span class="math inline">\lambda &lt; \lambda^*</span>. <span class="math inline">O(n)</span> time seems to be a quite large bound. We could do it in <span class="math inline">O(k\log (n))</span> instead by doing binary search for each <span class="math inline">a_i</span>. Using <a href="https://en.wikipedia.org/wiki/Exponential_search">exponential search</a> instead, we can obtain a <span class="math inline">O(k\log(n/k))</span> time algorithm.</p>
<p>One need to do binary search for <span class="math inline">\lambda^*</span>. There are <span class="math inline">\Omega(n^2)</span> weights, let it be <span class="math inline">W</span>. One does not have to know all of them in order to apply binary search. Note that <span class="math inline">w</span> is a matrix sorted in both row and column, hence we need a selection algorithm that returns the <span class="math inline">k</span>th smallest element for such matrix. There is an <a href="https://chaoxuprime.com/posts/2014-04-02-selection-in-a-sorted-matrix.html"><span class="math inline">O(n)</span> time algorithm</a> for that. Hence we can do binary search on the sorted <span class="math inline">W</span> by spending <span class="math inline">O(n)</span> time to access <span class="math inline">i</span>th element. We now obtain a <span class="math inline">O((n+ k\log(n/k)) \log n) = O(n\log n)</span> time algorithm. Not bad.</p>
<p>We can speed it up even further. Instead of selection in the sorted matrix, we can do <a href="https://chaoxuprime.com/posts/2019-01-30-search-sorted-matrixhtml">search in the sorted matrix</a>. We are given an oracle to test if a value is smaller than <span class="math inline">\lambda^*</span> after all. We can do search for <span class="math inline">\lambda^*</span> using <span class="math inline">O(\log n)</span> oracle calls and <span class="math inline">O(n)</span> time. Hence this gives us a <span class="math inline">O(n+k\log (n/k) \log n)</span> time algorithm for the problem. Whenever <span class="math inline">k=O(\frac{n}{\log(n) \log \log n})</span>, this is <span class="math inline">O(n)</span> time.</p>
<p>As an application, we obtain a solution to <a href="https://leetcode.com/problems/split-array-largest-sum/">Leetcode 410 Split Array Largest Sum</a>. The problem is also called the <em>linear partitioning</em> problem. The problem asks one to partition array into <span class="math inline">k</span> contagious subarrays that minimizes the maximum sum of each subarray. It was an example for learning dynamic programming in chapter 8.5 of <span class="citation" data-cites="Skiena10book">[<a href="#ref-Skiena10book">1</a>]</span>. An <span class="math inline">O(kn^2)</span> algorithm was given. Reading the discussion online, one would find <span class="math inline">O(n\log M)</span> time algorithm is the suggested solution, where <span class="math inline">M</span> is the maximum over all integers. The algorithm is actually fairly useful for photo galleries. There is the <a href="https://www.npmjs.com/package/linear-partitioning">NPM package <code>linear-partitioning</code></a>, used by multiple photo galleries packages. My <a href="https://chaoxuprime.com/posts/2013-08-16-more-algorithms-on-perfectly-balanced-photo-gallery.html">first encountered of the problem</a> was also for photo gallery. The linear partition problem reduces to the bottleneck <span class="math inline">k</span>-link path problem because we can define <span class="math inline">w(i,j)</span> to be the sum of elements from the <span class="math inline">i</span>th index of the array to the <span class="math inline">j</span>th index of the array. After <span class="math inline">O(n)</span> preprocessing, <span class="math inline">w(i,j)</span> can be computed in <span class="math inline">O(1)</span> time. This results a <span class="math inline">O(n+k\log (n/k) \log n)</span> running time algorithm.</p>
<p>What about when <span class="math inline">k</span> is large? I've emailed <a href="https://samsonzhou.github.io/">Samson Zhou</a>, who has confirmed the algorithm in <span class="citation" data-cites="FredericksonZ17">[<a href="#ref-FredericksonZ17">2</a>]</span> can be used to solve the problem in <span class="math inline">O(n)</span> time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Skiena10book">
<p>[1] S.S. Skiena, <strong>The algorithm design manual</strong>, Springer, 2010.</p>
</div>
<div id="ref-FredericksonZ17">
<p>[2] G.N. Frederickson, S. Zhou, <strong>Optimal parametric search for path and tree partitioning</strong>, CoRR. abs/1711.00599 (2017).</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-01-31">2019-01-31</time>. </div>
    <div class="info">Tags: algorithm, data structure.</div>
</div>]]></description>
    <pubDate>Thu, 31 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-01-31-bottleneck-k-link-path.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>

    </channel>
</rss>
