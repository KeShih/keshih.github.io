<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>The Art Gallery Guardian</title>
        <link>https://chaoxuprime.com</link>
        <description><![CDATA[Mostly notes on algorithms]]></description>
        <atom:link href="https://chaoxuprime.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 27 Apr 2019 00:00:00 UT</lastBuildDate>
        <item>
    <title>Union of intervals in SQL</title>
    <link>https://chaoxuprime.com/posts/2019-04-27-union-of-intervals-in-sql.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>We given a collection of intervals, and we want to find its union, represented by a set of disjoint intervals. Assume the intervals are of the form <span class="math inline">[a,b)</span>, where <span class="math inline">a&lt;b</span>. However, I have to solve this problem in Hive. So this is a problem I have to solve in Hive's SQL variant.</p>
<p>First, here is the schema of the table and some sample inputs.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> t (
  a <span class="dt">int</span>,
  b <span class="dt">int</span>
);
<span class="kw">INSERT</span> <span class="kw">INTO</span> t <span class="kw">VALUES</span>
  (<span class="dv">0</span>,<span class="dv">10</span>),
  (<span class="dv">20</span>,<span class="dv">30</span>),
  (<span class="dv">5</span>,<span class="dv">15</span>);</code></pre></div>
<p>The correct output should be the following.</p>
<pre><code>a    b
-------
0    15
20   30</code></pre>
<p>We do not allow empty intervals, so we cannot have <span class="math inline">a=b</span>.</p>
<h1 id="previous-works"><span class="header-section-number">2</span> Previous Works</h1>
<p>Note this is a common interview problem, <a href="https://leetcode.com/problems/merge-intervals/">LeetCode 56. Merge Intervals</a>. I was surprised find a <a href="https://stackoverflow.com/a/8120432/303863">very short solution on stackoverflow</a>.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> 
       t1.a,
       <span class="fu">MIN</span>(t2.b) <span class="kw">AS</span> b
<span class="kw">FROM</span> t t1 
<span class="kw">INNER</span> <span class="kw">JOIN</span> t t2 <span class="kw">ON</span> t1.a &lt;= t2.b
  <span class="kw">AND</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span>(<span class="kw">SELECT</span> * <span class="kw">FROM</span> t 
                 <span class="kw">WHERE</span> t2.b &gt;= t.a <span class="kw">AND</span> t2.b &lt; t.b) 
<span class="kw">WHERE</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span>(<span class="kw">SELECT</span> * <span class="kw">FROM</span> t
                 <span class="kw">WHERE</span> t1.a &gt; t.a <span class="kw">AND</span> t1.a &lt;= t.b) 
<span class="kw">GROUP</span> <span class="kw">BY</span> t1.a
<span class="kw">ORDER</span> <span class="kw">BY</span> t1.a</code></pre></div>
<p>Unfortunately, once you know how the entire algorithm goes, one can see its performance does not look promising. Also, making it work in Hive is next to impossible due to Hive's limitations on joins and subqueries.</p>
<p><a href="http://tsql.solidq.com/">Itzik Ben-Gan</a> has <a href="https://www.itprotoday.com/development-techniques-and-management/packing-date-intervals">written</a> <a href="https://blogs.solidq.com/en/sqlserver/packing-intervals/">multiple</a> <a href="https://www.itprotoday.com/sql-server/new-solution-packing-intervals-problem">articles</a> on how to solve this problem. I recommend reading them to learn various tricks. In fact, my solution here is quite similar to one of Ben-Gan's.</p>
<h1 id="using-basic-sql"><span class="header-section-number">3</span> Using basic SQL</h1>
<p>Here we will try to implement an algorithm using the most basic of SQL, so it would even work in Hive. We first build a table, such that <span class="math inline">(a,i,j)</span> is in the table shows that there are <span class="math inline">j</span> intervals covering <span class="math inline">a</span>, and there are <span class="math inline">i</span> intervals covering the previous point.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">VIEW</span> r <span class="kw">AS</span> 
<span class="kw">SELECT</span> a,
       <span class="fu">Sum</span>(d) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a <span class="kw">ROWS</span> <span class="kw">BETWEEN</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span> <span class="dv">1</span> <span class="kw">PRECEDING</span>) <span class="kw">AS</span> i,
       <span class="fu">Sum</span>(d) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a <span class="kw">ROWS</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span>) <span class="kw">AS</span> j
<span class="kw">FROM</span>  (<span class="kw">SELECT</span> a, <span class="fu">Sum</span>(d) <span class="kw">AS</span> d
       <span class="kw">FROM</span>   (<span class="kw">SELECT</span> a,  <span class="dv">1</span> <span class="kw">AS</span> d <span class="kw">FROM</span> t
               <span class="kw">UNION</span> <span class="kw">ALL</span>
               <span class="kw">SELECT</span> b, -<span class="dv">1</span> <span class="kw">AS</span> d <span class="kw">FROM</span> t) e
       <span class="kw">GROUP</span>  <span class="kw">BY</span> a) f; </code></pre></div>
<p>Next, we produce all the endpoints in the union of the intervals and pair up adjacent ones. Finally, we produce the set of intervals by only pick the odd-numbered rows.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> a, b
<span class="kw">FROM</span> (<span class="kw">SELECT</span> a,
             <span class="fu">Lead</span>(a)      <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> b,
             <span class="fu">Row_number</span>() <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> n
      <span class="kw">FROM</span>   r
      <span class="kw">WHERE</span>  j=<span class="dv">0</span> <span class="kw">OR</span> i=<span class="dv">0</span> <span class="kw">OR</span> i <span class="kw">is</span> <span class="kw">null</span>) e
<span class="kw">WHERE</span>  n%<span class="dv">2</span> = <span class="dv">1</span>;</code></pre></div>
<p>You can find <a href="https://www.db-fiddle.com/f/aVaF6NDTVYmxBpifsHDFBf/6">the example in DB-fiddle</a>. I am interested to seeing simpler and faster code using the simplest of SQL.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-04-27. </div>
    <div class="info">Tags: SQL, algorithm.</div>

</div>]]></description>
    <pubDate>Sat, 27 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-04-27-union-of-intervals-in-sql.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Maximum weight hierarchical <span class="math inline">b</span>-matching</title>
    <link>https://chaoxuprime.com/posts/2019-04-27-maximum-weight-hierarchical-b-matching.html</link>
    <description><![CDATA[<br />
<div>
<p>We consider the following problem, which appeared in <span class="citation" data-cites="EmekKSZ19">[<a href="#ref-EmekKSZ19">1</a>]</span>.</p>
<p>Let <span class="math inline">\mathcal{L}</span> be a laminar family consists of sets <span class="math inline">F_1,\ldots,F_k</span>. Let <span class="math inline">u_1,\ldots,u_k</span> to be positive integers. Consider a graph <span class="math inline">G=(V,E)</span> with a weight function <span class="math inline">w:E\to \N</span> and capacity function <span class="math inline">c:E\to \N</span>. We are interested in finding a <span class="math inline">y\leq c</span>, such that for every <span class="math inline">F_i\in \mathcal{L}</span>, we have <span class="math inline">\sum_{v\in F_i} \sum_{e:v\in e\in E} y_e \leq u_i</span>, and <span class="math inline">\sum_{e\in E} y_ew_e</span> is maximized.</p>
<p>Formally, it is the following integer program.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
&amp; \max_{y\in \Z^m} &amp; &amp; \sum_{e} w_e y_e &amp; \\
&amp; \text{s.t.} &amp; &amp; \sum_{v\in F_i} \sum_{e:v\in e\in E} y_e \leq u_i &amp; i\in [k] \\
&amp; &amp; &amp;  0\leq y_e \leq c_e &amp; \forall e\in E \\
\end{aligned}
</span></p>
<p>This is a generalization of the maximum weight <span class="math inline">c</span>-capacitated <span class="math inline">b</span>-matching problem. Indeed, we can simply set <span class="math inline">F_i = \set{v_i}</span> and <span class="math inline">u_i=b_i</span>. However, this problem is actually no more general than the maximum weight <span class="math inline">c</span>-capacitated <span class="math inline">b</span>-matching problem.</p>
<p>Let <span class="math inline">A \in \Z^{m\times n}</span> to be a matrix such that <span class="math inline">\sum_{i=1}^m |A_{i,j}|\leq 2</span> for every <span class="math inline">j</span>. We call <span class="math inline">A</span> a bidirected matrix.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>Given <span class="math inline">A \in \Z^{m\times n}</span> a bidirected matrix and vectors <span class="math inline">a,b\in \Z^m</span>, <span class="math inline">c,d,w\in \Z^n</span>. The integer program <span class="math inline">\max_{x\in \Z^n} \set{wx \mid a\leq Ax\leq b, c\leq x\leq d}</span> can be solved in polynomial time. In particular, it is equivalent to the maximum weight <span class="math inline">b</span>-matching problem on graph of size <span class="math inline">poly(m,n)</span>.</p>
</section>
<p>The above theorem can be found in <span class="citation" data-cites="Schrijver03">[<a href="#ref-Schrijver03">2</a>]</span>. Note that in Schrijver's book, one require <span class="math inline">\sum_{i=1}^m |A_{i,j}|=2</span>. It is not hard to see the statement still holds even if we have <span class="math inline">\leq</span> in place of <span class="math inline">=</span>.</p>
<p>We will express the maximum weight hierarchical <span class="math inline">b</span>-matching problem as an integer program based on a bidirected matrix. The integer program is a modification of the integer program in <span class="citation" data-cites="KaparisLM17">[<a href="#ref-KaparisLM17">3</a>]</span>. The integer program here is simpler, because we are not trying to reduce to <em>perfect</em> <span class="math inline">b</span>-matching.</p>
<p>We define <span class="math inline">F_i&#39; = F_i \setminus \bigcup_{j: F_j\subsetneq F_i} F_j</span>. We also define <span class="math inline">C_i</span> to be the indices <span class="math inline">j</span>, such that for all <span class="math inline">k</span>, <span class="math inline">F_j\subseteq F_k \subsetneq F_i</span> implies <span class="math inline">j=k</span>. <span class="math inline">y_e</span> denote the amount of capacities we assign to <span class="math inline">e</span>, <span class="math inline">x_v</span> denotes the capacitated degree, hence <span class="math inline">x_v = \sum_{e:v\in e\in E} y_e</span>. We define <span class="math inline">z_i = \sum_{v\in F_i} x_v</span>, which can be transformed to <span class="math inline">z_i = \sum_{v\in F_i&#39;} x_v + \sum_{j\in C_i} z_j</span>. Therefore we obtain the following integer program by directly applying substitutions.</p>
<span class="math">\begin{aligned}
& \max_{x\in \Z^n,y\in \Z^m, z\in \Z^k} & & \sum_{e} w_e y_e & \\
& \text{s.t.} & & \sum_{v\in F_i'} x_v + \sum_{j\in C_i} z_j = 0 & i\in [k] \\
& & &  \sum_{e: v\in e\in E} y_e -x_v = 0 & \forall v\in V \\
& & &  0\leq y_e \leq c_e & \forall e\in E \\
& & &  0\leq z_i \leq u_i & \forall i\in [k] \\
\end{aligned}</span>
<p>It's easy to see the matrix here is a bidirected matrix. This shows the original problem can be solved in polynomial time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-EmekKSZ19">
<p>[1] Y. Emek, S. Kutten, M. Shalom, S. Zaks, <strong>Hierarchical b-Matching</strong>, arXiv E-Prints. (2019) arXiv:1904.10210.</p>
</div>
<div id="ref-Schrijver03">
<p>[2] A. Schrijver, <strong>Combinatorial Optimization (3 volume, A, B, &amp; C)</strong>, Springer, 2003.</p>
</div>
<div id="ref-KaparisLM17">
<p>[3] I.M. Konstantinos Kaparis Adam N. Letchford, <strong>On matroid parity and matching polytopes</strong>, Department of Management Science, Lancaster University, 2017.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-04-27. </div>
    <div class="info">Tags: combinatorial optimization, matching, matroid.</div>

</div>]]></description>
    <pubDate>Sat, 27 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-04-27-maximum-weight-hierarchical-b-matching.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Misleading while being honest</title>
    <link>https://chaoxuprime.com/posts/2019-04-06-misleading-while-being-honest.html</link>
    <description><![CDATA[<br />
<div>
<p>Given a set of data <span class="math inline">A</span>, we can plot it on a <a href="https://en.wikipedia.org/wiki/Radar_chart">radar chart</a>. One can permute the axis to make sure the area of the radar chart is maximized. This was explored in <a href="https://chaoxuprime.com/posts/2012-08-08-maximize-the-area-of-a-radar-chart.html">a previous article</a>.</p>
<p>More interesting problem. Given two sets of data <span class="math inline">A</span> and <span class="math inline">B</span>, we are interested in finding a common radar chart, that make <span class="math inline">A</span> look as good as possible compared to <span class="math inline">B</span>. We might want to optimize the area ratio, area difference, or something else. Again, we are thinking of permuting the axis of the radar chart.</p>
<p>I once mentioned this problem to <a href="https://www.contrib.andrew.cmu.edu/~ravi/">R Ravi</a>, and he suggest I could ask the same question for all kind of different graphs. How to mislead people with graphs while being completely honest? Indeed, this looks like a fun research project. There is a <a href="https://en.wikipedia.org/wiki/Misleading_graph">wikipedia article completely devoted to it</a>. In my <a href="https://chaoxuprime.com/posts/2019-03-28-l1-linear-regression.html">previous post</a>, I've discussed how to fitting two seemingly not that related data points through simple transformation.</p>
<p>I'm interested in are algorithmic problems where one want to compute the most misleading chart, I think it would be a great fun project.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-04-06. </div>
    <div class="info">Tags: data visualization.</div>

</div>]]></description>
    <pubDate>Sat, 06 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-04-06-misleading-while-being-honest.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title><span class="math inline">L_1</span> linear regression</title>
    <link>https://chaoxuprime.com/posts/2019-03-28-l1-linear-regression.html</link>
    <description><![CDATA[<br />
<div>
<p>I read an article on the <a href="https://medium.economist.com/mistakes-weve-drawn-a-few-8cdd8a42d368">errors in visualization</a>. The example of forcing a relationship by cherry-picking scales is delightful. I recommend reading it.</p>
<p>I am interested in misleading people while being completely honest. The article inspires the following problem. Given 2 vectors <span class="math inline">\bm{x},\bm{y}\in \R^n</span>. Let <span class="math inline">\bm{1}</span> be the all <span class="math inline">1</span> vector in <span class="math inline">\R^n</span>. We are interested in finding <span class="math inline">a,b\in \R</span>, such that <span class="math inline">\|\bm{y}-(a\bm{x}+b\bm{1})\|_p</span> is minimized. Here <span class="math inline">p</span> is either <span class="math inline">1,2</span> or <span class="math inline">\infty</span>.</p>
<p>Note the problem is precisely the same as the linear regression problem. In the linear regression problem, we are given a point set <span class="math inline">S\subset \R^2</span> of size <span class="math inline">n</span> and we are interested in find a line <span class="math inline">f(x) = ax+b</span>, such that it minimizes the <em>error</em>, defined as</p>
<p><span class="math display">\displaystyle 
\sum_{(x,y)\in S} \|y - f(x)\|_p
</span></p>
<p>For <span class="math inline">p=2</span>, there is a <span class="math inline">O(n)</span> time algorithm because there is a closed formula. For <span class="math inline">p=\infty</span>, the problem can be rewritten as a linear program with <span class="math inline">3</span> variables and <span class="math inline">n</span> constraints. Using Megiddo's result <span class="citation" data-cites="Megiddo84">[<a href="#ref-Megiddo84">1</a>]</span>, there is a <span class="math inline">O(n)</span> time algorithm to solve this problem.</p>
<p>It is hard to find the worst case complexity when <span class="math inline">p=1</span>. This case is called the <em>least absolute deviations</em>. Statisticians just don't care about worst case running time as CS people do.</p>
<p>There are a few methods I found. One is to write it as a linear program on <span class="math inline">n+2</span> variables and <span class="math inline">n</span> constraints and solve it using the simplex method. The linear program is as follows.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
&amp; \min_{a,b,t_1,\ldots,t_n}
&amp; &amp; \sum_{i=1}^n t_i &amp; \\
&amp; \text{s.t.} &amp; &amp;  t_i \geq (ax_i+b)-y_i &amp; \forall 1 \leq i \leq n \\
&amp; &amp; &amp;  t_i \leq y_i-(ax_i+b) &amp; \forall 1 \leq i \leq n \\
\end{aligned}
</span></p>
<p>There are a bunch of other algorithms that specializes the simplex algorithm on this particular problem. There are also some iterative methods. Unfortunately, those algorithms depends on the actual numbers in the input. I want a running time that only depends on <span class="math inline">n</span>.</p>
<p>There exists an optimal solution that contains two points in <span class="math inline">S</span>. The native algorithm is to try all possible <span class="math inline">O(n^2)</span> lines. For each line, the algorithm can compute the error in <span class="math inline">O(n)</span> time. The naive algorithm's running time is <span class="math inline">O(n^3)</span>. There is a smarter algorithm. The optimal line that contains the point can actually be found in <span class="math inline">O(n)</span> time. Indeed, consider the line passes through the point <span class="math inline">(x,y)</span>. We consider changing the slope of the line, while maintaining it still contain <span class="math inline">(x,y)</span>. One can see a minimum will be reached at some line. Indeed, assume we reorder the points, so <span class="math inline">\frac{y_i-y}{x_i-x}\leq \frac{y_{i+1}-y}{x_{i+1}-x}</span> (namely, increasing slope). Let <span class="math inline">k</span> be the smallest integer such that the sum of <span class="math inline">\sum_{i=1}^k |x_i-x|\geq \sum_{i=k+1}^n |x_i-x|</span>. The line determined by <span class="math inline">(x,y)</span> and <span class="math inline">(x_k,y_k)</span> is the desired line. This can be computed in linear time by finding weighted median. Hence one can show the running time is <span class="math inline">O(n^2)</span>. This is the idea of <span class="citation" data-cites="BloomfieldS80">[<a href="#ref-BloomfieldS80">2</a>]</span>. As far as I know, this seems to be the state of the art in terms of worst case complexity.</p>
<p>After discussing with <a href="https://sites.google.com/site/qizhenghe96/home">Qizheng He</a>, he suggested the following approach. Consider the function <span class="math inline">g_p(s)</span> for <span class="math inline">p\in S</span>. It is defined as the error for the line of slope <span class="math inline">s</span> that contains <span class="math inline">p</span>. The function is bitonic, therefore we can do a ternary search to find the minimum. There are only <span class="math inline">n-1</span> possible slopes, hence the ternary search will take <span class="math inline">O(\log n)</span> queries, where each query asks for the error of the line that goes through <span class="math inline">p</span> and some other point.</p>
<p>Given a line <span class="math inline">f(x)=ax+b</span>, can one compute the error quickly? It is possible to decompose it to few halfspace range counting queries (allowing weights). In halfspace counting queries problem, we are given <span class="math inline">n</span> points with weights, we can preprocess it and obtain a data structure. Each query to a data structure is a halfspace, the output is the sum of all elements in the halfspace. In <span class="math inline">2</span>D, there exists a preprocessing time <span class="math inline">\tilde{O}(n^{4/3})</span> and query time <span class="math inline">\tilde{O}(n^{1/3})</span> data structure <span class="citation" data-cites="Matousek93">[<a href="#ref-Matousek93">3</a>]</span>. Let <span class="math inline">S^+</span> be the set of points above <span class="math inline">f</span>, and <span class="math inline">S^-</span> be the set of points below <span class="math inline">f</span>. The result is precisely the following.</p>
<p><span class="math display">\displaystyle 
\sum_{(x,y)\in S^+} y - ax-b + \sum_{(x,y)\in S^-} ax+b - y
</span></p>
<p>Let's consider the second sum, <span class="math inline">\sum_{(x,y)\in S^-} ax+b - y = a\sum_{(x,y)\in S^-}x + |S^-|b -\sum_{(x,y)\in S^-}y</span>. Note the <span class="math inline">3</span> terms can each be solved with a halfspace counting query, consider all points lies below <span class="math inline">f</span>. This shows in <span class="math inline">6</span> halfspace counting queries.</p>
<p>How can one do ternary search? This would need us to be able to pick the point that gives us the <span class="math inline">i</span>th largest slope with <span class="math inline">p</span>. We need a data structure such that it can return the <span class="math inline">i</span>th largest point in the radial ordering of the points in <span class="math inline">S</span> around <span class="math inline">p</span>. It is equivalent to <a href="https://cstheory.stackexchange.com/questions/42609/data-structure-for-radial-orderings-of-points-on-the-plane">halfspace range counting up to polylog factors</a>.</p>
<p>Thus, the total running time after building the data structure in <span class="math inline">\tilde{O}(n^{4/3})</span> is <span class="math inline">n</span> times ternary search over <span class="math inline">n</span> elements, where each decision process takes <span class="math inline">\tilde{O}(n^{1/3})</span> time. Therefore the final running time is <span class="math inline">\tilde{O}(n^{4/3})</span> time.</p>
<p>Qizheng mentioned the problem to <a href="http://tmc.web.engr.illinois.edu">Timothy Chan</a>, who gave us some references. There is an easy solution that obtains <span class="math inline">O(n\log^2 n)</span> time algorithm using simple parametric search <span class="citation" data-cites="MegiddoT83">[<a href="#ref-MegiddoT83">4</a>]</span>. Consider the following linear program. Let <span class="math inline">k</span> be a constant. We are given <span class="math inline">a_1,\ldots,a_k,b_1,\ldots,b_n</span>, <span class="math inline">k</span>D vectors <span class="math inline">\beta_1,\ldots,\beta_m</span> and reals <span class="math inline">\alpha_1,\ldots,\alpha_m</span>. Sets <span class="math inline">J_1,\ldots,J_n</span> a partition of <span class="math inline">[m]</span>.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
&amp; \min_{w_1,\ldots,w_k,x_1,\ldots,x_n}
&amp; &amp; \sum_{i=1}^k a_iw_i + \sum_{i=1}^n b_ix_i &amp; \\
&amp; \text{s.t.} &amp; &amp;  x_i \geq (\sum_{d=1}^k \beta_{j,d} w_d) - \alpha_j &amp; \forall 1 \leq i \leq n, j\in J_i
\end{aligned}
</span></p>
<p>Zemel showed such linear program can be solved in <span class="math inline">O(m)</span> time for constant <span class="math inline">k</span> <span class="citation" data-cites="Zemel84">[<a href="#ref-Zemel84">5</a>]</span>. The idea is a similar algorithm to Megiddo's linear time constant dimension LP algorithm <span class="citation" data-cites="Megiddo84">[<a href="#ref-Megiddo84">1</a>]</span>. For linear regression problem in <span class="math inline">L_1</span> with <span class="math inline">n</span> data points. The linear program we derived is a special case of the above linear program when <span class="math inline">k=2</span> and <span class="math inline">m=O(n)</span>. In fact, Zemel use the same linear program to show constant dimension <span class="math inline">L_1</span> regression can be solved in linear time.</p>
<h1 id="open-problem"><span class="header-section-number">1</span> Open problem</h1>
<p>One can also define another metric, the lexicographical minimum. Such idea was already present in fairness related linear regression <span class="citation" data-cites="KoeppenYO14">[<a href="#ref-KoeppenYO14">6</a>]</span>. Once we sort the values of <span class="math inline">|y - f(x)|</span> for <span class="math inline">(x,y)\in S</span>, say obtaining <span class="math inline">a_1,\ldots,a_n</span>, where <span class="math inline">a_1\geq a_2 \geq \ldots \geq a_n</span>. We are interested in finding a <span class="math inline">f</span> that minimizes the sequence <span class="math inline">a_1,\ldots,a_n</span>, lexicographically. Can this problem be solved in <span class="math inline">O(n)</span> time?</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Megiddo84">
<p>[1] N. Megiddo, <strong>Linear programming in linear time when the dimension is fixed</strong>, J. ACM. 31 (1984) 114–127 <a href="https://doi.org/10.1145/2422.322418">10.1145/2422.322418</a>.</p>
</div>
<div id="ref-BloomfieldS80">
<p>[2] P. Bloomfield, W. Steiger, <strong>Least absolute deviations curve-fitting</strong>, SIAM Journal on Scientific and Statistical Computing. 1 (1980) 290–301 <a href="https://doi.org/10.1137/0901019">10.1137/0901019</a>.</p>
</div>
<div id="ref-Matousek93">
<p>[3] J. Matoušek, <strong>Range searching with efficient hierarchical cuttings</strong>, Discrete &amp; Computational Geometry. 10 (1993) 157–182 <a href="https://doi.org/10.1007/BF02573972">10.1007/BF02573972</a>.</p>
</div>
<div id="ref-MegiddoT83">
<p>[4] N. Megiddo, A. Tamir, <strong>Finding Least-Distances Lines</strong>, SIAM Journal on Algebraic Discrete Methods. 4 (1983) 207–211 <a href="https://doi.org/10.1137/0604021">10.1137/0604021</a>.</p>
</div>
<div id="ref-Zemel84">
<p>[5] E. Zemel, <strong>An O(n) algorithm for the linear multiple choice knapsack problem and related problems</strong>, 18 (1984) 123–128 <a href="https://doi.org/10.1016/0020-0190(84)90014-0">10.1016/0020-0190(84)90014-0</a>.</p>
</div>
<div id="ref-KoeppenYO14">
<p>[6] M. Köeppen, K. Yoshida, K. Ohnishi, Evolving fair linear regression for the representation of human-drawn regression lines, in: 2014 International Conference on Intelligent Networking and Collaborative Systems, 2014: pp. 296–303 <a href="https://doi.org/10.1109/INCoS.2014.89">10.1109/INCoS.2014.89</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-03-28. </div>
    <div class="info">Tags: combinatorial optimization.</div>

</div>]]></description>
    <pubDate>Thu, 28 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-03-28-l1-linear-regression.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Densest subgraph variation</title>
    <link>https://chaoxuprime.com/posts/2019-03-24-densest-subgraph-variation.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">G=(V,E)</span> be a graph. Consider an edge weight function <span class="math inline">w:E\to \R^+</span> and a vertex cost function <span class="math inline">c:V\to \R^+</span>.</p>
<p>We are interested in finding <span class="math inline">S\subset V</span>, such that <span class="math inline">w(E(S))-c(S)</span> is maximized.</p>
<p>This is very close to the densest subgraph problem, as it is basically the Lagrangian relaxation of the problem.</p>
<p>This problem is equivalent to a min-<span class="math inline">st</span>-cut computation on a suitable graph. Indeed, minimizing <span class="math inline">w(E(S))-c(S)</span> is equivalent to minimizing <span class="math inline">c(S) + \frac{1}{2} w(E(S,\bar{S})) + \frac{1}{2} \sum_{v\in \bar{S}} \deg(v)</span>. This can be solved easily by modeling it as a min-<span class="math inline">st</span>-cut.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-03-24. </div>
    <div class="info">Tags: combinatorial optimization.</div>

</div>]]></description>
    <pubDate>Sun, 24 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-03-24-densest-subgraph-variation.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Finger tree allowing apply functions to each element</title>
    <link>https://chaoxuprime.com/posts/2019-03-10-finger-tree-apply-function-to-each-element.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">(M,+)</span> be a monoid. We are interested in maintaining a sequence <span class="math inline">a = a_1,\ldots,a_n\in M</span> under all updates currently supported by finger tree. However, we are also interested in adding another update, which we call the function update.</p>
<p>Let <span class="math inline">f = f_1,\ldots,f_n\in M\to M</span>.</p>
<p>The functions satisfies the following property.</p>
<p><span class="math inline">f_1(x_1)+\ldots+f_n(x_n) = f_1(y_1)+\ldots+f_n(y_n)</span> if <span class="math inline">\sum_{i=1}^n x_i = \sum_{i=1}^n y_i</span>.</p>
<p>The sequence <span class="math inline">f</span> is given implicitly, where it has two methods:</p>
<ul>
<li><code>evaluate(X)</code>: It returns <span class="math inline">f_1(x_1) + \ldots +f_n(x_n)</span> for any sequence <span class="math inline">x_1,\ldots,x_n</span> such that <span class="math inline">\sum_{i=1}^n x_i = X</span>.</li>
<li><code>split(j)</code>: returns a representation for <span class="math inline">f_1,\ldots,f_j</span> and <span class="math inline">f_{j+1},\ldots,f_n</span>.</li>
</ul>
<p>We are interested in implementing <code>FunctionUpdate(a,f)</code>, the output would be a representation of the sequence <span class="math inline">f_1(a_1),\ldots,f_n(a_n)</span>.</p>
<p>Many problems actually require update to a entire interval of the sequence, which makes this extremely valuable. For example, consider the following simple problem.</p>
<p>Maintain a sequence of integers <span class="math inline">a_1,\ldots,a_n</span>, such that we can do the operation <span class="math inline">inc(i,j)</span>, which increment all numbers from <span class="math inline">i</span>th to <span class="math inline">j</span>th index by <span class="math inline">1</span>. That is, the new sequence is <span class="math inline">a_1,\ldots,a_{i-1},a_i+1,\ldots,a_j+1,a_{j+1},\ldots,a_n</span>. Also, it has a function <span class="math inline">value(i)</span> which returns <span class="math inline">a_i</span>. This problem can be solved by finger tree with function update operation.</p>
<p>I want an actual implementation of such data structure so I can implement the min-cost flow algorithm for series-parallel graphs <span class="citation" data-cites="Booth1993416">[<a href="#ref-Booth1993416">1</a>]</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Booth1993416">
<p>[1] H. Booth, R. Tarjan, <strong>Finding the minimum-cost maximum flow in a series-parallel network</strong>, Journal of Algorithms. 15 (1993) 416–446 <a href="https://doi.org/10.1006/jagm.1993.1048">10.1006/jagm.1993.1048</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-03-10. </div>
    <div class="info">Tags: data structure, lazy propagation.</div>

</div>]]></description>
    <pubDate>Sun, 10 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-03-10-finger-tree-apply-function-to-each-element.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Find the period of a nice eventually periodic sequence</title>
    <link>https://chaoxuprime.com/posts/2019-02-05-eventually-periodic.html</link>
    <description><![CDATA[<br />
<div>
<p>A sequence is periodic if <span class="math inline">s_i = s_{i+p}</span> for all <span class="math inline">i</span>, where <span class="math inline">p&gt;0</span> is called a period. A sequence is eventually periodic if there exists a <span class="math inline">n</span> and <span class="math inline">p</span>, such that <span class="math inline">s_i = s_{i+p}</span> for all <span class="math inline">i&gt;n</span>. The sequence with index above <span class="math inline">n</span> is the <em>periodic part</em>.</p>
<p>A sequence is called <em><span class="math inline">u</span>-normal</em>, if there exists <span class="math inline">s_i=s_{i+p}</span> for some <span class="math inline">p&gt;0</span> for all <span class="math inline">i</span> in a interval of length <span class="math inline">u</span>, then the sequence starting at <span class="math inline">s_i</span> is part of the periodic part.</p>
<p>When does <span class="math inline">u</span>-normal sequence comes up? Consider we have a recurrence relation that produces a sequence. Say it is of the form <span class="math inline">a_n = f(a_{n-1},a_{n-2},\ldots,a_{n-u})</span>. The sequence <span class="math inline">a_1,\ldots</span> is <span class="math inline">u</span>-normal.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a oracle that can take input <span class="math inline">i</span> and return the <span class="math inline">i</span>th element in a <span class="math inline">u</span>-normal eventually periodic sequence <span class="math inline">a</span>. Find the smallest lexicographic pair <span class="math inline">(n,p)</span> where <span class="math inline">p&gt;0</span>, such that <span class="math inline">a_i=a_{i+p}</span> for all <span class="math inline">i&gt;n</span>.</p>
</section>
<p>One can solve this problem in <span class="math inline">O(u \log \frac{n}{u})</span> time. First, consider the subsequence <span class="math inline">a_u,a_{2u},\ldots</span>. We guess an upper bound on <span class="math inline">n</span> through exponential search in the subsequence. There is a <span class="math inline">O(u)</span> time algorithm to decide if <span class="math inline">n&#39;\geq n</span>. For example using the <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KMP algorithm</a>. We can quickly locate a <span class="math inline">n&#39;</span> such that <span class="math inline">n\in [n&#39;-u,n&#39;]</span>.</p>
<p>Let's take the sequence <span class="math inline">a_{n&#39;-u},\ldots,a_{n&#39;+3u}</span>. We just need to solve the following problem. Given a <span class="math inline">O(u)</span> length string, find the longest suffix that appears at least twice in the sequence. Let such suffix be <span class="math inline">s</span>. We know <span class="math inline">|s|\geq 3u</span>, which <span class="math inline">s</span> has to overlap with any other occurrence of the sequence. The claim is that the partial match table in the KMP algorithm would give us such information. Hence we can obtain <span class="math inline">n</span>. <span class="math inline">p</span> can also be obtained in the same time. Note that KMP algorithm only uses the fact one can check equality of two elements. So the sequence can contain elements from very general space.</p>
<p>The total running time is <span class="math inline">O(\log \frac{n}{u})</span> calls to <span class="math inline">O(u)</span> time string matching. The total running time is therefore <span class="math inline">O(u\log \frac{n}{u})</span>.</p>
<p>In many applications, we do not get oracle access to <span class="math inline">i</span>th index of the sequence. But we can read the sequence from the beginning as a list. In that case, we don't do binary search, but linear search. Advance the index by <span class="math inline">u</span> and obtain <span class="math inline">n&#39;</span>, and test if <span class="math inline">n</span> is no larger than the current point. If so, again we have <span class="math inline">n\in [n&#39;-u,n&#39;]</span> and reduce to the previous problem. If not, advance the index by <span class="math inline">u</span> again and repeat. This gives us a <span class="math inline">O(n+u)</span> time algorithm.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-02-05. </div>
    <div class="info">Tags: algorithms, infinite sequence.</div>

</div>]]></description>
    <pubDate>Tue, 05 Feb 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-02-05-eventually-periodic.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Bottleneck <span class="math inline">k</span>-link path</title>
    <link>https://chaoxuprime.com/posts/2019-01-31-bottleneck-k-link-path.html</link>
    <description><![CDATA[<br />
<div>
<p>A DAG is called complete, if there are vertices <span class="math inline">v_1,\ldots,v_n</span>, and <span class="math inline">v_iv_j</span> is an edge if and only if <span class="math inline">i&lt;j</span>. Let <span class="math inline">w(i,j)</span> be the edge weights from <span class="math inline">i</span> to <span class="math inline">j</span>. The weight is called ordered, if <span class="math inline">w(i,j)&lt;w(i,j+1)</span> and <span class="math inline">w(i+ 1,j)&lt;w(i,j)</span>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Bottleneck <span class="math inline">k</span>-link path problem</span></span>
<p>Find a path consists of <span class="math inline">k</span> edges from <span class="math inline">v_1</span> to <span class="math inline">v_n</span>, such that the maximum weight of the edges in the path is minimized.</p>
</section>
<p>One can formulate a dynamic programming algorithm, which takes <span class="math inline">O(kn^2)</span> time. My <a href="https://chaoxuprime.com/posts/2013-08-16-more-algorithms-on-perfectly-balanced-photo-gallery.html">previous writing</a> shows an <span class="math inline">O(kn)</span> time algorithm using the monge property. Using binary search, there is also an <span class="math inline">O(k\log(n/k)\log M)</span> time algorithm if all weights are positive integers no larger than <span class="math inline">M</span>.</p>
<p>We show there is an <span class="math inline">O(n+k\log(n/k)\log n)</span> time algorithm. Assume <span class="math inline">\lambda^*</span> is the optimal weight. First, there is an oracle that given <span class="math inline">\lambda</span>, decides if <span class="math inline">\lambda\geq \lambda^*</span>. Indeed, we can apply the greedy algorithm. Find the sequence <span class="math inline">a_1,\ldots,a_k</span>, as follows. <span class="math inline">a_0=1</span>, <span class="math inline">a_i</span> is the largest value such that <span class="math inline">w(a_{i-1},a_i)\leq \lambda</span>. If <span class="math inline">a_k=n</span>, then it is clear that <span class="math inline">\lambda \geq \lambda^*</span>. Also, we can show if <span class="math inline">a_k&lt;n</span>, then <span class="math inline">\lambda &lt; \lambda^*</span>. <span class="math inline">O(n)</span> time seems to be a quite large bound. We could do it in <span class="math inline">O(k\log (n))</span> instead by doing binary search for each <span class="math inline">a_i</span>. Using <a href="https://en.wikipedia.org/wiki/Exponential_search">exponential search</a> instead, we can obtain a <span class="math inline">O(k\log(n/k))</span> time algorithm.</p>
<p>One need to do binary search for <span class="math inline">\lambda^*</span>. There are <span class="math inline">\Omega(n^2)</span> weights, let it be <span class="math inline">W</span>. One does not have to know all of them in order to apply binary search. Note that <span class="math inline">w</span> is a matrix sorted in both row and column, hence we need a selection algorithm that returns the <span class="math inline">k</span>th smallest element for such matrix. There is an <a href="https://chaoxuprime.com/posts/2014-04-02-selection-in-a-sorted-matrix.html"><span class="math inline">O(n)</span> time algorithm</a> for that. Hence we can do binary search on the sorted <span class="math inline">W</span> by spending <span class="math inline">O(n)</span> time to access <span class="math inline">i</span>th element. We now obtain a <span class="math inline">O((n+ k\log(n/k)) \log n) = O(n\log n)</span> time algorithm. Not bad.</p>
<p>We can speed it up even further. Instead of selection in the sorted matrix, we can do <a href="https://chaoxuprime.com/posts/2019-01-30-search-sorted-matrixhtml">search in the sorted matrix</a>. We are given an oracle to test if a value is smaller than <span class="math inline">\lambda^*</span> after all. We can do search for <span class="math inline">\lambda^*</span> using <span class="math inline">O(\log n)</span> oracle calls and <span class="math inline">O(n)</span> time. Hence this gives us a <span class="math inline">O(n+k\log (n/k) \log n)</span> time algorithm for the problem. Whenever <span class="math inline">k=O(\frac{n}{\log(n) \log \log n})</span>, this is <span class="math inline">O(n)</span> time.</p>
<p>As an application, we obtain a solution to <a href="https://leetcode.com/problems/split-array-largest-sum/">Leetcode 410 Split Array Largest Sum</a>. The problem is also called the <em>linear partitioning</em> problem. The problem asks one to partition array into <span class="math inline">k</span> contagious subarrays that minimizes the maximum sum of each subarray. It was an example for learning dynamic programming in chapter 8.5 of <span class="citation" data-cites="Skiena10book">[<a href="#ref-Skiena10book">1</a>]</span>. An <span class="math inline">O(kn^2)</span> algorithm was given. Reading the discussion online, one would find <span class="math inline">O(n\log M)</span> time algorithm is the suggested solution, where <span class="math inline">M</span> is the maximum over all integers. The algorithm is actually fairly useful for photo galleries. There is the <a href="https://www.npmjs.com/package/linear-partitioning">NPM package <code>linear-partitioning</code></a>, used by multiple photo galleries packages. My <a href="https://chaoxuprime.com/posts/2013-08-16-more-algorithms-on-perfectly-balanced-photo-gallery.html">first encountered of the problem</a> was also for photo gallery. The linear partition problem reduces to the bottleneck <span class="math inline">k</span>-link path problem because we can define <span class="math inline">w(i,j)</span> to be the sum of elements from the <span class="math inline">i</span>th index of the array to the <span class="math inline">j</span>th index of the array. After <span class="math inline">O(n)</span> preprocessing, <span class="math inline">w(i,j)</span> can be computed in <span class="math inline">O(1)</span> time. This results a <span class="math inline">O(n+k\log (n/k) \log n)</span> running time algorithm.</p>
<p>What about when <span class="math inline">k</span> is large? I've emailed <a href="https://samsonzhou.github.io/">Samson Zhou</a>, who has confirmed the algorithm in <span class="citation" data-cites="FredericksonZ17">[<a href="#ref-FredericksonZ17">2</a>]</span> can be used to solve the problem in <span class="math inline">O(n)</span> time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Skiena10book">
<p>[1] S.S. Skiena, <strong>The algorithm design manual</strong>, Springer, 2010.</p>
</div>
<div id="ref-FredericksonZ17">
<p>[2] G.N. Frederickson, S. Zhou, <strong>Optimal parametric search for path and tree partitioning</strong>, CoRR. abs/1711.00599 (2017).</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-31. </div>
    <div class="info">Tags: algorithm, data structure.</div>

</div>]]></description>
    <pubDate>Thu, 31 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-01-31-bottleneck-k-link-path.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Search in a sorted matrix with an oracle</title>
    <link>https://chaoxuprime.com/posts/2019-01-30-search-sorted-matrix.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider a infinite matrix <span class="math inline">M</span>. Another way to think about it is a function <span class="math inline">f:\N\to \N\to X</span>. A matrix <span class="math inline">M</span> is sorted if <span class="math inline">M_{i,j}\leq M_{i,j+1}</span> and <span class="math inline">M_{i,j}\leq M_{i+1,j}</span>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a sorted matrix <span class="math inline">M</span>, and an oracle that takes <span class="math inline">\lambda</span> returns if a value is <span class="math inline">\lambda &lt;\lambda^*</span> or <span class="math inline">\lambda \geq \lambda^*</span>. Find the largest value no larger than <span class="math inline">\lambda^*</span>.</p>
</section>
<p>Assuming there are at most <span class="math inline">k</span> elements no larger than <span class="math inline">\lambda^*</span>, and we know the smallest <span class="math inline">n</span> and <span class="math inline">m</span> such that <span class="math inline">M_{i,j}&gt;\lambda^*</span> if <span class="math inline">i&gt;n</span> or <span class="math inline">j&gt;m</span>. Also, let <span class="math inline">t</span> be the smallest number such that <span class="math inline">M_{t,t}&gt;\lambda^*</span>. One can see that <span class="math inline">t\leq \min(n,m)</span> and <span class="math inline">k=O(\max(n,m)^2)</span>.</p>
<p>Let's first consider the case when <span class="math inline">n</span> and <span class="math inline">m</span> is known and <span class="math inline">n\leq m</span>. It is <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">Leetcode 240. Search a 2D Matrix II</a>. However, our problem is more general, because comparison with <span class="math inline">\lambda^*</span> can only be done through the oracle. Craig Gidney wrote about an <a href="http://twistedoakstudios.com/blog/Post5365_searching-a-sorted-matrix-faster">optimal algorithm</a> with <span class="math inline">O(n\log \frac{m}{n})</span> running time, matrix access algorithm. However, the oracle access is too large. There are times where the oracle access is slow. For example, when using it as a subroutine for finding a <a href="https://chaoxuprime.com/posts/2019-01-31-bottleneck-k-link-path.html">bottleneck <span class="math inline">k</span>-link path</a>. There is an algorithm with optimal running time and <span class="math inline">O(\log(nm))</span> oracle access.</p>
<p>Let's consider a special case, where <span class="math inline">n=m=2^i</span> for some <span class="math inline">i</span>. This case was shown in <span class="citation" data-cites="FredericksonZ17">[<a href="#ref-FredericksonZ17">1</a>]</span>. For each submatrix, the two vertices on the opposite diagonal indicates the largest and smallest element in the submatrix. Hence each matrix can be represented by two numbers, indicate the maximum and minimum. These numbers are called the representative of the matrix. The idea is we keep two numbers <span class="math inline">\lambda_1</span> and <span class="math inline">\lambda_2</span>, such that we know <span class="math inline">\lambda^*\in [\lambda_1,\lambda_2]</span>. The algorithm keep partition the matrix into small matrices, updating <span class="math inline">\lambda_1</span> and <span class="math inline">\lambda_2</span>, and discard matrices outside the range. We apply the following algorithm. Let <span class="math inline">R</span> consists of the multiset of representatives of the matrix, and <span class="math inline">R&#39;</span> be the representatives that lies inside <span class="math inline">[\lambda_1,\lambda_2]</span>. We find <span class="math inline">\lambda</span>, the median of <span class="math inline">R&#39;</span>. Test if <span class="math inline">\lambda&lt;\lambda^*</span>. If so, then <span class="math inline">\lambda_1</span> updates to <span class="math inline">\lambda</span>, otherwise <span class="math inline">\lambda_2</span> updates to <span class="math inline">\lambda</span>. This step is done twice. Now, we split the matrices with more than one element into <span class="math inline">4</span> equally sized matrices, and repeat the algorithm. Recall at all times, the matrices does not contain any element in <span class="math inline">[\lambda_1,\lambda_2]</span> are discarded.</p>
<p>There is at most <span class="math inline">O(\log n)</span> iterations before range shrinks to a single element, hence at most <span class="math inline">O(\log n)</span> oracle calls. The difficulty is to show that the overall time is only <span class="math inline">O(n)</span>. Intuitively, in each iteration we quadruple the number of matrices, but we half it by two calls to the oracle. Therefore in <span class="math inline">\log n</span> steps we obtain roughly <span class="math inline">2^{\log n}=O(n)</span> matrices. However, at this point, the matrices are all singletons, and no more matrix can be created. We will only decrease the number of matrices by each oracle call. Careful reader can trace the whole argument in Lemma 2.1 of <span class="citation" data-cites="FredericksonZ17">[<a href="#ref-FredericksonZ17">1</a>]</span>.</p>
<p>For the more general case, one can find the proof in <span class="citation" data-cites="FredericksonJ84">[<a href="#ref-FredericksonJ84">2</a>]</span>. Note the proof is for selection, but one can easily modify it to work for search.</p>
<p>Now, <span class="math inline">n</span> and <span class="math inline">m</span> is not known, but we can quickly using exponential search to find it. Indeed, we just have to apply exponential search in the first row and first column using the oracle. This gives us an extra <span class="math inline">O(\log n + \log m)=O(\log nm)</span> oracle calls.</p>
<p>Let <span class="math inline">k</span> to be the number of elements no larger than <span class="math inline">\lambda^*</span>. We can get running time relative to <span class="math inline">k</span>. Use exponential search until we find the first <span class="math inline">i</span> such that <span class="math inline">M_{2^i,2^i}&gt;\lambda^*</span>. So we can upper bound <span class="math inline">t</span>. Then one can solve the problem with <span class="math inline">2</span> matrices. One <span class="math inline">t\times k</span> matrix and a <span class="math inline">k\times t</span> matrix. The total running time is therefore <span class="math inline">O(\log k+t\log k/t)=O(t\log k)</span>. In fact, we get <span class="math inline">O(\log k)</span> oracle calls and <span class="math inline">O(t\log k)</span> running time. Here we can take <span class="math inline">t</span> to be <span class="math inline">\sqrt{k}</span>, and obtain <span class="math inline">O(\sqrt{k}\log k)</span> time.</p>
<p>Note if we relax on number of oracle calls. I know how to get a <span class="math inline">O(\sqrt{k})</span> running time.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Given <span class="math inline">\lambda^*</span> and a <span class="math inline">n\times m</span> sorted matrix such that the <span class="math inline">i</span>th row has <span class="math inline">k_i</span> elements no larger than <span class="math inline">x</span>. Let <span class="math inline">k=\sum_{i} k_i</span>. We can find <span class="math inline">\lambda^*</span> in <span class="math inline">O(\sum_{i} \log (k_{i+1}-k_i+1) ) = O(n \log \frac{k}{n^2})</span> time.</p>
</section>
<p>The idea is simple, we do exponential search on each row to find the largest element no larger than <span class="math inline">\lambda^*</span>, but we reuse information from the previous row. This gives us the running time <span class="math inline">O(\sum_{i} \log (k_{i+1}-k_i+1) )</span>. The main difficulty is to show why is is <span class="math inline">O(n \log \frac{k}{n^2})</span>.</p>
<section class="theorem-environment Lemma" id="Lemma-3">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">3</span></span>
<p>If <span class="math inline">\sum_{i=1}^n k_i=k</span>, then <span class="math inline">\sum_{i=1}^n \log (k_{i+1}-k_i+1)=O(n\log k/n^2)</span>.</p>
</section>
<p>Once we show that, we can use the theorem to obtain <span class="math inline">O(\sqrt{k})</span> running time.</p>
<p>In fact, we can also get a very simple algorithm with running time <span class="math inline">O(h \log(k/h^2))</span>, where <span class="math inline">h</span> is the number of stairs in the staircase shape. However, it also uses <span class="math inline">O(h\log(k/h^2)</span> oracle calls. The idea is to use exponential search to find the boundary of the staircase, but we switch between boundaries: horizontal then vertical. It is open if we can obtain <span class="math inline">O(h\log(k/h^2))</span> running time and <span class="math inline">O(\log k)</span> oracle calls.</p>
<h1 id="remark"><span class="header-section-number">1</span> Remark</h1>
<p>There is an alternative algorithm which can be found in <span class="citation" data-cites="JacobR08">[<a href="#ref-JacobR08">3</a>]</span>. The alternative algorithm is quite close to a post about <a href="https://chaoxuprime.com/posts/2014-04-02-selection-in-a-sorted-matrix.html">selection in a sorted matrix</a>.</p>
<p>The careful reader might observe the known search algorithms follow the exact same structure as algorithms for selection. Indeed, we <em>are</em> doing selection but we do not know the rank of the element. Intuitively, many selection algorithm, the rank is <em>only used</em> to remove the correct set of candidates. Hence this suggest one can modify the algorithm to use the oracle call in place of the rank.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-FredericksonZ17">
<p>[1] G.N. Frederickson, S. Zhou, <strong>Optimal parametric search for path and tree partitioning</strong>, CoRR. abs/1711.00599 (2017).</p>
</div>
<div id="ref-FredericksonJ84">
<p>[2] G. Frederickson, D. Johnson, <strong>Generalized selection and ranking: Sorted matrices</strong>, SIAM Journal on Computing. 13 (1984) 14–30 <a href="https://doi.org/10.1137/0213002">10.1137/0213002</a>.</p>
</div>
<div id="ref-JacobR08">
<p>[3] R. Jacob, <strong>Binary search on two-dimensional data</strong>, Technische Universität München, 2008.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-30. </div>
    <div class="info">Tags: algorithm, data structure.</div>

</div>]]></description>
    <pubDate>Wed, 30 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-01-30-search-sorted-matrix.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>A Reviewer Assignment Problem</title>
    <link>https://chaoxuprime.com/posts/2019-01-29-reviewer-assignment.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider there are some reviewers and some papers. Each reviewer can review exactly one paper, and each reviewer is qualified to review some subset of papers. We are interested in maximizing the number of papers reviewed by at least <span class="math inline">k</span> reviewer, then under that constraint, maximize the paper reviewed by <span class="math inline">k+1</span> reviewer, etc. This make sure we are being fair in evaluating papers. It would try to avoid the case where most paper getting small number of reviews and a few papers getting unreasonable number of reviews.</p>
<p>Formally, we are given a bipartite graph <span class="math inline">G=(A,B,E)</span> of <span class="math inline">n</span> vertices and <span class="math inline">m</span> edges. A subset of edges <span class="math inline">M</span> is called a semi-matching, if <span class="math inline">\deg_M(v)=1</span> for all <span class="math inline">v\in A</span>. For a subset of edges <span class="math inline">M</span>, let <span class="math inline">g_M(i)</span> to be the number of vertices in <span class="math inline">B</span> with degree at least <span class="math inline">i</span>. We want to find a semi-matching <span class="math inline">M</span>, such that <span class="math inline">(g_M(k),g_M(k+1),\ldots,g_M(n))</span> is lexicographically maximum.</p>
<p>When <span class="math inline">k=1</span>, if <span class="math inline">M</span> minimizes the sum of the function <span class="math inline">\sum_{v\in B} f(\deg_M(v))</span> for any strictly convex increasing function <span class="math inline">f</span>, then <span class="math inline">(g_M(1),g_M(2),\ldots,g_M(n))</span> is lexicographically maximum. The problem therefore can be reduced to min-cost flow can be applied here directly, and obtain a polynomial time algorithm <span class="citation" data-cites="HarveyLLT06">[<a href="#ref-HarveyLLT06">1</a>]</span>.</p>
<p>When <span class="math inline">k=3</span>, the problem is NP-hard, since it would imply we have to maximized <span class="math inline">g_M(3)</span>, and this is already NP-hard because exact cover by <span class="math inline">3</span>-sets. That is, given a collection of sets of size <span class="math inline">3</span> each. Decide if there exists a subcollection that forms a partition of the universe.</p>
<p>The only unresolved case is <span class="math inline">k=2</span>. Interestingly, we can show it is also polynomial time solvable. First, one can see that maximizing <span class="math inline">(g_M(2),g_M(3),\ldots,g_M(n))</span> is equivalent to minimize <span class="math inline">\sum_{v, \deg_M(v)\geq 2} f(\deg_M(v))</span> for some strictly convex increasing function <span class="math inline">v</span>, and <span class="math inline">M</span> range through all semi-matchings so each vertex in <span class="math inline">B</span> has degree exactly <span class="math inline">2</span> (Assuming it exists).</p>
<p>Apollonio and Sebő shown the following problem is polynomial time solvable <span class="citation" data-cites="ApollonioS09">[<a href="#ref-ApollonioS09">2</a>]</span>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a graph <span class="math inline">G=(V,E)</span>, a integer <span class="math inline">k</span>, convex functions <span class="math inline">f_v:\N \to \R</span> for each <span class="math inline">v\in V</span>, and an edge cost function <span class="math inline">c:E\to \R</span>. One can find the following in polynomial time. <span class="math display">\displaystyle \min \left\{   \sum_{v\in V} f_v(\deg_M(v)) + \sum_{e\in M} c(e) \middle| M\subseteq E, |M|=k  \right\}</span></p>
</section>
<p>It's not hard to generalize it a bit further by requiring <span class="math inline">M</span> to respect some upper and lower bound on the vertices. Indeed, we can let <span class="math inline">f_v:\N\to \R\cup \set{\infty}</span>, and set <span class="math inline">f_v(x)=\infty</span> if <span class="math inline">x</span> is not between the upper and lower bounds.</p>
<p>Now, we are going to reduce the problem. The reduction is similar to the <a href="https://cstheory.stackexchange.com/questions/33857/is-two-or-zero-matching-in-a-bipartite-graph-np-complete/33859">one for <span class="math inline">2</span>-or-<span class="math inline">0</span> matching</a>.</p>
<p>For each vertex <span class="math inline">v\in B</span>, split into two vertices <span class="math inline">v_1</span> and <span class="math inline">v_2</span>. Define <span class="math inline">B_i=\set{v_1|v\in B}</span>. The new input graph consists of vertices <span class="math inline">B_1\cup B_2 \cup A</span>. <span class="math inline">v_1</span> and <span class="math inline">v_2</span> connects to the same vertices as <span class="math inline">v</span>. We add an edge between <span class="math inline">v_1</span> and <span class="math inline">v_2</span>, with very large cost <span class="math inline">C</span>. Say <span class="math inline">C=mn^2+1</span>. <span class="math inline">v_1</span> has both an upper and lower bound of <span class="math inline">1</span>. <span class="math inline">v_2</span> has a lower bound of <span class="math inline">1</span>. For each vertex in <span class="math inline">A</span>, add an upper and lower bound of <span class="math inline">1</span>. We have a strict convex function <span class="math inline">f_{v_2}(x)=x^2</span> on each vertex <span class="math inline">v_2</span>.</p>
<p>Let <span class="math inline">r=|A|</span>, <span class="math inline">p=|B|</span>. We solve <a href="#Problem-1">Problem 1</a> repeatedly for each <span class="math inline">k</span> from <span class="math inline">r</span> to <span class="math inline">r+p</span>.</p>
<p>Say there exists an optimal solution to the original problem with exactly <span class="math inline">t</span> vertices in <span class="math inline">B</span> with degree smaller than <span class="math inline">2</span>. Find the optimal solution to the new problem with <span class="math inline">k=r+t</span>. Let it be <span class="math inline">M&#39;</span>. We obtain <span class="math inline">M</span> from <span class="math inline">M&#39;</span> by identify pairs of vertices <span class="math inline">v_1</span> and <span class="math inline">v_2</span>. <span class="math inline">M</span> would be the solution to the original problem.</p>
<h1 id="extensions"><span class="header-section-number">1</span> Extensions</h1>
<p>I first heard of the problem from <span class="citation" data-cites="YesilcimenY19">[<a href="#ref-YesilcimenY19">3</a>]</span>, where they focused on <span class="math inline">k=1</span> case, but the reviewer can review more than one paper. This case can be handled easily. We can add degree upper and lower bounds to all vertices, and only look at subgraphs in <span class="math inline">M</span> that satisfies the upper and lower bounds. That is, we can also make sure no reviewers review too many papers too. Under that constraint, find <span class="math inline">(g_M(k),\ldots,g_M(n))</span> lexicographically. This is possible but more tricky, as we have to do some reduction from capacitated <span class="math inline">b</span>-matching to <span class="math inline">b</span>-matching.</p>
<p>There is a little more generalization. Assume for each paper, we have a lower bound of reviews <span class="math inline">d_v</span>. That is, it has to be reviewed by at least <span class="math inline">d_v</span> person to be useful. So translating to the graph case, we can impose the constraint that <span class="math inline">\deg_M(v)=0</span> or <span class="math inline">\deg_M(v)\geq d_v</span>. One can see maximizing <span class="math inline">(g_M(2),g_M(3),\ldots,g_M(n))</span> is equivalent to maximizing <span class="math inline">(g_M(1),g_M(2),\ldots,g_M(n))</span> where <span class="math inline">d_v=2</span> for all vertices. Again, one can modify the reduction to handle the case when <span class="math inline">d_v</span> is either <span class="math inline">1</span> or <span class="math inline">2</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-HarveyLLT06">
<p>[1] N.J. Harvey, R.E. Ladner, L. Lovász, T. Tamir, <strong>Semi-matchings for bipartite graphs and load balancing</strong>, Journal of Algorithms. 59 (2006) 53–78 <a href="https://doi.org/10.1016/j.jalgor.2005.01.003">10.1016/j.jalgor.2005.01.003</a>.</p>
</div>
<div id="ref-ApollonioS09">
<p>[2] N. Apollonio, A. Sebő, <strong>Minconvex factors of prescribed size in graphs</strong>, SIAM Journal on Discrete Mathematics. 23 (2009) 1297–1310 <a href="https://doi.org/10.1137/060651136">10.1137/060651136</a>.</p>
</div>
<div id="ref-YesilcimenY19">
<p>[3] A. Yeşilçimen, E.A. Yildirim, <strong>An alternative polynomial-sized formulation and an optimization based heuristic for the reviewer assignment problem</strong>, European Journal of Operational Research. (2019) <a href="https://doi.org/10.1016/j.ejor.2019.01.035">10.1016/j.ejor.2019.01.035</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-29. </div>
    <div class="info">Tags: algorithm, matching.</div>

</div>]]></description>
    <pubDate>Tue, 29 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-01-29-reviewer-assignment.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>

    </channel>
</rss>
