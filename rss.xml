<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>The Art Gallery Guardian</title>
        <link>https://chaoxuprime.com/blog</link>
        <description><![CDATA[Mostly notes on algorithms]]></description>
        <atom:link href="https://chaoxuprime.com/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 21 Jan 2019 00:00:00 UT</lastBuildDate>
        <item>
    <title>The high-degree low-degree technique and arboricity</title>
    <link>https://chaoxuprime.com/blog/posts/2019-01-21-high-degree-low-degree-technique.html</link>
    <description><![CDATA[<br />
<div>
<p>In this piece we demonstrate the high-degree low-degree technique in graphs. Often, we obtain running times that depends on the individual degrees of the vertices. If the graph has only low degree vertices, then a faster algorithm exists. For graph with only large degrees, then it is dense, and can often be handled in another way.</p>
<p>We will also use the information of <a href="https://en.wikipedia.org/wiki/Arboricity">arboricity</a>. Mainly, there are a few useful statements.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>For a graph <span class="math inline">G=(V,E)</span> with arboricity <span class="math inline">\alpha</span>, we have <span class="math display">\displaystyle 
    \sum_{uv\in E} \min(\deg(u),\deg(v)) \leq 2\alpha m
</span></p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>If the arboricity of a graph is <span class="math inline">\alpha</span>, then there exists a induced subgraph with minimum degree at least <span class="math inline">\alpha</span>.</p>
</section>
<p>Often, using the arboricity, we can obtain the same complexity algorithm without high-degree low-degree technique. Note the arboricity is <span class="math inline">O(\sqrt{m})</span>. The application of arboricity are from <span class="citation" data-cites="ChibaN85">[<span class="citeproc-not-found" data-reference-id="ChibaN85"><strong>???</strong></span>]</span>.</p>
<p>Some of the algorithms described can be speedup by using matrix multiplication, or faster combinatorial boolean matrix multiplication. We avoid them for simplicity of exposition.</p>
<h1 id="dominating-set-with-few-edges"><span class="header-section-number">1</span> Dominating set with few edges</h1>
<p>The set cover problem, given <span class="math inline">\mathcal{S} = \set{S_1,\ldots,S_n}</span> are <span class="math inline">n</span> set contains a total of <span class="math inline">m</span> elements. <span class="math inline">U=\bigcup_{S\in \mathcal{S}} S</span> is the universe, with size <span class="math inline">u</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>There is a probability distribution <span class="math inline">D</span> over <span class="math inline">\mathcal{S}</span>, such that for each <span class="math inline">u</span>, the probability a random set <span class="math inline">S</span> covers <span class="math inline">u</span> is at least <span class="math inline">\e</span>. There exists a set cover of <span class="math inline">\ceil{\frac{\log u}{\e}}</span>.</p>
</section>
<h6 id="section-3" type="Proof" index="" name=""><span class="header-section-number">1.0.0.0.0.1</span> </h6>
<p>There exists a set that covers at least <span class="math inline">\e |U&#39;|</span> for any <span class="math inline">U&#39; \subset U</span>. Therefore each greedy iteration decrease the size of uncovered universe by an <span class="math inline">\e</span> fraction. So there can be at most <span class="math inline">t</span> iterations, where <span class="math inline">(1-\e)^t&lt;1</span>. One can show <span class="math inline">\ceil{\frac{\log u}{\e}}</span> suffices.</p>
<section class="theorem-environment Theorem" id="Theorem-4">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">4</span></span>
<p>There is a dominating set incident to <span class="math inline">O(n\sqrt{n\log n})</span> edges.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Fix a <span class="math inline">\delta</span>. We repeatedly removing vertices with degree no more than <span class="math inline">\delta</span> from the graph, and add it into a set <span class="math inline">D</span>. The total degree of <span class="math inline">D</span> is at most <span class="math inline">n\delta</span>. Now the remaining vertices has degree at least <span class="math inline">\delta</span>. Using the set cover theorem, and let the distribution to be the uniform distribution. If all elements are covered at least by <span class="math inline">\e</span> fraction of the set, then we obtain a set cover of size <span class="math inline">O(\frac{\log u}{\e})</span>. Now, let the sets <span class="math inline">N(v)</span> for each <span class="math inline">v</span>. Since degree is bounded by at most <span class="math inline">n</span>, we can obtain a dominating set of size <span class="math inline">O(\frac{n\log n}{e})</span>. We set <span class="math inline">\e=\delta/n</span>. Since the degree of each vertex is at least <span class="math inline">\delta</span>, then there is a covering of <span class="math inline">O(\frac{n^2\log n}{\delta})</span>. Add the vertices induces this set cover to <span class="math inline">D</span>. <span class="math inline">D</span> is a dominating set, and its size is <span class="math inline">O(n\delta +\frac{n^2\log n}{\delta})</span>, set <span class="math inline">\delta=\sqrt{n\log n}</span> and we obtain the desired result.</p>
</section>
<p>One can show the above result is almost optimal, as there exists graphs where every dominating set incidents <span class="math inline">\Omega(n^{3/2})</span> edges. The same bound holds for weakly connected dominating set, that is a dominating set <span class="math inline">D</span> such that the edges incident to <span class="math inline">D</span> forms a connected graph. The stronger modification of this result was used in deciding the <span class="math inline">4</span>-connectivity of a matroid <span class="citation" data-cites="Rajan87">[<a href="#ref-Rajan87">1</a>]</span>.</p>
<h1 id="finding-small-subgraphs"><span class="header-section-number">2</span> Finding small subgraphs</h1>
<h2 id="finding-a-triangle"><span class="header-section-number">2.1</span> Finding a triangle</h2>
<p>A <em>triangle</em> is <span class="math inline">3</span> vertices pairwise adjacent to each other, another name for <span class="math inline">K_3</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-5">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">5</span></span>
<p>There is a <span class="math inline">O(m\Delta)</span> time algorithm to decide if the graph has a triangle, where <span class="math inline">\Delta</span> is the maximum degree.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Indeed, for each vertex <span class="math inline">v</span>, we consider its neighbors, see if any is adjacent to each other. We then delete <span class="math inline">v</span>. The algorithm takes <span class="math inline">O(\sum_{v} \deg^2(v)) = O(m\Delta)</span> time.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-6">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">6</span></span>
<p>There is a <span class="math inline">O(n^3)</span> time algorithm to decide if the graph has a triangle.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>The naive algorithm, for each <span class="math inline">3</span> vertices, we decide if it forms a triangle.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-7">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p>There is a <span class="math inline">O(m^{3/2})</span> time algorithm to decide if the graph has a triangle.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">t</span> be a parameter we will find later. Apply the above algorithm by picking the vertex with the smallest degree, until the next vertex has degree at least <span class="math inline">t</span>. It will use at most <span class="math inline">O(mt)</span> time. Now, for the remaining graph, it is clear the maximum degree is at least <span class="math inline">t</span>. Note, there can be at most <span class="math inline">n/t</span> vertices. We use the <span class="math inline">O(n^3)</span> time algorithm. The final running time is <span class="math inline">O(mt+(m/t)^3)</span>. Set <span class="math inline">t=\sqrt{m}</span> and we are done.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span><span class="name">Alternative</span></span>
<p>We modify the algorithm a little. For each vertex <span class="math inline">v</span>, we consider its neighbor <span class="math inline">u</span>, and check if <span class="math inline">u</span> has a neighbor that is in <span class="math inline">v</span>. Then we delete <span class="math inline">v</span>, and move on to next vertex. The running time become <span class="math inline">\sum_{v\in V} (\deg(v)+\sum_{u\in N(v)} \deg(u))</span>. Now, assume we pick vertices by the <em>largest</em> to <em>smallest</em> in term of degrees. We rearrange the sum and obtain <span class="math inline">\sum_{v\in V} (\deg(v)+\sum_{u\in N(v)} \deg(u)) = \sum_{v\in V} \deg(v) + 2 \sum_{uv\in E} \min(\deg(u),\deg(v)) = O(\alpha m)</span>. But <span class="math inline">\alpha\leq \sqrt{m}</span>, therefore we have the running time <span class="math inline">O(m^{3/2})</span>.</p>
</section>
<h2 id="finding-a-k_2ell-in-bipartite-graphs"><span class="header-section-number">2.2</span> Finding a <span class="math inline">K_{2,\ell}</span> in bipartite graphs</h2>
<p>This section we use technique that follows from <span class="citation" data-cites="AlonYZ97">[<a href="#ref-AlonYZ97">2</a>]</span>, which solved the special case <span class="math inline">K_{2,2}</span>. For two vertices <span class="math inline">u,v\in A</span>, decide if there is a intersection of the neighborhood of size at least <span class="math inline">\ell</span>. The claim is using the same argument as the triangle case with arboricity. Of course one need to be careful with designing the algorithm. However, the following would not be difficult to obtain.</p>
<section class="theorem-environment Theorem" id="Theorem-8">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">8</span></span>
<p>One can check if there exists a <span class="math inline">K_{2,\ell}</span> in the bipartite graph <span class="math inline">G=(A,B,E)</span> in <span class="math inline">O(\alpha m)</span> time.</p>
</section>
<p>Again, we directly obtain <span class="math inline">O(m^{3/2})</span> running time. However, we show something better using stronger theorems.</p>
<section class="theorem-environment Theorem" id="Theorem-9">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">9</span></span>
<p>One can check if there exists a <span class="math inline">K_{2,\ell}</span> in the bipartite graph <span class="math inline">G=(A,B,E)</span> in <span class="math inline">O(\ell n^2)</span> time.</p>
</section>
<p>Now, we combine the two algorithms. It requires a theorem in extremal graph theory can be found in <span class="citation" data-cites="Furedi96">[<a href="#ref-Furedi96">3</a>]</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-10">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">10</span><span class="name"><span class="math inline">K_{2,\ell}</span>-free theorem</span></span>
<p>There exists a constant <span class="math inline">c</span>, such that each <span class="math inline">n</span> vertex graph with <span class="math inline">c n^{3/2} \ell^{1/2}</span> edges contains a <span class="math inline">K_{2,\ell}</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-11">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">11</span></span>
<p>There is a <span class="math inline">O(\ell^{1/3}m^{4/3})</span> time algorithm to find a <span class="math inline">K_{2,\ell}</span> in the graph.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>If the arboricity is <span class="math inline">t</span>. We use the first algorithm and we get running time <span class="math inline">O(t m)</span>. Otherwise, we know there is a subgraph with minimum degree at least <span class="math inline">t</span>. The subgraph can be found by repeatedly deleting vertices of minimum degree. The subgraph <span class="math inline">G&#39;</span> with the previous property has <span class="math inline">n&#39;\leq n</span> vertices and <span class="math inline">m&#39;\leq n&#39;t</span> edges. One can see <span class="math inline">n&#39;\leq m&#39;/t\leq m/t</span>. If <span class="math inline">cn&#39;^{3/2}\ell^{1/2}\leq m&#39; \leq n&#39;t</span>, then we know there exists a <span class="math inline">K_{2,\ell}</span> in <span class="math inline">G&#39;</span> by the previous theorem, and we can apply the <span class="math inline">O(\ell n^2)</span> time algorithm in the subgraph to find the <span class="math inline">K_{2,\ell}</span>. The total running time is therefore <span class="math inline">O(tm + \ell n&#39;^2) = O(tm+\ell (m/t)^2)</span>. We set <span class="math inline">t=c^{3/2} (\ell m)^{1/3}</span>. One can check after lot of algebra, it make sure the condition <span class="math inline">cn&#39;^{3/2}\ell^{1/2}\leq n&#39;t</span> is satisfied. The algorithm takes <span class="math inline">O(\ell^{1/3}m^{4/3})</span> time.</p>
</section>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Rajan87">
<p>[1] A. Rajan, Algorithmic applications of connectivity and related topics in matroid theory, PhD thesis, Northwestern University, 1987.</p>
</div>
<div id="ref-AlonYZ97">
<p>[2] N. Alon, R. Yuster, U. Zwick, <strong>Finding and counting given length cycles</strong>, Algorithmica. 17 (1997) 209–223 <a href="https://doi.org/10.1007/BF02523189">10.1007/BF02523189</a>.</p>
</div>
<div id="ref-Furedi96">
<p>[3] Z. Füredi, <strong>New asymptotics for bipartite turán numbers</strong>, Journal of Combinatorial Theory, Series A. 75 (1996) 141–144 <a href="https://doi.org/https://doi.org/10.1006/jcta.1996.0067">https://doi.org/10.1006/jcta.1996.0067</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-21. </div>
    <div class="info">Tags: algorithm, graph.</div>

</div>]]></description>
    <pubDate>Mon, 21 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2019-01-21-high-degree-low-degree-technique.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Lights out game on a grid</title>
    <link>https://chaoxuprime.com/blog/posts/2019-01-12-lights-out-game.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Let <span class="math inline">G</span> be a graph, let <span class="math inline">A</span> be the adjacency matrix of <span class="math inline">G</span>. Solve the equation <span class="math inline">Ax=b</span> in <span class="math inline">\F_2</span>.</p>
</section>
<p>The problem is equivalent to the <a href="https://en.wikipedia.org/wiki/Lights_Out_%28game%29">lights out game</a>. Each vertex has state <span class="math inline">0</span> or <span class="math inline">1</span>. Activate a vertex flips the state of itself and all its neighbors. Find a set of activations that turns all state into <span class="math inline">0</span>. Originally I thought this problem can be solved in <span class="math inline">O(n^{\omega/2})</span> when <span class="math inline">G</span> is planar graph on <span class="math inline">n</span> vertices by <a href="https://en.wikipedia.org/wiki/Nested_dissection">nested dissection</a>. However, only recently I found out the matrix must be non-singular. Therefore nested dissection does not apply.</p>
<p>Recently I saw an algorithm that shows if the graph is a <span class="math inline">n\times n</span> grid, then it can be solved in <span class="math inline">O(n^3)</span> time. The solution in Chinese and can be seen <a href="https://zhuanlan.zhihu.com/p/53646257">here</a>.</p>
<p>Given a <span class="math inline">n\times n</span> grid graph. Let <span class="math inline">v_{i,j}</span> be the node on the <span class="math inline">i</span>th row and <span class="math inline">j</span>th column. Let <span class="math inline">b_{i,j}</span> be the state of the vertex <span class="math inline">v_{i,j}</span>. The state is in <span class="math inline">\F_2</span> If we activates a node, the state of the node and its neighbors change by <span class="math inline">1</span>. The set of activated node is called the activation set.</p>
<p>We are interested in finding an activation set <span class="math inline">S</span>, such the state of all nodes after activate <span class="math inline">S</span> is <span class="math inline">0</span>.</p>
<p>Let <span class="math inline">S</span> be the activation set, and <span class="math inline">S_1</span> to be the activation set of the first row.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p><span class="math inline">S_1</span> uniquely determines <span class="math inline">S</span>. Moreover, One can compute <span class="math inline">S</span> from <span class="math inline">S_1</span> in <span class="math inline">O(n^2)</span> time.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Indeed, consider apply activation to the nodes in <span class="math inline">S_1</span>. Consider any vertex in row <span class="math inline">1</span>. If it <span class="math inline">0</span>, then the remaining neighbor (on the second row) cannot be activated. If it is <span class="math inline">1</span>, then the remaining neighbor has to be activated.</p>
</section>
<p>Let <span class="math inline">D[i,j]</span> indicates if we activate <span class="math inline">v_{i,j}</span> or not. We create formal variables <span class="math inline">Z=\set{z_1,\ldots,z_n}</span>. Here <span class="math inline">z_i</span> is an indicator variable that represents if <span class="math inline">v_{1,i}</span> is activated or not. The base case <span class="math inline">D[1,j] = z_j</span>. The observation shows that for each <span class="math inline">i</span> and <span class="math inline">j</span>, <span class="math inline">D[i+1,j] = 1 + D[i,j-1]+D[i,j]+D[i,j+1]+D[i-1,j]+b_{i,j}</span>. We can express <span class="math inline">D[i,j]</span> as a sum of elements in <span class="math inline">Z</span> and a constant, and we are summing a constant number of previous states. So it has size <span class="math inline">O(n)</span>. We can compute the expression of <span class="math inline">D[i,j]</span> in <span class="math inline">O(n)</span> time. So computing all <span class="math inline">D[i,j]</span> for <span class="math inline">i\geq 2</span> takes <span class="math inline">O(n^3)</span> time.</p>
<p>We are interested in <span class="math inline">D[n,1],\ldots,D[n,n]</span>. We can see it is of the following form.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
D[n,1] &amp;= c_{1,1} z_1+\ldots +c_{1,n} z_{n} + u_{1}\\
D[n,2] &amp;= c_{2,1} z_1+\ldots +c_{2,n} z_{n} + u_{2}\\
 \vdots &amp;\qquad  \vdots\\
D[n,n] &amp;= c_{m,1} z_1+\ldots + c_{m,n} z_n + u_{n}
\end{aligned}
</span></p>
<p>We solve the equation <span class="math inline">Cz=u</span>. Note here <span class="math inline">C</span> is just a <span class="math inline">n\times n</span> matrix. We finds <span class="math inline">z_1,\ldots,z_n</span>. So now we have found the activation set restricted on the first row. We can use it to find the entire activation set.</p>
<p>The total running time is <span class="math inline">O(n^3)</span>. Building the table <span class="math inline">D</span> and solving <span class="math inline">Cz=u</span>. One can generalize this a bit further. We can obtain <span class="math inline">O(m^2n)</span> running time for a <span class="math inline">m\times n</span> grid, where <span class="math inline">m\leq n</span>. Also, there is no reason we have to work in <span class="math inline">\F_2</span>, any arbitrary field is fine.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>Let <span class="math inline">G</span> be a <span class="math inline">m\times n</span> grid and <span class="math inline">A</span> is a matrix where the non-zero entires are precisely the position of <span class="math inline">1</span>s in the adjacency matrix of <span class="math inline">A</span>. Finding <span class="math inline">Ax=b</span> can be done in <span class="math inline">O(m^2n)</span> time.</p>
</section>
<p>I did not think too much into it, but maybe it works for all integral domains too. Interestingly, this algorithm is so special, that we have no idea how to extend it to other graphs. Maybe it works for directed graph, maybe it works for subgraph of the grid graphs.</p>
<p>It would be really interesting to see an algorithm with running time <span class="math inline">O(n^{3/2})</span> for a planar graph of <span class="math inline">n</span> vertices.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-12. </div>
    <div class="info">Tags: algorithm, algebra.</div>

</div>]]></description>
    <pubDate>Sat, 12 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2019-01-12-lights-out-game.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Strings with hamming distance exactly <span class="math inline">1</span></title>
    <link>https://chaoxuprime.com/blog/posts/2018-12-23-strings-with-hamming-distance-exactly-1.html</link>
    <description><![CDATA[<br />
<div>
<p><a href="http://darktef.github.io/">Lin Yang</a> asked me about the complexity for the following problem, which is the day 2 part 2 of the <a href="https://adventofcode.com/2018">advent of code 2018</a>. It is an elegant programming exercise, and also a clever algorithmic exercise. The problem can be summarized below.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a set <span class="math inline">W</span> of <span class="math inline">n</span> length <span class="math inline">m</span> strings. Decide if there are two of them that differs at exactly one position.</p>
</section>
<p>In other words, we want to find two strings in <span class="math inline">W</span> with <a href="https://en.wikipedia.org/wiki/Hamming_distance">hamming distance</a> <span class="math inline">1</span>.</p>
<p>The naive algorithm would have running time <span class="math inline">O(n^2m)</span>. The complexity of the problem have gathered a lot of attention a while ago, for example a <a href="https://dev.to/conectado/advent-of-code-day-2-part-2-complexity-556l">post in dev.to</a>, and <a href="https://www.reddit.com/r/adventofcode/comments/a2damm/2018_day2_part_2_a_linear_time_solution/">on reddit</a>. Some of them had a running time of <span class="math inline">O(nm^2)</span> instead. Some require hashing to get the <em>expected</em> running time of <span class="math inline">O(mn)</span>. Here we are interested in an algorithm with <em>worst case</em> <span class="math inline">O(mn)</span> time.</p>
<h1 id="an-omn-time-algorithm"><span class="header-section-number">1</span> An <span class="math inline">O(mn)</span> time algorithm</h1>
<p>First, we define some equivalent classes on the strings in <span class="math inline">W</span>.</p>
<ol type="1">
<li><span class="math inline">x\equiv^i y</span>, if <span class="math inline">x[1..i-1]=y[1..i-1]</span>. Namely, if the first <span class="math inline">i-1</span> elements of <span class="math inline">x</span> and <span class="math inline">y</span> match.</li>
<li><span class="math inline">x\equiv_i y</span> if <span class="math inline">x[i+1..m]=y[i+1..m]</span>. Namely, if the last <span class="math inline">m-i+1</span> elements of <span class="math inline">x</span> and <span class="math inline">y</span> match.</li>
</ol>
<p>The algorithm uses the following idea. For each <span class="math inline">i</span>, decide if there are any strings <span class="math inline">x</span> and <span class="math inline">y</span> such that differs in precisely position <span class="math inline">i</span>.</p>
<section class="theorem-environment Lemma" id="Lemma-2">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">2</span></span>
<p>For distinct <span class="math inline">x</span> and <span class="math inline">y</span>, they differ only in position <span class="math inline">i</span> if and only if <span class="math inline">x\equiv^i y</span> and <span class="math inline">x\equiv_i y</span>.</p>
</section>
<p>Let <span class="math inline">\mathcal{P}_i</span> and <span class="math inline">\mathcal{S}_i</span> be the collection of equivalent classes of <span class="math inline">\equiv^i</span> and <span class="math inline">\equiv_i</span>, respectively. We show a result related to the meet of partitions.</p>
<section class="theorem-environment Lemma" id="Lemma-3">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">3</span></span>
<p>Let <span class="math inline">\mathcal{A}</span> and <span class="math inline">\mathcal{B}</span> be partitions of <span class="math inline">[n]</span>. There is an <span class="math inline">O(n)</span> time algorithm to test find the sets in <span class="math inline">\set{ A\cap B | A\in \mathcal{A}, B\in \mathcal{B}}</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">\mathcal{A}=\set{A_1,\ldots,A_k}</span> and <span class="math inline">\mathcal{B} = \set{B_1,\ldots,B_\ell}</span>. We define <span class="math inline">I_i = (a,b)</span> such that <span class="math inline">i\in A_a</span> and <span class="math inline">i\in B_b</span>. Then we know <span class="math inline">i</span> is in <span class="math inline">A_a\cap B_b</span> if <span class="math inline">I_i=(a,b)</span>. Hence we are interested in find the largest set of elements such <span class="math inline">S</span> such that for <span class="math inline">i,j\in S</span>, <span class="math inline">I_i=I_j</span>. The simplified problem can be solved in <span class="math inline">O(n)</span> time. Indeed, the pair is just a base <span class="math inline">n</span> number with <span class="math inline">2</span> digits. We can apply radix sort with running time <span class="math inline">O(n)</span> and group by the result.</p>
</section>
<p>Note one can also directly use a <a href="https://en.wikipedia.org/wiki/Partition_refinement">partition refinement data structure</a> to get the same result.</p>
<p>As a corollary, consider <span class="math inline">\mathcal{A}=\mathcal{P}_i</span> and <span class="math inline">\mathcal{B}=\mathcal{S}_i</span>, then we obtain the following lemma.</p>
<section class="theorem-environment Lemma" id="Lemma-4">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">4</span></span>
<p>Given the collections <span class="math inline">\mathcal{P}_i</span> and <span class="math inline">\mathcal{S}_i</span>, there is an <span class="math inline">O(n)</span> time algorithm to test if there are two strings <span class="math inline">x,y\in W</span> that differs in precisely position <span class="math inline">i</span>.</p>
</section>
<section class="theorem-environment Lemma" id="Lemma-5">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">5</span></span>
<p>Finding <span class="math inline">\mathcal{P}_1,\ldots,\mathcal{P}_m</span> and <span class="math inline">\mathcal{S}_1,\ldots,\mathcal{S}_m</span> can be done in <span class="math inline">O(mn)</span> time.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>To find the equivalent classes, build two tries for the strings. Trie <span class="math inline">T_\mathcal{P}</span> for strings in <span class="math inline">W</span> and trie <span class="math inline">T_\mathcal{S}</span> for the reversal of strings in <span class="math inline">W</span>. Building the tries takes <span class="math inline">O(mn)</span> time. Inspect the nodes at depth <span class="math inline">i-1</span> in <span class="math inline">T_P</span> and nodes at depth <span class="math inline">m-i+1</span> in <span class="math inline">T_S</span> to recover <span class="math inline">\mathcal{P}_i</span> and <span class="math inline">\mathcal{S}_i</span> in <span class="math inline">O(n)</span> time.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-6">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">6</span></span>
<p>There is an <span class="math inline">O(mn)</span> time algorithm that solves <a href="#Problem-1">Problem 1</a>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Finding the sequence of equivalent classes takes <span class="math inline">O(mn)</span> time by <a href="#Lemma-4">Lemma 4</a>. For each <span class="math inline">i</span>, checking if there exists <span class="math inline">x,y\in W</span> differs in precisely position <span class="math inline">i</span> takes <span class="math inline">O(n)</span> time by <a href="#Lemma-3">Lemma 3</a>. Since <span class="math inline">i</span> ranges from <span class="math inline">1</span> to <span class="math inline">m</span>, we obtain the final running time is <span class="math inline">O(mn)</span>.</p>
</section>
<h1 id="remarks"><span class="header-section-number">2</span> Remarks</h1>
<p><a href="https://dblp.uni-trier.de/pers/hd/w/Wang:Ruosong">Ruosong Wang</a> communicated another <span class="math inline">O(mn)</span> solution. It is much easier to describe. Let <span class="math inline">\diamond</span> be a symbol not in the alphabet. Build a <a href="https://en.wikipedia.org/wiki/Generalized_suffix_tree">generalized suffix tree</a> over the set of strings <span class="math inline">S&#39;=\set{x\diamond x| x\in W}</span>. Traverse the suffix tree, up to level <span class="math inline">m</span>, and output <code>true</code> if a path that contains <span class="math inline">\diamond</span> was traversed, and can lead to more than <span class="math inline">2</span> leaves. Indeed, this means the substring <span class="math inline">x\diamond y</span> appears at least twice. Hence there are at least two strings of the form <span class="math inline">yax</span> and <span class="math inline">ybx</span> in <span class="math inline">W</span>. This definitely hits the optimal running time, but implementing a generalized suffix tree is fairly hard.</p>
<p>We do assume the alphabet size is constant. If the alphabet size is <span class="math inline">\sigma</span> and ordered, then there is an extra factor of <span class="math inline">\log \sigma</span> in building the tries. The the final running time will be <span class="math inline">O(mn\log \sigma)</span>.</p>
<p><a href="#Problem-1">Problem 1</a> also reduces to finding the closest pair of elements by hamming metric <span class="citation" data-cites="MinKZ09">[<a href="#ref-MinKZ09">1</a>]</span>. It does not get us the desired running time though.</p>
<h1 id="an-implementation-in-haskell"><span class="header-section-number">3</span> An implementation in Haskell</h1>
<p>The implementation is mostly faithful to the presentation in the article. We did not implement counting sort nor radix sort.</p>
<script src="https://gist.github.com/chaoxu/a4a60408a069edf3889e8328e685f700.js"></script>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-MinKZ09">
<p>[1] K. Min, M.-Y. Kao, H. Zhu, The closest pair problem under the hamming metric, in: H.Q. Ngo (Ed.), Computing and Combinatorics, Springer Berlin Heidelberg, Berlin, Heidelberg, 2009: pp. 205–214.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2018-12-23. </div>
    <div class="info">Tags: algorithms, strings, tries.</div>

</div>]]></description>
    <pubDate>Sun, 23 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2018-12-23-strings-with-hamming-distance-exactly-1.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Subset sum through balancing</title>
    <link>https://chaoxuprime.com/blog/posts/2018-12-18-subset-sum-through-balancing.html</link>
    <description><![CDATA[<br />
<div>
<p>This is a note for Pisinger's balancing algorithm for subset sum <span class="citation" data-cites="Pisinger19991">[<a href="#ref-Pisinger19991">1</a>]</span>. Let <span class="math inline">\mathcal{S}</span> be the set of all subset sums of <span class="math inline">S</span>. The subset sum problem, the input is <span class="math inline">S\subset \N</span>, and we are interested in checking if <span class="math inline">t\in \mathcal{S}</span>.</p>
<p>We define a variation of the subset sum problem. The <em>balanced subset sum problem</em>. In this problem, we are given a vector <span class="math inline">v</span> of integers(does not have to be positive). We let <span class="math inline">M=\|v\|_\infty</span>. We are interested in find a subset that sums to <span class="math inline">t\in [M]</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>Each subset sum problem on <span class="math inline">n</span> elements can be reduced to a balanced subset sum problem in <span class="math inline">n</span> elements in <span class="math inline">O(n)</span> time.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Consider the input to the subset sum problem <span class="math inline">S</span> and <span class="math inline">t</span>. Greedily find a subset of elements <span class="math inline">S&#39;</span>, such that adding any other element will exceed <span class="math inline">t</span>. Let <span class="math inline">\|S&#39;\|_1=t&#39;</span>. Now, we negate all the elements in <span class="math inline">S&#39;</span>, and ask for balanced subset sum with input set <span class="math inline">-S&#39; \cup (S\setminus S&#39;)</span> and target number <span class="math inline">t-t&#39;</span>.</p>
</section>
<p>We partition <span class="math inline">S</span> into <span class="math inline">A = [-M..0]\cap S</span> and <span class="math inline">B=S\setminus A</span>. We also define <span class="math inline">A_i = \set{a_1,\ldots,a_i}</span> and <span class="math inline">B_i=\set{b_1,\ldots,b_i}</span>.</p>
<p>A set is balanced by the following recursive definition. Let <span class="math inline">S</span> be a set.</p>
<ul>
<li><span class="math inline">S=\emptyset</span> is balanced.</li>
<li><span class="math inline">\|S\|_1&gt; t</span>, then <span class="math inline">S\cup \set{a}</span> is balanced, where <span class="math inline">a\in A</span>.</li>
<li><span class="math inline">\|S\|_1\leq t</span>, then <span class="math inline">S\cup \set{b}</span> is balanced, where <span class="math inline">b\in B</span>.</li>
</ul>
<p>Consider a set <span class="math inline">T</span>, such that <span class="math inline">(i,j,k)\in T</span> if and only if <span class="math inline">k</span> is a subset sum of <span class="math inline">A_i\cup B_j</span>. Certainly, we are interested if <span class="math inline">(|A|,|B|,t)</span> is in <span class="math inline">T</span>. However, the state space is already <span class="math inline">O(n^2M)</span>, which is no better than the standard dynamic programming algorithm.</p>
<p>There is a nice dominance relation. If <span class="math inline">(i,j,k)\in T</span>, then for <span class="math inline">(i&#39;,j&#39;)\geq (i,j)</span>, we have <span class="math inline">(i&#39;,j&#39;,k)\in T</span>. We can ask for each <span class="math inline">k</span>, what are all the minimal <span class="math inline">(i,j)</span> pairs where <span class="math inline">(i,j,k)\in T</span>. Such value will be <span class="math inline">g(j,k)</span>. Formally, <span class="math inline">g(j,k) = \min \set{i | (i,j,k)\in T}</span>, one can see that <span class="math inline">g(j,k) \geq g(j+1,k)</span>. Also, we know the solution corresponding to <span class="math inline">g(j,k)</span> must contain <span class="math inline">a_{g(j,k)}</span> as an element.</p>
<p>One can get a recurrence relation for <span class="math inline">g</span> as below.</p>
<p><span class="math display">\displaystyle 
g(j,k)= \min \begin{cases}
g(j-1,k)\\
g(j-1,k-b_j) &amp; \text{if }k-b_j\leq t\\
i &amp; \text{if }k-a_i &gt; t \text{ and } i&gt;g(j,k-a_i)
\end{cases}
</span></p>
<p>Fix a <span class="math inline">k</span> and <span class="math inline">j</span>, let <span class="math inline">i</span> to be as small as possible, such that there is <span class="math inline">A_i&#39;\subset A_i</span> and <span class="math inline">B_j&#39;\subset B_j</span> such that <span class="math inline">A_i&#39;\cup B_j&#39;</span> is balanced and sums to <span class="math inline">k</span>. Note that <span class="math inline">a_i\in A_i&#39;</span>.</p>
<p>We obtained <span class="math inline">A_i&#39;\cup B_j&#39;</span> by inserting an element in <span class="math inline">B</span> or <span class="math inline">A</span> to another balanced set. If the inserted element is in <span class="math inline">B</span>, but not <span class="math inline">b_j</span>, then we know <span class="math inline">i=g(j-1,k)</span>. If it is <span class="math inline">b_j</span>, then <span class="math inline">i=g(j-1,k-b_j)</span>. If the last inserted is <span class="math inline">a_i</span>, then <span class="math inline">g(j,k)=i</span>. Note we observe in this case, <span class="math inline">g(j,k-a_i)&lt;i</span>. A direct dynamic programming implementation seems to imply a <span class="math inline">O(n^2M)</span> time algorithm, since there does not seem to be a quick way to obtain <span class="math inline">i</span>.</p>
<p>On the other hand, if we think bottom up instead of top down, we can obtain a better result. Below is the algorithm.</p>
<figure>
<img src="/files/balanced_subsetsum.png" alt="The algorithm" /><figcaption>The algorithm</figcaption>
</figure>
<p>The value <span class="math inline">D[j,k]</span> eventually equals <span class="math inline">g(j,k)</span>. Note we can argue the running time is <span class="math inline">O(nM)</span>, since for each fixed <span class="math inline">k</span>, the final for loop can ran at most <span class="math inline">n</span> times. It is frustrating that the DP algorithm cannot be inferred directly from the recurrence relation. Indeed, we mainly obtained this through the fact that we can prune the search space if we start bottom up, which is unclear from the recurrence relation.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Pisinger19991">
<p>[1] D. Pisinger, <strong>Linear time algorithms for knapsack problems with bounded weights</strong>, Journal of Algorithms. 33 (1999) 1–14 <a href="https://doi.org/10.1006/jagm.1999.1034">10.1006/jagm.1999.1034</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2018-12-18. </div>
    <div class="info">Tags: algorithms, subset sum.</div>

</div>]]></description>
    <pubDate>Tue, 18 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2018-12-18-subset-sum-through-balancing.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Global min-cut with parity constraint on the edges</title>
    <link>https://chaoxuprime.com/blog/posts/2018-11-06-global-min-cut-with-parity-constraint-on-the-edges.html</link>
    <description><![CDATA[<br />
<div>
<p>In a discussion with <a href="https://patrickl.in/">Patrick Lin</a>, a nice problem was born.</p>
<p>Let <span class="math inline">\delta(S)</span> to be the set of edges with exactly one endpoint in <span class="math inline">S</span>. <span class="math inline">\delta^-(S)</span> to be the set of edges with its head in <span class="math inline">S</span> and tail in <span class="math inline">V\setminus S</span>. Given a non-negative weighted graph, we define the cut function <span class="math inline">f:2^V\to \R^+</span> to be <span class="math inline">f(S) = \sum_{e\in \delta(S)} w(e)</span>. For directed graphs, <span class="math inline">f(S) = \sum_{e\in \delta^-(S)} w(e)</span>. <span class="math inline">f(S)</span> is called the value of the cut <span class="math inline">S</span>.</p>
<p>Let <span class="math inline">k</span> be a constant, we consider the following problem.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Give a graph and <span class="math inline">k</span> set of edges <span class="math inline">F_1,\ldots,F_k</span>, <span class="math inline">a_1,\ldots,a_k,b</span>. Find a cut <span class="math inline">S</span> satisfies that <span class="math inline">|\delta(S)\cap F_i|\equiv a_i \pmod b</span> for all <span class="math inline">i</span>, and the value is minimized.</p>
</section>
<p>We will try to reduce this problem to the following</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span><span class="name">submodular minimization under congruence constraints</span></span>
<p>Given <span class="math inline">T_1,\ldots,T_k</span> and a submodular function <span class="math inline">f</span>. Find a set <span class="math inline">S</span> such that <span class="math inline">|T_i\cap S| \equiv a_i\pmod b_i</span>, and <span class="math inline">f(S)</span> is minimized.</p>
</section>
<p>The above problem is known as submodular minimization under congruence constraints. It is known to be solvable in polynomial time under certain conditions on the <span class="math inline">b_i</span>'s <span class="citation" data-cites="NageleSZ18">[<a href="#ref-NageleSZ18">1</a>]</span>. We sketch the reductions.</p>
<h1 id="undirected-case"><span class="header-section-number">1</span> Undirected case</h1>
<p>In the undirected case, we only consider when <span class="math inline">b=2</span>. Patrick showed a the following construction. Create a new graph <span class="math inline">G&#39;</span> as follows. For each <span class="math inline">uv</span> in <span class="math inline">E</span>, split it into edges <span class="math inline">ux</span>, <span class="math inline">xy</span>, <span class="math inline">yv</span>, <span class="math inline">w(ux)=w(yv)=\infty</span>, and <span class="math inline">w(xy)=w(uv)</span>. Let <span class="math inline">T_i</span> contains the vertex <span class="math inline">x</span> and <span class="math inline">y</span> if <span class="math inline">uv\in F_i</span>.<br />
We now solve the submodular minimization under congruence constraints problem on input <span class="math inline">f</span>, which is the cut function for <span class="math inline">G&#39;</span>, and same <span class="math inline">a_1,\ldots,a_k</span> and <span class="math inline">b_1,\ldots,b_k=2</span>.</p>
<h1 id="directed-case"><span class="header-section-number">2</span> Directed case</h1>
<p>In the directed case, a similar approach works. But now, instead of <span class="math inline">\mod 2</span>, we can do <span class="math inline">\mod b</span> for any <span class="math inline">b</span>. We consider the same approach.<br />
<span class="math inline">(u,v) \in E</span> split into <span class="math inline">(u,x_1),\ldots,(x_b,v)</span> and <span class="math inline">w(u,x_1)=w(u,v)</span>, <span class="math inline">w(x_i,x_{i+1})=\infty</span>, <span class="math inline">w(x_b,v)=\infty</span>. Now, let <span class="math inline">T_i</span> contain vertices <span class="math inline">x_1,\ldots,x_b</span> of <span class="math inline">uv\in F_i</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-NageleSZ18">
<p>[1] M. Nägele, B. Sudakov, R. Zenklusen, Submodular minimization under congruency constraints, in: Proceedings of the Twenty-Ninth Annual Acm-Siam Symposium on Discrete Algorithms, Society for Industrial; Applied Mathematics, Philadelphia, PA, USA, 2018: pp. 849–866.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2018-11-06. </div>
    <div class="info">Tags: algorithms, min-cut.</div>

</div>]]></description>
    <pubDate>Tue, 06 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2018-11-06-global-min-cut-with-parity-constraint-on-the-edges.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Computing the weighted h-index</title>
    <link>https://chaoxuprime.com/blog/posts/2018-02-23-weighted-h-index.html</link>
    <description><![CDATA[<br />
<div>
<p>A common algorithm problem is that given a sequence of numbers, find a h-index. Where h-index is the largest integer <span class="math inline">h</span> such there are at least <span class="math inline">h</span> integers in the sequence is at least as large as <span class="math inline">h</span>.</p>
<p>Formally, we have the following problem.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given <span class="math inline">a_1,\ldots,a_n</span>, find the largest <span class="math inline">h</span>, such that <span class="math inline">|\set{i \mid a_i\geq h}|\geq h</span>.</p>
</section>
<p>The <a href="https://leetcode.com/problems/h-index/description/">h-index problem is featured in leetcode</a>.</p>
<p>If we the numbers are sorted, then a trivial <span class="math inline">O(n)</span> time algorithm exists. If it is not sorted, then note that we can solve the problem on <span class="math inline">\min(a_1,n),\ldots,\min(a_n,n)</span>. In this case, the input numbers is at most <span class="math inline">n</span>, therefore can be sorted in <span class="math inline">O(n)</span> time. Hence the total running time is <span class="math inline">O(n)</span>.</p>
<p>Consider a weighted version of the problem where the above algorithm does not work.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given a sequence of pairs of non-negative positive reals <span class="math inline">(w_1,a_1),\ldots,(w_n,a_n)</span>. Find the largest <span class="math inline">h\in \R</span>, such that <span class="math inline">\sum_{i:a_i\geq h} w_i \geq h</span>.</p>
</section>
<p>An <span class="math inline">O(n)</span> time algorithm still exists. For simplicity, we assume all <span class="math inline">a_i</span>'s are distinct, so the input is a set. The case where <span class="math inline">a_i</span>'s are not distinct is left as an exercise to the reader.</p>
<p>Define <span class="math inline">f(t) = \sum_{i:a_i\geq t} w_i</span>. We want to find the largest <span class="math inline">t</span> such that <span class="math inline">f(t)\geq t</span>. First, we can find the median of <span class="math inline">a_1,\ldots,a_n</span>, say <span class="math inline">t</span>. If <span class="math inline">f(t) &lt; t</span>, then we recurse on <span class="math inline">\set{(w_i-f(t),a_i) \mid a_i&lt; t}</span>. Assume the optimum in the recursed solution is <span class="math inline">t&#39;</span>, we return <span class="math inline">t&#39;+f(t)</span> as the solution. If <span class="math inline">f(t)\geq t</span>, then we recurse and output the solution with input <span class="math inline">\set{(w_i,a_i) \mid a_i\geq t}</span>. The running time satisfies <span class="math inline">T(n)=T(n/2)+O(n)</span>, which is <span class="math inline">O(n)</span>.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2018-02-23. </div>
    <div class="info">Tags: algorithms.</div>

</div>]]></description>
    <pubDate>Fri, 23 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2018-02-23-weighted-h-index.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Small <span class="math inline">L_1</span> norm solution to a linear Diophantine equation</title>
    <link>https://chaoxuprime.com/blog/posts/2017-08-26-solution-to-linear-diophantine.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">a=(a_1,\ldots,a_n)</span> be <span class="math inline">n</span> integers with <span class="math inline">\gcd(a_1,\ldots,a_n)=1</span>. There exists a integral vector <span class="math inline">x=(x_1,\ldots,x_n)</span>, such that <span class="math inline">\sum_{i=1}^n x_ia_i = 1</span>. How large is the solution <span class="math inline">x</span>? By <a href="https://en.wikipedia.org/wiki/Bézout%27s_identity">Bézout's lemma</a>, when <span class="math inline">n=2</span>, we can obtain that <span class="math inline">\|x\|\leq \|a\|</span>. Here <span class="math inline">\|\cdot \|</span> is the <span class="math inline">L_1</span> norm.</p>
<p>However, I could not find a general bound of <span class="math inline">\|x\|</span> anywhere. Here we prove that the bound on <span class="math inline">\|x\|</span> is true in general. Before that, we first introduce a lemma from <span class="citation" data-cites="Ford1996">[<a href="#ref-Ford1996">1</a>]</span>.</p>
<section class="theorem-environment Lemma" id="Lemma-1">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">1</span></span>
<p>Let <span class="math inline">a=(a_1,\ldots,a_n)</span> be a vector of positive integers with at least <span class="math inline">2</span> elements, it does not contain <span class="math inline">1</span> and <span class="math inline">\gcd(a)=1</span>. If <span class="math inline">g_k = \gcd(a_k,\ldots,a_n)</span>, then there exist a solution to <span class="math display">\displaystyle 
\sum_{i=1}^n x_i a_i = 1
</span> such that for all <span class="math inline">1\leq i\leq n-1</span>, <span class="math display">\displaystyle 
|x_i|\leq \frac{g_{i+1}}{2g_i}
</span> and <span class="math inline">|x_n|\leq \frac{\max(a_1,\ldots,a_{n-1})}{2}</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Let <span class="math inline">a</span> be a vector of positive integers such that <span class="math inline">\gcd(a)=1</span>, then there exists a integral solution to <span class="math inline">x \cdot a=1</span> such that <span class="math inline">\|x\|\leq \frac{1}{2}(\min(a)+\max(a))</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">a=(a_1,\ldots,a_n)</span>. Let <span class="math inline">a_n=\min(a)</span>. We can assume <span class="math inline">1</span> is not in <span class="math inline">a</span>, otherwise we can find <span class="math inline">x</span> such that <span class="math inline">\|x\|=1</span>. Let <span class="math inline">g_i = \gcd(a_i,\ldots,a_n)</span>. Hence <span class="math inline">g_n = \min(a)</span>. We consider a solution to <span class="math inline">\sum_{i=1}^n x_ia_i = 1</span> satisfies <a href="#Lemma-1">Lemma 1</a>. Let <span class="math inline">I = \set{i | g_{i+1}\geq 2g_{i}, i\leq n-1}</span> and <span class="math inline">j=\min(I)</span>. One can algebraically check that <span class="math inline">a/b\leq a-b</span> holds if both <span class="math inline">a\geq 2b</span> and <span class="math inline">b\geq 2</span>. In particular, we have <span class="math inline">\frac{g_{i+1}}{g_i} \leq g_{i+1}-g_i</span> for all <span class="math inline">i\in I\setminus \set{j}</span>. <span class="math display">\displaystyle 
\sum_{i\in I} |x_i| \leq \frac{1}{2} \sum_{i\in I} \frac{g_{i+1}}{g_i} \leq \frac{g_{j+1}}{2} + \frac{1}{2} \sum_{i\in I, i\neq j} g_{i+1} - g_i \leq \frac{g_{j+1}}{2} + \frac{1}{2} \sum_{i=j+1}^{n-1} g_{i+1}-g_i = \frac{1}{2}g_n = \frac{\min(a)}{2}.
</span></p>
<p><span class="math display">\displaystyle 
    \|x\| = \sum_{i=1}^n |x_i| = |x_n| + \sum_{i\in I} |x_i| \leq \frac{\min(a)+\max(a)}{2}
</span></p>
</section>
<section class="theorem-environment Corollary" id="Corollary-3">
<span class="theorem-header"><span class="type">Corollary</span><span class="index">3</span></span>
<p>Let <span class="math inline">a</span> be a vector of integers such that <span class="math inline">\gcd(a)=1</span>, then there exists a integral solution to <span class="math inline">x \cdot a=1</span> such that <span class="math inline">\|x\|\leq \|a\|</span>.</p>
</section>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Ford1996">
<p>[1] D. Ford, G. Havas, A new algorithm and refined bounds for extended gcd computation, in: H. Cohen (Ed.), Algorithmic Number Theory: Second International Symposium, Ants-Ii Talence, France, May 18–23, 1996 Proceedings, Springer Berlin Heidelberg, Berlin, Heidelberg, 1996: pp. 145–150 <a href="https://doi.org/10.1007/3-540-61581-4_50">10.1007/3-540-61581-4_50</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2017-08-26. </div>
    <div class="info">Tags: number theory.</div>

</div>]]></description>
    <pubDate>Sat, 26 Aug 2017 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2017-08-26-solution-to-linear-diophantine.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>List the smallest <span class="math inline">k</span> subset sums</title>
    <link>https://chaoxuprime.com/blog/posts/2017-04-20-list-the-smallest-k-subset-sums.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a set of positive reals <span class="math inline">\set{x_1,\ldots,x_n}</span> where <span class="math inline">x_1&lt;x_2&lt;\ldots&lt;x_n</span>, find the smallest <span class="math inline">k</span> subset sums.</p>
</section>
<p>We can assume <span class="math inline">n\leq k</span>, because we do not have to read <span class="math inline">x_j</span> if <span class="math inline">j&gt;k</span>.</p>
<p>Torsten Gross and Nils Blüthgen posted <a href="https://arxiv.org/abs/1704.05795">a <span class="math inline">O(k^2)</span> time solution on arXiv</a>.</p>
<p>We show a <span class="math inline">O(k\log k)</span> time algorithm, which is optimal if we want to output the numbers in order.</p>
<p>We list the sums one by one by maintaining a priority queue of sums. We start with the empty set. Assume that we added the sum induced by <span class="math inline">I\subset [n]</span> (that is, <span class="math inline">\sum_{i\in I} x_i</span>) into the output, let <span class="math inline">j=1+\max I</span>. Now we can consider two possibilities by extending the current solution: the sum induced by <span class="math inline">I\cup \set{j}</span> or the sum induced by <span class="math inline">I\cup \set{k}</span> where <span class="math inline">k&gt;j</span>. We will add both possibilities to the queue so that one can inspect them later. We can avoid storing the sets, only the values are required.</p>
<p>Here is a python implementation.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> first_k_subset_sums(x,k):
    n <span class="op">=</span> <span class="bu">len</span>(x)
    h <span class="op">=</span> []
    output <span class="op">=</span> [<span class="dv">0</span>] <span class="co"># need to account for the empty set</span>
    heapq.heappush(h,(x[<span class="dv">0</span>],<span class="dv">0</span>))
    <span class="cf">while</span> h <span class="kw">and</span> <span class="bu">len</span>(output)<span class="op">&lt;</span>k:
        (u,b) <span class="op">=</span> heapq.heappop(h)
        output.append(u)
        <span class="cf">if</span> b<span class="op">+</span><span class="dv">1</span><span class="op">&lt;</span>n:
            heapq.heappush(h,(u<span class="op">+</span>x[b<span class="op">+</span><span class="dv">1</span>],b<span class="op">+</span><span class="dv">1</span>))
            heapq.heappush(h,((u<span class="op">-</span>x[b])<span class="op">+</span>x[b<span class="op">+</span><span class="dv">1</span>],b<span class="op">+</span><span class="dv">1</span>))
    <span class="cf">return</span> output</code></pre></div>
<p>If we want to output the sets themselves, not just the values, does the running time change? If a set <span class="math inline">I</span> is in the output, then all subsets of <span class="math inline">I</span> must also be in the output. Hence the largest set we can ever output has size <span class="math inline">O(\log k)</span>. Therefore the total output length is at most <span class="math inline">O(k\log k)</span>.</p>
<p>This is also a lower bound. Consider when <span class="math inline">x_i=2^i</span>, then we will output all subsets of <span class="math inline">\set{x_1,\ldots,x_{\log k}}</span>, and we know that <span class="math inline">\sum_{i=1}^{\log k} i{\log k\choose i} = \Omega(\log k)</span>.</p>
<p>If we don't have to list the smallest <span class="math inline">k</span> subset sum values in order, then <span class="math inline">O(k)</span> is possible, see <a href="https://mathoverflow.net/a/222341/6886">this mathoverflow answer</a> by <a href="https://www.ics.uci.edu/~eppstein/">David Eppstein</a>.</p>
<p>If we are interested in the smallest <span class="math inline">k</span> <em>distinct</em> subset sum. I don't know of any algorithm that performs better than <span class="math inline">O(nk)</span>, even if we know that <span class="math inline">n=\Omega(k)</span>.</p>
<h1 id="acknowledgements" class="unnumbered">Acknowledgements</h1>
<p>I would like to thank Tana Wattanawaroon for helpful discussions and taking an interest in this problem.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2017-04-20. </div>
    <div class="info">Tags: algorithm.</div>

</div>]]></description>
    <pubDate>Thu, 20 Apr 2017 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2017-04-20-list-the-smallest-k-subset-sums.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Filling up a bin using balls with divisible weights</title>
    <link>https://chaoxuprime.com/blog/posts/2017-03-09-filling-up-a-bin-using-balls-with-divisible-weight.html</link>
    <description><![CDATA[<br />
<div>
<p>This post shows how to solve the special case for <a href="http://cs.stackexchange.com/questions/12441/is-it-np-hard-to-fill-up-bins-with-minimum-moves">this problem</a>. The special case has exactly one bin, and each ball have weight a power of <span class="math inline">2</span>. It is one of the <a href="http://cs.stackexchange.com/unanswered">most popular unanswered problem on cs.stackexchange</a> as of writing.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>We are interested in solving the following integer program, <span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n |x_i-a_i| \\
\text{subject to:} &amp; \sum_{i=1}^n w_i x_i = c\\
&amp; 0\leq x_i \leq b_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>where each <span class="math inline">w_i</span> is a power of <span class="math inline">2</span> for all <span class="math inline">1\leq i\leq n</span>. Assume <span class="math inline">w_i\leq w_{i+1}</span>.</p>
</section>
<p>In fact, we do not require the <span class="math inline">w_i</span>s are powers of <span class="math inline">2</span>. We can establish polynomial time as long as <span class="math inline">w_{i+1}/w_i</span> is bounded by a polynomial in terms of the input size for all <span class="math inline">i</span>. However, for simplicity of exposition, assume <span class="math inline">w_i</span>s are powers of <span class="math inline">2</span>. We do not know the case when <span class="math inline">w_{i+1}/w_i</span> is unbounded.</p>
<p>Consider a more natural problem without the absolute values.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span><span class="name"><span class="math inline">0</span>-<span class="math inline">1</span> exact knapsack problem with divisible weights</span></span>
<p>We are interested in solving the following integer program, <span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n c_i x_i \\
\text{subject to:} &amp; \sum_{i=1}^n w_i x_i = t\\
&amp; x_i \in \{0,1\} \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>where <span class="math inline">w_i|w_{i+1}</span> for all <span class="math inline">1\leq i\leq n</span>. <span class="math inline">w_i</span> can be negative.</p>
</section>
<p>We show <a href="#Problem-1">Problem 1</a> reduces to <a href="#Problem-2">Problem 2</a> with polynomial blow up, and <a href="#Problem-2">Problem 2</a> can be solved in polynomial time.</p>
<h1 id="reduction"><span class="header-section-number">1</span> Reduction</h1>
<p>The reduction goes through a few steps. We start with the integer program in <a href="#Problem-1">Problem 1</a>, and let <span class="math inline">y_i = a_i-x_i</span>, and we get</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n |y_i| \\
\text{subject to:} &amp; \sum_{i=1}^n w_i y_i = \sum_{i=1}^n w_i a_i - c\\
&amp; a_i-b_i\leq y_i \leq a_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>Let <span class="math inline">c&#39; = \sum_{i=1}^n w_ia_i -c</span>, and <span class="math inline">l_i = a_i-b_i</span> and <span class="math inline">u_i = a_i</span>.</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n |y_i| \\
\text{subject to:} &amp; \sum_{i=1}^n w_i y_i = c&#39;\\
&amp; l_i \leq y_i \leq u_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>Let <span class="math inline">y_i=y_i^+ - y_i^-</span>, where <span class="math inline">y_i^-,y_i^+\geq 0</span>, we can remove the absolute value.</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n y_i^+ + y_i^- \\
\text{subject to:} &amp; \sum_{i=1}^n w_i y_i^+ + \sum_{i=1}^n -w_i y_i^- = c&#39;\\
&amp; l_i \leq y_i^+- y_i^- \leq u_i \text{ for all } 1\leq i \leq n\\
&amp; y_i^-, y_i^+\geq 0 \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>Observe that we can separate the inequalities involving <span class="math inline">y_i^+ - y_i^-</span>, because there is always an optimal where <span class="math inline">y_i^-</span> or <span class="math inline">y_i^+</span> is <span class="math inline">0</span>.</p>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>This observation fails when the number of bins is more than <span class="math inline">1</span>.</p>
</section>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n y_i^+ + y_i^- \\
\text{subject to:} &amp; \sum_{i=1}^n w_i y_i^+ + \sum_{i=1}^n -w_i y_i^- = c&#39;\\
&amp; 0 \leq y_i^+ \leq u_i \text{ for all } 1\leq i \leq n\\
&amp; 0 \leq y_i^- \leq -l_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>This is an integer program as a bounded exact knapsack problem.</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n x_i \\
\text{subject to:} &amp; \sum_{i=1}^n w_i x_i = c\\
&amp; 0 \leq x_i \leq b_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>Finally, apply the standard technique that rewrites a bounded knapsack problem to <span class="math inline">0</span>-<span class="math inline">1</span>-knapsack problem (see Section 7.1.1 of <span class="citation" data-cites="9783540402862">[<a href="#ref-9783540402862">1</a>]</span>). The blow up in problem size is at most a factor of <span class="math inline">O(\log \max_i b_i)</span>. We can get the integer program in <a href="#Problem-2">Problem 2</a>, and also the weights are all powers of <span class="math inline">2</span>. The reduction runs in polynomial time with respect to input size.</p>
<h1 id="solving-problem-2"><span class="header-section-number">2</span> Solving <a href="#Problem-2">Problem 2</a></h1>
<p><a href="http://sevenkplus.com/">Yuzhou Gu</a> noted that the integer program in <a href="#Problem-2">Problem 2</a> has a dynamic programming solution.</p>
<p>Let <span class="math inline">D[m,k]</span> to be the optimal value to the following problem</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{j=1}^m c_j x_j \\
\text{subject to:} &amp; \sum_{j=1}^m w_j x_j = k |w_m| + t \bmod |w_m|\\
&amp; x_j \in \{0,1\} \text{ for all } 1\leq j \leq m\\
\end{aligned}</span></p>
<p>The claim is that <span class="math inline">D[m,k]</span> can be expressed by the following recurrence relation.</p>
<p><span class="math display">\displaystyle 
D[m,k] = \min_{x_m\in \{0,1\}} D\left[m-1,\frac{|w_m|k- w_m x_m+(t\bmod |w_m| - t\bmod |w_{m-1}|)}{|w_{m-1}|}\right]
</span></p>
<p>Note that <span class="math inline">|k|</span> is at most <span class="math inline">m</span>. Therefore the table has at most <span class="math inline">O(n^2)</span> entries. To obtain the solution to the original equation, we find the minimum overall <span class="math inline">D[n, k]</span>. Clearly, this runs in polynomial time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-9783540402862">
<p>[1] H. Kellerer, U. Pferschy, D. Pisinger, <strong>Knapsack problems</strong>, Springer, 2004.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2017-03-09. </div>
    <div class="info">Tags: optimization, integer.</div>

</div>]]></description>
    <pubDate>Thu, 09 Mar 2017 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2017-03-09-filling-up-a-bin-using-balls-with-divisible-weight.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Processor distribution and proportional apportionment</title>
    <link>https://chaoxuprime.com/blog/posts/2016-08-02-proportional-apportionment.html</link>
    <description><![CDATA[<br />
<div>
<p>I saw an interview problem about assigning identical processors to embarrassingly parallel jobs. The running time of a job equals the running time on a single processor divided by the number of processors. We are interested in minimizing the maximum running time. Formally, we get the following problem.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given positive reals <span class="math inline">a_1,\ldots,a_n</span> and positive integer <span class="math inline">k</span>, find non-negative integers <span class="math inline">x_1,\ldots,x_n</span>, such that <span class="math inline">\sum_{i} x_i \leq k</span> and <span class="math inline">\theta = \max_{i} a_i/x_i</span> is minimized.</p>
</section>
<p>If there is no integral requirement on <span class="math inline">x_i</span>'s, then the problem is easy. Let <span class="math inline">A=\sum_{i} a_i</span>. There is a closed solution of <span class="math inline">x_i = k \frac{a_i}{A}</span>, and <span class="math inline">\theta = A / k</span>.</p>
<p>Otherwise, it is easy to check if <span class="math inline">\theta&#39;&gt;0</span> is a feasible solution. <span class="math inline">\theta&#39;</span> is feasible iff <span class="math inline">\sum_{i} \ceil{a_i/\theta&#39;} \leq k</span>. Therefore one can apply binary search, and get the result in <span class="math inline">O(n\log k)</span> time.</p>
<p>One can also get a <span class="math inline">O(n\log n)</span> time algorithm. First compute <span class="math inline">y_i = \ceil{k \frac{a_i}{A}}</span>. Greedily find a <span class="math inline">i</span> such that <span class="math inline">a_i/y_i</span> is maximized, and decrease <span class="math inline">y_i</span> by <span class="math inline">1</span>. We stop when we have <span class="math inline">\sum_{i} y_i=k</span>. This takes <span class="math inline">O(\log n)</span> per operation using a binary search tree.</p>
<p>Linear time algorithm also exists. It is connected to proportional apportionment. This is the problem of finding the smallest <span class="math inline">\lambda</span>, such that <span class="math inline">\sum_{i} \ceil{\lambda a_i} = k</span>. Cheng and Eppstein found a <span class="math inline">O(n)</span> time algorithm <span class="citation" data-cites="Cheng2014">[<a href="#ref-Cheng2014">1</a>]</span>. Reitzig and Wild found a simpler algorithm later <span class="citation" data-cites="Reitzig2017">[<a href="#ref-Reitzig2017">2</a>]</span>.</p>
<p>There is a similar interview problem. Given <span class="math inline">n</span> points on the real line, add <span class="math inline">k</span> more points, such that it minimizes the maximum length between adjacent points. The problem is the same as the following one.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given positive <span class="math inline">a_1,\ldots,a_n</span> and positive integer <span class="math inline">k</span>, find non-negative integers <span class="math inline">x_1,\ldots,x_n</span>, such that <span class="math inline">\sum_{i} x_i \leq k</span> and <span class="math inline">\theta = \max_{i} a_i/(x_i+1)</span> is minimized.</p>
</section>
<p>The linear time algorithm for proportional apportionment should also work for the above problem. It is interesting how much can we change the problem before the linear time algorithm no longer works.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Cheng2014">
<p>[1] Z. Cheng, D. Eppstein, Linear-time algorithms for proportional apportionment, in: H.-K. Ahn, C.-S. Shin (Eds.), Algorithms and Computation: 25th International Symposium, Isaac 2014, Jeonju, Korea, December 15-17, 2014, Proceedings, Springer International Publishing, Cham, 2014: pp. 581–592 <a href="https://doi.org/10.1007/978-3-319-13075-0_46">10.1007/978-3-319-13075-0_46</a>.</p>
</div>
<div id="ref-Reitzig2017">
<p>[2] R. Reitzig, S. Wild, <strong>Building fences straight and high: An optimal algorithm for finding the maximum length you can cut <span class="math inline">k</span> times from given sticks</strong>, Algorithmica. (2017) <a href="https://doi.org/10.1007/s00453-017-0392-3">10.1007/s00453-017-0392-3</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2016-08-02. </div>
    <div class="info">Tags: optimization, integer.</div>

</div>]]></description>
    <pubDate>Tue, 02 Aug 2016 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2016-08-02-proportional-apportionment.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Maximum flow running time depend on longest path</title>
    <link>https://chaoxuprime.com/blog/posts/2016-07-02-max-flow-longest-path.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider a directed graph with specified vertices <span class="math inline">s</span> and <span class="math inline">t</span>. The graph has <span class="math inline">m</span> edges and <span class="math inline">n</span> vertices with length of the longest simple <span class="math inline">st</span>-path to be <span class="math inline">k</span>. Dinic's algorithm finds a maximum flow consists of blocking flow computations, where each takes <span class="math inline">O(m\log n)</span> time with dynamic trees <span class="citation" data-cites="Sleator1983 Dinitz">[<a href="#ref-Sleator1983">1</a>,<a href="#ref-Dinitz">2</a>]</span>. After each blocking flow, the distance between <span class="math inline">s</span> and <span class="math inline">t</span> in the residual graph increases by at least <span class="math inline">1</span>. Therefore there are at most <span class="math inline">k</span> blocking flow computations. Dinic's algorithm takes <span class="math inline">O(km\log n)</span> time to find a maximum <span class="math inline">st</span>-flow.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Sleator1983">
<p>[1] D.D. Sleator, R.E. Tarjan, <strong>A Data Structure for Dynamic Trees</strong>, J. Comput. Syst. Sci. 26 (1983) 362–391 <a href="https://doi.org/10.1016/0022-0000(83)90006-5">10.1016/0022-0000(83)90006-5</a>.</p>
</div>
<div id="ref-Dinitz">
<p>[2] Y. Dinitz, Theoretical computer science, in: O. Goldreich, A.L. Rosenberg, A.L. Selman (Eds.), Springer-Verlag, Berlin, Heidelberg, 2006: pp. 218–240.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2016-07-02. </div>
    <div class="info">Tags: flow.</div>

</div>]]></description>
    <pubDate>Sat, 02 Jul 2016 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2016-07-02-max-flow-longest-path.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Minimum cuts with restrictions</title>
    <link>https://chaoxuprime.com/blog/posts/2016-04-24-restricted-min-cut.html</link>
    <description><![CDATA[<br />
<div>
<p>There is a nice algorithm design technique for cuts: fix a small number of partial solutions, and guess all possible solutions built from the partial solution. Here are two demonstrations.</p>
<h1 id="k-size-cut"><span class="header-section-number">1</span> <span class="math inline">k</span>-size-cut</h1>
<p>A cut <span class="math inline">(X,\bar{X})</span> such that both <span class="math inline">|X|,|\bar{X}|\geq k</span> is called a <span class="math inline">k</span>-size-cut.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a graph <span class="math inline">G</span>, find a minimum <span class="math inline">k</span>-size-cut.</p>
</section>
<p>The standard algorithm is based on finding all possible min-<span class="math inline">ST</span>-cut, where <span class="math inline">S,T</span> are all possible disjoint sets of size <span class="math inline">k</span>. The running time is <span class="math inline">O(n^{2k})</span> min-cut computations.</p>
<p>One can improve it by first fix an arbitrary set of <span class="math inline">k</span> vertices <span class="math inline">Y</span>. Consider a min-<span class="math inline">k</span>-size-cut <span class="math inline">(X,\bar{X})</span>. Let <span class="math inline">S&#39;=X\cap Y</span> and <span class="math inline">T&#39;=\bar{X}\cap Y</span>. We can try to find the min-cut of all possible <span class="math inline">S</span> and <span class="math inline">T</span> such that <span class="math inline">S&#39;\subset S</span>,<span class="math inline">T&#39;\subset T</span> and <span class="math inline">|S|=|T|=k</span>. Since we don't know what <span class="math inline">S&#39;</span> and <span class="math inline">T&#39;</span> are, we will try all <span class="math inline">2^k</span> possibilities. Here the <span class="math inline">S&#39;</span> and <span class="math inline">T&#39;</span> are the partial solutions. This gives us an algorithm with running time <span class="math inline">O(2^k n^k)</span> min-cut computations. The idea is also used in computing matroid connectivity.</p>
<p>A further improvement depending on the fact that there are only <span class="math inline">O(n^{k-1})</span> cuts we try to avoid. We can enumerate all the cuts from smallest to largest, with a delay of a single application of Hao-Orlin algorithm <span class="citation" data-cites="HAO1994424">[<a href="#ref-HAO1994424">1</a>]</span>. The running time of Hao-Orlin algorithm is approximately a single maximum flow. One of the smallest <span class="math inline">{n \choose k-1}+1</span> cuts is the min-<span class="math inline">k</span>-size-cut. The running time is <span class="math inline">O(n^{k-1})</span> Hao-Orlin computation <span class="citation" data-cites="Yeh2009">[<a href="#ref-Yeh2009">2</a>]</span>.</p>
<p>It's interesting to wonder if the running time can be improved, especially for the case where <span class="math inline">k=2</span>. Fix a set <span class="math inline">S=\{s,t\}</span> of size <span class="math inline">2</span>. There are two cases, either the min-<span class="math inline">2</span>-size-cut crosses <span class="math inline">S</span>, then one of the the <span class="math inline">3</span> smallest <span class="math inline">st</span>-cuts is our solution. The other case is <span class="math inline">S</span> is on one side of the min-<span class="math inline">2</span>-size-cut, and we are interested in finding a cut so the side doesn't contain <span class="math inline">S</span> has at least <span class="math inline">2</span> vertices.</p>
<p>This prompt a interesting problem:</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Find the second smallest <span class="math inline">st</span>-cut, if we already have a min-<span class="math inline">st</span>-cut and it's corresponding flow(or some other useful information obtained through a push relabel flow computation).</p>
</section>
<p>Can we solve this in <span class="math inline">O(m)</span> time? What if we also know the min-<span class="math inline">st</span>-cut is induced by <span class="math inline">t</span>?</p>
<h1 id="restricted-cut"><span class="header-section-number">2</span> <span class="math inline">2</span>-restricted-cut</h1>
<p>A problem which appeared as a <a href="http://cstheory.stackexchange.com/questions/29474/finding-a-minimum-directed-cut-that-splits-a-weakly-connected-bipartite-graph-in">question on cstheory</a>.</p>
<section class="theorem-environment Problem" id="Problem-3">
<span class="theorem-header"><span class="type">Problem</span><span class="index">3</span></span>
<p>Given a graph <span class="math inline">G</span>, find the minimum cut under the constraint that each side is connected and has at least <span class="math inline">2</span> vertices. (Assume it exists).</p>
</section>
<p>This is the <span class="math inline">k</span>-restricted edge connectivity problem when <span class="math inline">k=2</span>.</p>
<p><span class="math inline">\lambda_k(G)</span>, the <span class="math inline">k</span>-restricted edge connectivity of <span class="math inline">G</span>, defined as the smallest number of edges such that the removal result exactly <span class="math inline">2</span> connected component, each with at least <span class="math inline">k</span> vertices. The rest of the article describes the algorithm by Esfahanian and Hakimi <span class="citation" data-cites="ESFAHANIAN1988195">[<a href="#ref-ESFAHANIAN1988195">3</a>]</span>.</p>
<p><span class="math inline">\lambda_2(G)</span> can be found in <span class="math inline">O(m^2)</span> flow computations. The idea is to contract any two independent edges <span class="math inline">e</span> and <span class="math inline">e&#39;</span> to <span class="math inline">s</span> and <span class="math inline">t</span>, and then find a <span class="math inline">st</span>-min-cut. The cut will give us the desired partition.</p>
<p>It can be improved with the idea of fixing a partial solution. Consider a single edge <span class="math inline">e</span> that incident to a vertex with lowest degree, contract it to vertex <span class="math inline">s</span>. Pick another edge <span class="math inline">e&#39;</span> that not incident to <span class="math inline">s</span>, we contract it to <span class="math inline">t</span>. The min-cut between <span class="math inline">s</span> and <span class="math inline">t</span> reflects a <span class="math inline">2</span>-restricted cut. If <span class="math inline">e</span> is on one side of the min-<span class="math inline">2</span>-restricted cut, then this algorithm finds it in <span class="math inline">O(m)</span> flow computations by trying all possible <span class="math inline">e&#39;</span>.</p>
<p>Otherwise, <span class="math inline">e</span> is an edge crossing every min-<span class="math inline">2</span>-restricted cut. Let <span class="math inline">e=uv</span> and and wlog <span class="math inline">\deg(u)=\delta</span>, the min degree. We fix another partial solutions where <span class="math inline">u</span> and <span class="math inline">v</span> are on different side of the min-<span class="math inline">2</span>-restricted cut. One can contract any edge incident to <span class="math inline">u</span> and any edge incident to <span class="math inline">v</span> and apply a flow computation. There are at most <span class="math inline">\deg(u) \deg(v)\leq \delta n = O(m)</span> flow computations.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-HAO1994424">
<p>[1] J. Hao, J. Orlin, <strong>A faster algorithm for finding the minimum cut in a directed graph</strong>, Journal of Algorithms. 17 (1994) 424–446 <a href="https://doi.org/10.1006/jagm.1994.1043">10.1006/jagm.1994.1043</a>.</p>
</div>
<div id="ref-Yeh2009">
<p>[2] L.-P. Yeh, B.-F. Wang, H.-H. Su, <strong>Efficient algorithms for the problems of enumerating cuts by non-decreasing weights</strong>, Algorithmica. 56 (2009) 297–312 <a href="https://doi.org/10.1007/s00453-009-9284-5">10.1007/s00453-009-9284-5</a>.</p>
</div>
<div id="ref-ESFAHANIAN1988195">
<p>[3] A.-H. Esfahanian, S. Hakimi, <strong>On computing a conditional edge-connectivity of a graph</strong>, Information Processing Letters. 27 (1988) 195–199 <a href="https://doi.org/10.1016/0020-0190(88)90025-7">10.1016/0020-0190(88)90025-7</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2016-04-24. </div>
    <div class="info">Tags: cut.</div>

</div>]]></description>
    <pubDate>Sun, 24 Apr 2016 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2016-04-24-restricted-min-cut.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Balanced partition for trees</title>
    <link>https://chaoxuprime.com/blog/posts/2016-04-21-tree-balanced-partition.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Let <span class="math inline">T</span> be a tree with non-negative weights on the edges. Partition the vertices so each side have <span class="math inline">n/2</span> vertices and minimize the sum of the weights of the edges crossing the partition.</p>
</section>
<p>This problem can be solved in <span class="math inline">O(n^3)</span> time, and it generalizes to graphs with constant treewidth <span class="citation" data-cites="doi:10.1137/S009753970139567X">[<a href="#ref-doi:10.1137/S009753970139567X">1</a>]</span>.</p>
<p>Here we describe the dynamic programming solution for tree and also show the running time is <span class="math inline">O(n^2)</span>. This is probably the solution in <span class="citation" data-cites="doi:10.1137/S009753970139567X">[<a href="#ref-doi:10.1137/S009753970139567X">1</a>]</span> when the input is a tree, so this might lead to <span class="math inline">O(2^kn^2)</span> time algorithm for graphs with treewidth <span class="math inline">k</span>.</p>
<p>This problem can be reduced to the following problem by arbitrarily root the tree at a leaf, and replace each vertex with degree <span class="math inline">d+1</span> into a binary tree with <span class="math inline">d</span> leaves, and assign weight <span class="math inline">0</span> to the internal nodes (except the root) of the replacing binary tree, and infinite edge weight for the edges connecting internal nodes inside the binary tree.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Let <span class="math inline">T</span> be a rooted binary tree with non-negative weights on the edges, and <span class="math inline">0-1</span> weights on the vertices. Partition the vertices so each side have the same weight and minimize the sum of the weights of the edges crossing the partition.</p>
</section>
<p>Let <span class="math inline">W(v)</span> to be the sum of the vertex weights of the subtree rooted at <span class="math inline">v</span>. Let <span class="math inline">D(v,k)</span> to be the subproblem of minimum cost partition of the the vertices of the tree rooted at <span class="math inline">v</span> into vertices <span class="math inline">(A,B)</span> such that <span class="math inline">v\in A</span> and <span class="math inline">\sum_{a\in A} {w(a)}=k</span>. Assume <span class="math inline">v</span> have two children <span class="math inline">u</span> and <span class="math inline">w</span>. There are 4 cases to consider, depending on which of <span class="math inline">\{u,w\}</span> is on the same side of the partition as <span class="math inline">v</span>.</p>
<p><span class="math display">\displaystyle 
D(v,k) = \min \begin{cases}
\min_{i} D(u,i) + D(w,k-w(v)-i)\\
\min_{i} w(vu) + D(u,W(u)-i) + D(w,k-w(v)-i)\\
\min_{i} w(vw) + D(u,i) + D(w,W(w) - (k-w(v)-i))\\
\min_{i} w(vu) + w(vw) + D(u,W(u)-i) + D(w,W(w)-(k-w(v)-i))\\
\end{cases}
</span></p>
<p>Where <span class="math inline">i</span> taken over all the numbers that make sense. Other cases are similar and simpler. Note that <span class="math inline">D(v,k)</span> for a particular <span class="math inline">k</span> can be computed <span class="math inline">O(k \min\{W(u),W(w)\})</span> time. So computing <span class="math inline">D(v,k)</span> for all <span class="math inline">1\leq k\leq W(v)</span> takes <span class="math inline">O(W(u)W(w))</span> time.</p>
<p>Hence the running time would obey <span class="math inline">T(n) \leq \max_{a+b=n} T(a)+T(b)+O(ab)</span>. One can show <span class="math inline">T(n)=O(n^2)</span> is a solution by induction.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-doi:10.1137/S009753970139567X">
<p>[1] K. Jansen, M. Karpinski, A. Lingas, E. Seidel, <strong>Polynomial time approximation schemes for max-bisection on planar and geometric graphs</strong>, SIAM Journal on Computing. 35 (2005) 110–119 <a href="https://doi.org/10.1137/S009753970139567X">10.1137/S009753970139567X</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2016-04-21. </div>
    <div class="info">Tags: tree, dynamic programming.</div>

</div>]]></description>
    <pubDate>Thu, 21 Apr 2016 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2016-04-21-tree-balanced-partition.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Shortest string distinguishing two regular languages</title>
    <link>https://chaoxuprime.com/blog/posts/2016-03-10-shortest-string-distinguishs-two-regular-languages.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">D_0</span> and <span class="math inline">D_1</span> be two DFAs with <span class="math inline">n</span> and <span class="math inline">m</span> states, such that <span class="math inline">L(D_0)\neq L(D_1)</span>.</p>
<p>There exist a string of length at most <span class="math inline">n+m</span> in the symmetric difference of <span class="math inline">L(D_0)</span> and <span class="math inline">L(D_1)</span>.</p>
<p>We construct the following DFA <span class="math inline">D</span> from <span class="math inline">D_0</span> and <span class="math inline">D_1</span>. The start state <span class="math inline">s</span> has a transition <span class="math inline">\delta(s,0) = s_0</span> and <span class="math inline">\delta(s,1) = s_1</span>, where <span class="math inline">s_0</span> and <span class="math inline">s_1</span> are start state of <span class="math inline">D_0</span> and <span class="math inline">D_1</span>.</p>
<p>Now <span class="math inline">D</span> represents the language <span class="math inline">\set{0w|w \in L(D_0)} \cup \set{1w|w\in L(D_1)}</span>. This language has at most <span class="math inline">n+m+1</span> equivalent classes in Myhill–Nerode theorem. There exist a string of length less than <span class="math inline">n+m+1</span> that differentiate state <span class="math inline">s_0</span> and <span class="math inline">s_1</span>, since <span class="math inline">s_0</span> and <span class="math inline">s_1</span> can't correspond to the same equivalent class.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2016-03-10. </div>
    <div class="info">Tags: DFA.</div>

</div>]]></description>
    <pubDate>Thu, 10 Mar 2016 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2016-03-10-shortest-string-distinguishs-two-regular-languages.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>No nice generalization of Gomory-Hu tree</title>
    <link>https://chaoxuprime.com/blog/posts/2016-02-01-gomory-hu-bad-news.html</link>
    <description><![CDATA[<br />
<div>
<p><a href="https://en.wikipedia.org/wiki/Gomory%E2%80%93Hu_tree">Gomory-Hu tree</a> of a graph <span class="math inline">G</span> is a weighted graph <span class="math inline">H</span> on the same set of vertices. It has the two nice properties.</p>
<ol type="1">
<li>It is a tree.</li>
<li>For every <span class="math inline">s,t</span>, there exist a min-<span class="math inline">st</span>-cut in <span class="math inline">H</span> that is also a min-<span class="math inline">st</span>-cut in <span class="math inline">G</span>.</li>
</ol>
<p>We could ask for a generalization. Given a graph <span class="math inline">G</span>, can we find some <em>nice</em> graph <span class="math inline">H</span> such that</p>
<p>For every <span class="math inline">S,T</span> such that <span class="math inline">1\leq |S|,|T|\leq k</span> and <span class="math inline">S\cap T=\emptyset</span>, there is a min-<span class="math inline">ST</span>-cut in <span class="math inline">H</span> that is a min-<span class="math inline">ST</span>-cut in <span class="math inline">G</span>.</p>
<p>We recover Gomory-Hu tree when <span class="math inline">k=1</span>. There were some consideration of a problem similar to this <span class="citation" data-cites="2015arXiv151108647C">[<a href="#ref-2015arXiv151108647C">1</a>]</span>.</p>
<p>There are various useful definition of <em>nice</em> , for example sparse or bounded treewidth. Likely none of them would apply, because we can show that for <span class="math inline">k=2</span>, there are graphs where <span class="math inline">H</span> is almost the complete graph.</p>
<p>Let <span class="math inline">G</span> be the complete graph on <span class="math inline">n</span> vertices, and each edge has capacity <span class="math inline">1</span>. Let <span class="math inline">f(S)</span> be the sum of the capacity of edges going across <span class="math inline">S</span>. There is a unique <span class="math inline">ST</span>-min cut for every <span class="math inline">|T|=1</span> and <span class="math inline">|S|=2</span>. Hence this shows that <span class="math inline">f(\{v\}) = n-1</span> for every <span class="math inline">v\in V</span>. If <span class="math inline">|S|=|T|=2</span>, there are exactly two min <span class="math inline">ST</span>-cuts, either <span class="math inline">S</span> or <span class="math inline">T</span> in <span class="math inline">G</span>. Assume that <span class="math inline">T</span> is not a min <span class="math inline">ST</span>-cut in <span class="math inline">H</span>, then <span class="math inline">S</span> has to be the min <span class="math inline">ST</span>-cut in <span class="math inline">H</span>. Therefore for all <span class="math inline">\{s_1,s_2\}</span> such that <span class="math inline">s_1,s_2\not \in T</span>, we have <span class="math inline">f(\{s_1,s_2\})=2n-4</span>. Because <span class="math inline">f(\{s_1\})=f(\{s_2\})=n-1</span>, the edge between <span class="math inline">s_1</span> and <span class="math inline">s_2</span> has capacity <span class="math inline">1</span>. The complete graph on <span class="math inline">V\setminus T</span> has to be a subgraph of <span class="math inline">H</span>.</p>
<h1 id="reference" class="unnumbered">Reference</h1>
<div id="refs" class="references">
<div id="ref-2015arXiv151108647C">
<p>[1] R. Chitnis, L. Kamma, R. Krauthgamer, <strong>Tight Bounds for Gomory-Hu-like Cut Counting</strong>, ArXiv E-Prints. (2015).</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2016-02-01. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Mon, 01 Feb 2016 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2016-02-01-gomory-hu-bad-news.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Divide and conquer over cyclic groups</title>
    <link>https://chaoxuprime.com/blog/posts/2015-11-20-divide-and-conquer-over-cyclic-groups.html</link>
    <description><![CDATA[<br />
<div>
<p>Recently we found a divide and conquer algorithm over <span class="math inline">\Z_m</span>. We have an efficient algorithm for the case where all the elements <span class="math inline">S</span> are in <span class="math inline">\Z_m^*</span>, the set of units.</p>
<p>Our divide and conquer algorithm basically partition the numbers by throwing them into different subgroups. Assume <span class="math inline">m</span> has distinct prime factors <span class="math inline">p_1 &lt; \ldots &lt; p_k</span>, and for simplicity, define <span class="math inline">p_0=1</span>. We partition <span class="math inline">S</span> to <span class="math inline">S_0,\ldots,S_k</span>, where <span class="math inline">S_i</span> contain all the elements that's divisible by <span class="math inline">p_i</span> but not <span class="math inline">p_j</span> for any <span class="math inline">j&gt;i</span>. We recursively apply our algorithm to each <span class="math inline">S_i/p_i</span> in <span class="math inline">\Z_{m/p_i}</span> and combine the solution.</p>
<p>This gives us a recurrence relation, and the crucial part of the recurrence involves the following function.</p>
<p>Let <span class="math inline">p_i</span> be the <span class="math inline">i</span>th smallest prime number, and <span class="math inline">p_0</span> defined as <span class="math inline">1</span>. If we know that <span class="math inline">f_0(x) = x</span> and <span class="math inline">f_k(x) = \sum_{i=0}^k f_i(x/p_i)</span>, then we can show that <span class="math display">\displaystyle 
f_k(x) = x \prod_{i=1}^{k} \left(1+\frac{1}{p_j-1}\right)
</span> by induction.</p>
<p>First, we would need a small lemma.</p>
<section class="theorem-environment Lemma" id="Lemma-1">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">1</span></span>
<p>Let <span class="math inline">a_1,\ldots,a_k</span> be real numbers such that non of them is <span class="math inline">0</span> or <span class="math inline">1</span>, then <span class="math display">\displaystyle 
1+\sum_{j=1}^k \frac{1}{p_j} \prod_{i=1}^j \left(1+\frac{1}{p_i -1}\right) = \prod_{j=1}^k \left(1+\frac{1}{p_j-1}\right)
</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Proof by induction, basically <span class="math inline">\frac{1}{x} (1+\frac{1}{x-1})=\frac{1}{x-1}</span> for any <span class="math inline">x\neq 0,1</span>, so this is true when <span class="math inline">k=1</span>.</p>
<p><span class="math display">\displaystyle \begin{aligned}
1+\sum_{j=1}^k \frac{1}{p_j} \prod_{i=1}^j \left(1+\frac{1}{p_i -1}\right) &amp;= \prod_{j=1}^{k-1}\left(1+\frac{1}{p_j-1}\right) + \frac{1}{p_k}\prod_{j=1}^{k}\left(1+\frac{1}{p_j-1}\right)\\
&amp;= \left(1+\frac{1}{p_k} \left(1 + \frac{1}{p_{k-1}}\right) \right)\prod_{j=1}^{k-1}\left(1+\frac{1}{p_j-1}\right)\\
&amp;= \left(1+\frac{1}{p_k -1}\right)\prod_{j=1}^{k-1}\left(1+\frac{1}{p_j-1}\right)\\
\end{aligned}</span></p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p><span class="math display">\displaystyle 
	f_k(x) = x \prod_{i=1}^{k} \left(1+\frac{1}{p_i-1}\right)
</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math display">\displaystyle \begin{aligned}
	f_k(x)            &amp;= \sum_{i=0}^k f_i(x/p_i)\\
	f_k(x)-f_k(x/p_i) &amp;= \sum_{i=0}^{k-1} f_i(x/p_i)\\
	                  &amp;= x \sum_{i=0}^{k-1} \frac{1}{p_i} \prod_{j=1}^i \left(1+\frac{1}{p_j-1}\right)\\
	                  &amp;= x \left(1 + \sum_{i=1}^{k-1} \frac{1}{p_i} \prod_{j=1}^i \left(1+\frac{1}{p_j-1}\right)\right)\\
	                  &amp;= x \prod_{i=1}^{k-1} \left(1+\frac{1}{p_i-1}\right)\\
\end{aligned}</span></p>
<p>We can substitute <span class="math inline">f_k(x) = x \prod_{i=1}^{k} \left(1+\frac{1}{p_i-1}\right)</span>, and see the result matches.</p>
<p><span class="math display">\displaystyle \begin{aligned}
	x\left(1-\frac{1}{p_i}\right) \prod_{i=1}^{k} \left(1+\frac{1}{p_i-1}\right) = x \prod_{i=1}^{k-1} \left(1+\frac{1}{p_i-1}\right)
\end{aligned}</span></p>
</section>
<p>It's also useful to bound <span class="math inline">f_k(x)</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p><span class="math display">\displaystyle 
	f_k(x) = O(x \log k)
</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math display">\displaystyle \begin{aligned}
	f_k(x) &amp;= x \prod_{i=1}^{k} \left(1+\frac{1}{p_i-1}\right)\\
	       &amp;\leq x \exp \left( \sum_{i=1}^k \frac{1}{p_i-1}\right)\\
	       &amp;\leq x \exp \left( 1 + \sum_{i=1}^k \frac{1}{p_i}\right)\\
	       &amp;\leq x \exp \left( \log \log (k \log k) + A \right)\\
	       &amp;= O(x \log k)
\end{aligned}</span></p>
<p>It uses the facts on <a href="https://en.wikipedia.org/wiki/Divergence_of_the_sum_of_the_reciprocals_of_the_primes">sum of reciprocals of the primes</a>.</p>
</section>
<p>Apply this to the actual algorithm running time analysis, we would get a <span class="math inline">O(\log \log m)</span> blow up of the running time for the <span class="math inline">\Z_m^*</span> algorithm.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-11-20. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Fri, 20 Nov 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-11-20-divide-and-conquer-over-cyclic-groups.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Subset sum of elements sum to <span class="math inline">\sigma</span></title>
    <link>https://chaoxuprime.com/blog/posts/2015-07-20-subset-sum-parametrized-by-sum.html</link>
    <description><![CDATA[<br />
<div>
<p>We assume the input of the subset sum problem is a sequence of <span class="math inline">n</span> positive integers that sums to <span class="math inline">\sigma</span>. We are interested if there is a subsequence sums to <span class="math inline">t</span>.</p>
<p>In this case, the subset sum problem can be solved in <span class="math inline">O(\sigma \log^2 \sigma)</span> time. In fact, it output all possible subset sums in the same running time.</p>
<p>Consider we partition the input into two subsequences, each have sum in between <span class="math inline">\sigma/4</span> and <span class="math inline">3\sigma/4</span>, and solve each recursively then take the Minkowski sum. One can analyze this and get <span class="math inline">O(\sigma \log^2 \sigma)</span> running time. Notice if at some point, such partition cannot be found, then there is a side with a single huge element, and hence can be solved in constant time.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-07-20. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Mon, 20 Jul 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-07-20-subset-sum-parametrized-by-sum.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Sum of sparse array in linear time</title>
    <link>https://chaoxuprime.com/blog/posts/2015-04-22-sum-of-sparse-array-in-linear-time.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">\vec{n}=(n_1,\ldots,n_d)</span>. Define <span class="math inline">\vec{x}\mod \vec{n} = (x_1 \mod n_1,\ldots,x_d\mod n_d)</span>. We want to represent an <span class="math inline">d</span>-dimensional array. Assume <span class="math inline">A</span> and <span class="math inline">B</span> are both <span class="math inline">d</span>-dimensional arrays of size <span class="math inline">\vec{n}</span> and one have <span class="math inline">m</span> non-zero elements one have <span class="math inline">m&#39;</span> non-zero elements. The following operations should be supported.</p>
<ol type="1">
<li><span class="math inline">circshift(A,\vec{r})</span> creates a new sparse array <span class="math inline">C</span>, such that <span class="math inline">C((\vec{i}+\vec{r}) \mod \vec{n})=A(\vec{i})</span>. This is the <a href="http://www.mathworks.com/help/matlab/ref/circshift.html">circshift operation</a> in matlab. Running time should be <span class="math inline">O(m)</span>.</li>
<li>Similarly, we can define <span class="math inline">shift(A,\vec{t})</span>, such that <span class="math inline">C(\vec{i}+\vec{t})=A(\vec{i})</span>, if <span class="math inline">\vec{i}+\vec{t}</span> is outside the range, we have <span class="math inline">0</span> instead.</li>
<li><span class="math inline">A+B</span> returns a sparse array <span class="math inline">C</span> such that <span class="math inline">C(\vec{i})=A(\vec{i})+B(\vec{i})</span> in <span class="math inline">O(m+m&#39;)</span> time.</li>
<li><span class="math inline">elements(A)</span> output all elements with associated coordinates in <span class="math inline">A</span> in <span class="math inline">O(m)</span> time.</li>
<li><span class="math inline">initialize(x,\vec{n})</span> create a new sparse array with size <span class="math inline">\vec{n}</span> and one element <span class="math inline">x</span> initialized at <span class="math inline">\vec{0}</span> position.</li>
</ol>
<p>We create a sparse list with <span class="math inline">d-1</span> dimension slices, and the lower dimension slices can be handled inductively. All we need to do is to implement sparse list. The list should store the position and value pairs ordered by position. Sum can be done with a merge operation. circshift go though all elements one by one and update the position, and then rotate the list so the smallest position is in the beginning.</p>
<p>This data structure can be useful output sensitive dynamic programming problems. For example, multidimensional subset sum have a simple recursive solution.</p>
<ol type="1">
<li>Input <span class="math inline">S=\{s_1,\ldots,s_n\}</span></li>
<li><span class="math inline">X\gets \{0\}</span>.</li>
<li>For <span class="math inline">i</span> from <span class="math inline">1</span> to <span class="math inline">n</span>, <span class="math inline">X\gets X \cup \{x+s_i|x\in X\}</span>.</li>
<li>Return <span class="math inline">X</span></li>
</ol>
<p>The running time is <span class="math inline">O(|S||X|)</span>, where <span class="math inline">X</span> is the final output, since <span class="math inline">\{x+s_i|x\in X\}</span> is a shift, and union is just a sum. Using circshift, it can produce a output sensitive algorithm for subset sums in finite abelian groups.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-04-22. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Wed, 22 Apr 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-04-22-sum-of-sparse-array-in-linear-time.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>A characterization of treewidth 2 graphs</title>
    <link>https://chaoxuprime.com/blog/posts/2015-04-10-treewidth-2.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider 3 reduction operations on a graph:</p>
<ol type="1">
<li>Parallel reduction: Remove an parallel edge.</li>
<li>Series reduction: Remove a degree 2 vertex <span class="math inline">v</span> and add an edge to connect <span class="math inline">v</span>'s neighbor.</li>
<li>Pendant/isolated vertex/loop reduction: Remove a vertex with degree at most <span class="math inline">1</span>, remove loops.</li>
</ol>
<p>For an edge <span class="math inline">e</span>, a sequence of reduction is called <span class="math inline">e</span>-avoiding if none of the reduction delete <span class="math inline">e</span> or the vertices incident to <span class="math inline">e</span>.</p>
<p>A reduction sequence is maximal if there is no reduction can be applied or any reduction will decrease the number of vertices to less than <span class="math inline">2</span>.</p>
<p>A graph has treewidth <span class="math inline">2</span>, if and only if there exist a reduction sequence that reduce the graph to an empty graph.</p>
<p>We can prove a stronger result, such that we can make sure that every maximal <span class="math inline">e</span>-avoiding reduction reduce the graph to a single edge <span class="math inline">e</span>.</p>
<section class="theorem-environment Lemma" id="Lemma-1">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">1</span></span>
<p>Every simple treewidth <span class="math inline">2</span> graph <span class="math inline">G</span> with at least <span class="math inline">3</span> vertices has at least <span class="math inline">2</span> non-adjacent vertices with degree at most <span class="math inline">2</span>, or it is a triangle.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Consider a tree decomposition. If it has more than <span class="math inline">2</span> bags, then there are <span class="math inline">2</span> leaves. In each leave, there exist a vertex with degree at most <span class="math inline">2</span>, since it is not incident to any vertex outside it's bag and there are at most <span class="math inline">2</span> other vertices in the bag. Also, those two vertices are not adjacent to each other.</p>
<p>If it contain only <span class="math inline">1</span> bag, and if there is no <span class="math inline">2</span> non-adjacent vertices wit degree at most <span class="math inline">2</span>, then it must be a triangle.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>A graph <span class="math inline">G</span> has treewidth 2 if and only if for every edge <span class="math inline">e</span>, every maximal sequence of <span class="math inline">e</span>-avoiding reduction reduce the graph to the edge <span class="math inline">e</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>For one direction, consider any <span class="math inline">e</span>-avoiding reduction that reduces the graph to a single edge <span class="math inline">e</span>. Apply two more vertex removal to get the empty graph.</p>
<p>For the other direction, assume <span class="math inline">e</span> incident to edge <span class="math inline">uv</span>.</p>
<p>The proof is by induction. The base case where <span class="math inline">G</span> is a graph with at most <span class="math inline">2</span> vertices is trivial.</p>
<p>Consider the induction step with a graph <span class="math inline">G</span> with at least <span class="math inline">3</span> vertices. Each reduction operation can be expressed as minor operations, thus it results a treewidth <span class="math inline">2</span> graph, hence it has the desired property. Thus we need to show if a graph has treewidth <span class="math inline">2</span>, one of the operations can be applied. Indeed, we can always apply a reduction if there is at least <span class="math inline">3</span> vertices.</p>
<p>If none of the operations can be applied, then the graph has to be simple. There can't be two non-adjacent vertices with degree at most <span class="math inline">2</span>, otherwise one of them is not <span class="math inline">u</span> or <span class="math inline">v</span> and can be removed with series reduction. If the graph is a triangle, then there is a vertex with degree <span class="math inline">2</span> that's not <span class="math inline">u</span> and <span class="math inline">v</span>. Hence, by the Lemma, the graph can have at most <span class="math inline">2</span> vertices.</p>
</section>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>One can apply this to show that the AB-reducible graphs and generalized outerplanar graphs in <span class="citation" data-cites="Cheng2012449">[<a href="#ref-Cheng2012449">1</a>]</span> is exactly the graphs with treewidth <span class="math inline">2</span>.</p>
</section>
<h1 id="acknowledgment" class="unnumbered">Acknowledgment</h1>
<p>I wish to thank <a href="https://nlp.stanford.edu/~urvashik/">Urvashi Khandelwal</a> and <a href="http://vmadan2.web.engr.illinois.edu/">Vivek Madan</a> for helpful discussions.</p>
<h1 id="reference" class="unnumbered">Reference</h1>
<div id="refs" class="references">
<div id="ref-Cheng2012449">
<p>[1] Q. Cheng, F. Chen, W. Xu, S. Wang, <strong>Recursive sum–product algorithm for generalized outer-planar graphs</strong>, Information Processing Letters. 112 (2012) 449–456 <a href="https://doi.org/10.1016/j.ipl.2012.03.001">10.1016/j.ipl.2012.03.001</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-04-10. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Fri, 10 Apr 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-04-10-treewidth-2.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Minimum cost zero skew tree</title>
    <link>https://chaoxuprime.com/blog/posts/2015-03-15-minimum-cost-zero-skew-tree.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Let <span class="math inline">T</span> be a rooted tree with real costs <span class="math inline">c(e)</span> and length lower bounds <span class="math inline">\ell(e)</span> on each edge <span class="math inline">e</span>. We are interested in compute a function <span class="math inline">f</span>, such that <span class="math inline">f(e)\geq \ell(e)</span>, for any root to leaf path <span class="math inline">P</span>, <span class="math inline">\sum_{e\in P} f(e)=t</span> and <span class="math inline">\sum_{e\in E} c(e)f(e)</span> is minimized.</p>
</section>
<p>This is the <a href="http://theory.cs.uni-bonn.de/info5/steinerkompendium/node27.html">zero skew tree problem</a> where the tree is fixed.</p>
<p>Here we show how this problem can be solved in <span class="math inline">O(n\log n)</span> time by reducing it to minimum cost flow on 2-terminal series parallel graph. <span class="citation" data-cites="Booth1993416">[<a href="#ref-Booth1993416">1</a>]</span></p>
<p><span class="math inline">C(v)</span> denote the set of all the children of <span class="math inline">v</span>.</p>
<p>For <span class="math inline">vu\in E(T)</span>, and <span class="math inline">u\in C(v)</span>, the graph <span class="math inline">P(vu)</span> is the parallel connection of one single edge with cost <span class="math inline">c(vu)</span>, lower bound <span class="math inline">\ell(vu)</span>, infinite upper bound and a series-parallel graph <span class="math inline">S(u)</span>. Let the graph <span class="math inline">S(v)</span> for <span class="math inline">v\in V(T)</span> to be the series connection of <span class="math inline">P(vu)</span> for all <span class="math inline">u\in C(v)</span>(the connection can be ordered arbitrarily).</p>
<p>The base case is when <span class="math inline">u</span> does not have any children, and <span class="math inline">P(vu)</span> is just a single edge with two terminals.</p>
<p>Let <span class="math inline">G=S(r)</span>, where <span class="math inline">r</span> is the root of <span class="math inline">T</span>. There is a bijection between the edges in <span class="math inline">T</span> and the edges in <span class="math inline">G</span>.</p>
<p>Finding the minimum cost flow of value <span class="math inline">t</span> in <span class="math inline">G</span> with the two terminals gives us the desired solution by going back to the original edge using the bijection.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Booth1993416">
<p>[1] H. Booth, R. Tarjan, <strong>Finding the minimum-cost maximum flow in a series-parallel network</strong>, Journal of Algorithms. 15 (1993) 416–446 <a href="https://doi.org/10.1006/jagm.1993.1048">10.1006/jagm.1993.1048</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-03-15. </div>
    <div class="info">Tags: series-parallel, tree.</div>

</div>]]></description>
    <pubDate>Sun, 15 Mar 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-03-15-minimum-cost-zero-skew-tree.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Network Transformations and Applications</title>
    <link>https://chaoxuprime.com/blog/posts/2015-02-13-network-transformations.html</link>
    <description><![CDATA[<br />
<div>
<p>There are so many variations of what minimum cost flow means. Sometimes an algorithm might state it only works if the costs are all positive. Here are some of the transforms, many are just from section 2.4 of <span class="citation" data-cites="Ahuja:1993:NFT:137406">[<a href="#ref-Ahuja:1993:NFT:137406">1</a>]</span>.</p>
<p>In the most general formulation of the minimum cost flow problem</p>
<ol type="1">
<li>Each vertex has a balance constraint.</li>
<li>Each edge has lower bound(demand) and upper bound(capacity).</li>
</ol>
<p>A flow is feasible if it's within lower bound and upper bound and balance constraint must be satisfied at all vertices.</p>
<p>Min-cost flow problem finds the flow with minimum cost. Min-cost circulation is the min-cost flow problem with all balance <span class="math inline">0</span>. Min-cost transshipment is the min-cost flow problem with no edge capacities. (But there is a lower bound of <span class="math inline">0</span> on all edges).</p>
<h1 id="remove-all-balance"><span class="header-section-number">1</span> Remove all balance</h1>
<p>This shows min-cost flow is equivalent to min-cost circulation. A common way to remove balance is add an new vertex <span class="math inline">s</span>. For each vertex <span class="math inline">v</span> with balance <span class="math inline">b_v</span>, add edge <span class="math inline">sv</span> with lower and upper bound both <span class="math inline">-b_v</span>.</p>
<p>However, this might make the graph no longer have certain structural properties. For example, the graph might no longer be planar.</p>
<p>One way to do this is solve two problems. First compute a spanning tree <span class="math inline">T</span> of the graph. Add parallel edges from <span class="math inline">T</span> to <span class="math inline">G</span>. Find flow only on those parallel edges(so it's just a tree) that satisfies all the balance constraints. Let this flow be <span class="math inline">f</span>. Make sure the cost of the flow on the added edges are infinity, and consider the residue graph. Now, solve the min-cost circulation on the residual graph and then sum with the flow <span class="math inline">f</span> gives one the desired result. This idea was first used for max flow problem with balance constraints in <span class="citation" data-cites="Miller:1995:FPG:214022.214026">[<a href="#ref-Miller:1995:FPG:214022.214026">2</a>]</span>.</p>
<h1 id="remove-upper-and-lower-bounds"><span class="header-section-number">2</span> Remove upper and lower bounds</h1>
<p>This shows min-cost flow is equivalent to min-cost transshipment problem. All operations are local, therefore we establish the notation. There is an edge <span class="math inline">st</span> with lower bound <span class="math inline">l</span>, upper bound <span class="math inline">u</span>, cost <span class="math inline">c</span>. <span class="math inline">b_s</span> and <span class="math inline">b_t</span> are the balances of <span class="math inline">s</span> and <span class="math inline">t</span>, respectively.</p>
<h2 id="remove-non-zero-lower-bound"><span class="header-section-number">2.1</span> Remove non-zero lower bound</h2>
<p>The idea is we just send the flow of value <span class="math inline">l</span> along the edge! We transform so the new balance for <span class="math inline">s</span> is <span class="math inline">b_s - l</span>, new balance for <span class="math inline">t</span> is <span class="math inline">b_t+l</span>, and the new upper bound on the edge is <span class="math inline">u-l</span>. The low The cost doesn't change.</p>
<h2 id="remove-upper-bounds"><span class="header-section-number">2.2</span> Remove upper bounds</h2>
<p>Here we assume <span class="math inline">l=0</span>. If not, first remove the non-zero lower bound. We create a new node <span class="math inline">w</span> with balance <span class="math inline">-u</span>. We remove the edge <span class="math inline">st</span>, and split it into <span class="math inline">sw</span> and <span class="math inline">tw</span> instead. <span class="math inline">sw</span> has infinite capacity and cost <span class="math inline">c</span>. <span class="math inline">tw</span> has infinite capacity and cost <span class="math inline">0</span>. Finally, let the balance of <span class="math inline">t</span> be <span class="math inline">b_t+u</span>.</p>
<p>The idea is instead of sending flow on <span class="math inline">st</span>, now we send on <span class="math inline">sw</span>. Because the balance is <span class="math inline">-u</span>, we can't send more than <span class="math inline">u</span> unit of flow. To cover the remaining balance, some flow is sent from <span class="math inline">t</span> to <span class="math inline">w</span>.</p>
<h1 id="applications"><span class="header-section-number">3</span> Applications</h1>
<p>Let <span class="math inline">C</span> be a class of graphs. Let <span class="math inline">Sub(C)=\{G| G\subset H, H\in C\}</span> be the set of subgraphs of graphs in class <span class="math inline">C</span>. If there is an algorithm that solves min-cost circulation/transshipment problem for <span class="math inline">C</span>, then there is an algorithm that solves min-cost flow problem on <span class="math inline">Sub(C)</span>. The running time of the algorithm is only the extra time spent on complete the graph to some graph in <span class="math inline">C</span> by adding edges of <span class="math inline">0</span> capacity.</p>
<p>This directly implies min-cost flow on general series-parallel graphs can be solved in <span class="math inline">O(n\log n)</span> time using the algorithm for min-cost circulation on <span class="math inline">2</span>-terminal series-parallel graphs(Note the article solves the min-cost maximum flow problem, one can see it also works for min-cost circulation)<span class="citation" data-cites="Booth1993416">[<a href="#ref-Booth1993416">3</a>]</span>. As a corollary, one can solve min-cost flow problem on outerplanar graph in the same running time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Ahuja:1993:NFT:137406">
<p>[1] R.K. Ahuja, T.L. Magnanti, J.B. Orlin, <strong>Network flows: Theory, algorithms, and applications</strong>, Prentice-Hall, Inc., Upper Saddle River, NJ, USA, 1993.</p>
</div>
<div id="ref-Miller:1995:FPG:214022.214026">
<p>[2] G.L. Miller, <strong>Flow in planar graphs with multiple sources and sinks</strong>, SIAM J. Comput. 24 (1995) 1002–1017 <a href="https://doi.org/10.1137/S0097539789162997">10.1137/S0097539789162997</a>.</p>
</div>
<div id="ref-Booth1993416">
<p>[3] H. Booth, R. Tarjan, <strong>Finding the minimum-cost maximum flow in a series-parallel network</strong>, Journal of Algorithms. 15 (1993) 416–446 <a href="https://doi.org/10.1006/jagm.1993.1048">10.1006/jagm.1993.1048</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-02-13. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Fri, 13 Feb 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-02-13-network-transformations.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Two problem related to sequence of sets</title>
    <link>https://chaoxuprime.com/blog/posts/2015-02-08-two-problem-related-to-sequence-of-sets.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a sequence of sets <span class="math inline">S_1,\ldots,S_n</span> with a total of <span class="math inline">m</span> elements. Partition <span class="math inline">[n]</span>, such that if <span class="math inline">i,j</span> is in the same partition class, then <span class="math inline">S_i = S_j</span>.</p>
</section>
<p>Solve the problem by building a trie over the lexicographic ordering of the elements in the set. Since the alphabet has size <span class="math inline">n</span>, it has running time <span class="math inline">O(m\log n)</span>. One can get better running time using integer data structures, say <span class="math inline">O(m\log \log n)</span> using van Emde Boas tree.</p>
<p><span class="math inline">O(m)</span> time is actually possible. For each <span class="math inline">k</span>, we build the set <span class="math inline">H_k = \set{j | k\in S_j}</span> (as a list). We define equivalent relation <span class="math inline">\equiv_k</span> as <span class="math inline">i\equiv_k j</span> if <span class="math inline">S_i\cap [k] =S_j\cap [k]</span>. If we have equivalent class of <span class="math inline">\equiv_k</span>, we can obtain the equivalent class of <span class="math inline">\equiv_{k+1}</span> in <span class="math inline">O(|H_k|)</span> time. Hence together the running time is <span class="math inline">O(m)</span>.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given a sequence of sets <span class="math inline">S_1,\ldots,S_n</span> containing a total of <span class="math inline">m</span> integers, and a integer <span class="math inline">k</span>. Decide if there exists <span class="math inline">i</span> and <span class="math inline">j</span> such that <span class="math inline">i\neq j</span> and <span class="math inline">|S_i\cap S_j|\geq k</span>.</p>
</section>
<p>We assume the elements in the sets are in <span class="math inline">[m]</span>. Let <span class="math inline">S=\bigcup_{i=1}^n S_i</span>.</p>
<p>For <span class="math inline">k=0,1</span>, we can solve it in <span class="math inline">O(m)</span> time: Decide if any element appears more than once in the sets.</p>
<p>For larger <span class="math inline">k</span>, we shall compute <span class="math inline">|S_i\cap S_j|</span> for every pair <span class="math inline">i</span> and <span class="math inline">j</span>. To do this, we start with an all zero <span class="math inline">n\times n</span> matrix <span class="math inline">C</span>. At the end of the algorithm, <span class="math inline">C_{i,j} = |S_i\cap S_j|</span> for all <span class="math inline">i,j\in [n]</span>. For each element <span class="math inline">x</span>, we find <span class="math inline">E_x = \set{i|x\in S_i}</span>. This takes <span class="math inline">O(m)</span> time. We increment <span class="math inline">C_{i,j}</span> for all <span class="math inline">i,j\in E_x</span>. We claim this algorithm have running time <span class="math inline">O(nm)</span>. Indeed, for each <span class="math inline">x</span>, we spend <span class="math inline">|E_x|</span> time in incrementing <span class="math inline">C_{i,j}</span> where <span class="math inline">i,j\in E_x</span>. Hence the running time is bounded by <span class="math inline">\sum_{x\in S} |E_x|^2</span>. We know <span class="math inline">\sum_{x\in S} |E_x|=m</span> and <span class="math inline">|E_x|\leq n</span>. We see the worst case is when <span class="math inline">|E_x|=n</span> and <span class="math inline">|S|=m/n</span>. In that case, we have running time <span class="math inline">O(\sum_{x\in S} n^2)=O(mn)</span>.</p>
<p>Since we just want to find a pair <span class="math inline">\set{i,j}</span> where <span class="math inline">|S_i\cap S_j|\geq k</span>. We can stop the algorithm as soon as <span class="math inline">C_{i,j}\geq k</span> for some <span class="math inline">i</span> and <span class="math inline">j</span>. This means we can increment at most <span class="math inline">(k-1)n^2</span> times.</p>
<p>Together, the running time become <span class="math inline">O(\min(nm,k n^2+m))</span>.</p>
<p>For <span class="math inline">k=2</span>. One can improve the running time when <span class="math inline">n</span> is large by reduce it to a problem similar to <a href="/posts/2015-02-02-rectangle-in-point-set.html">finding rectangles</a> or finding a <span class="math inline">C_4</span> in the incident graph. Let <span class="math inline">n&#39;</span> be <span class="math inline">|\bigcup_i S_i|</span>, we can obtain a more refined bound. Together, the final running time for <span class="math inline">k=2</span> is <span class="math inline">O(\min(m^{4/3}, dm, n^2+m))</span>. Here <span class="math inline">d</span> is the <a href="https://en.wikipedia.org/wiki/Degeneracy_(graph_theory)">degeneracy</a> of the incident graph of the sets and the elements, which is bounded above by the maximum degree.</p>
<p>I am unaware of any faster results for <span class="math inline">k&gt;2</span>, which is equivalent to finding subgraph of the form <span class="math inline">K_{2,k}</span> in bipartite graphs.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-02-08. </div>
    <div class="info">Tags: algorithm.</div>

</div>]]></description>
    <pubDate>Sun, 08 Feb 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-02-08-two-problem-related-to-sequence-of-sets.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Rectangles in point set</title>
    <link>https://chaoxuprime.com/blog/posts/2015-02-02-rectangle-in-point-set.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given <span class="math inline">n</span> points in the plane <span class="math inline">P</span>, find if any <span class="math inline">4</span> of them are the vertices of some axis-aligned rectangle.</p>
</section>
<p>The idea is we guess the left vertical segment of the rectangle, and see what would be the right vertical segment. If we pick an left vertical line <span class="math inline">l</span>, and then for each <span class="math inline">(x,y)\in l\cap P</span>, we consider all the points with the same <span class="math inline">y</span> coordinate and to the right of <span class="math inline">x</span>, and add a counter to the vertical lines that contains it. This can be done in linear time with respect to number of vertices with the same <span class="math inline">y</span> coordinate if one already builds a data structure before hand. If any counter become <span class="math inline">2</span>, then we are done.</p>
<p>It is a <span class="math inline">O(n^2)</span> time algorithm, since the time it takes is at most <span class="math inline">O(n)</span> to guess each left vertical segment. One could, however analyze this algorithm better, and realize the time is actually <span class="math inline">O(ln)</span>, where <span class="math inline">l</span> is the maximum number of points on a horizontal line. Indeed, we look at a horizontal line that contain <span class="math inline">l</span> points, and realize for each point on the horizontal line, we need to increment a counter at most <span class="math inline">l</span> times.</p>
<p>We can also solve the problem in <span class="math inline">O(t^2+n)</span> time, where <span class="math inline">t</span> is the number of vertical lines. Note since we can stop as soon as a counter become <span class="math inline">2</span>. The number of counter we will increase is at most <span class="math inline">t^2</span>. Indeed, the counter depend only one two vertical lines.</p>
<p>There is an <span class="math inline">O(n^{3/2})</span> algorithm <span class="citation" data-cites="vanKreveldD91">[<a href="#ref-vanKreveldD91">1</a>]</span>, using this <span class="math inline">O(n^2)</span> algorithm as subroutine.</p>
<p>We consider the set of vertical lines that contains at least <span class="math inline">2</span> points. This give us two set of vertical lines, <span class="math inline">S</span> are the lines with at most <span class="math inline">\sqrt{n}</span> points and <span class="math inline">L</span> are the lines contain at least <span class="math inline">\sqrt{n}+1</span> lines.</p>
<p>There are 3 possibilities. There is a rectangle with two sides contained in <span class="math inline">S</span>, or one side in <span class="math inline">S</span> one in <span class="math inline">L</span>, or both in <span class="math inline">L</span>.</p>
<p>For the first case, just use our <span class="math inline">O(ln)</span> algorithm, which gives us <span class="math inline">O(n^{3/2})</span> time.</p>
<p>For the second case, consider we pick one line in <span class="math inline">S</span> and the union of all the points in the lines in <span class="math inline">L</span>. For each point in <span class="math inline">S</span>, we will find if this point is in some line in <span class="math inline">L</span>, if it is, we increment a counter for that line. We would increment at most <span class="math inline">\sqrt{n}</span> counters. The running time is therefore <span class="math inline">\sum_{l\in S} |l\cap P|(\log n + \sqrt{n}) = O(n^{3/2})</span>.</p>
<p>Once we are done with the first two case, consider remove all the points lying on the small lines. Now we only have large lines. Since there are at most <span class="math inline">\sqrt{n}</span> large lines, we can rotate the plane and run the algorithm again, but this time, we know all the lines are small.</p>
<p>As noted in <span class="citation" data-cites="AlonYZ97">[<a href="#ref-AlonYZ97">2</a>]</span>, rectangle finding problem can be reduced to finding a <span class="math inline">C_4</span> in a bipartite graph. The vertices are <span class="math inline">X=\set{x|(x,y)\in P}</span> and <span class="math inline">Y=\set{y|(x,y)\in P}</span>, and the edges are <span class="math inline">P</span>. So this is a nice interaction with graph theory. In the same article, some stronger bounds were established. First, if the graph have <a href="https://en.wikipedia.org/wiki/Degeneracy_(graph_theory)">degeneracy</a> <span class="math inline">d</span>, the running is <span class="math inline">O(md)</span>. They used the fact and lead to finding a <span class="math inline">C_4</span> takes <span class="math inline">O(m^{4/3})</span> time <span class="citation" data-cites="AlonYZ97">[<a href="#ref-AlonYZ97">2</a>]</span>.</p>
<p>We briefly mention how this is done.</p>
<p>First, it is known that if <span class="math inline">m \geq c n^{1/2}</span>, then there exists a <span class="math inline">C_4</span>. If <span class="math inline">d\geq c n^{3/2}</span>, then one can find a subgraph that has degree at least <span class="math inline">d</span> in <span class="math inline">O(m)</span> time. Note this implies in the subgraph, there exists a <span class="math inline">C_4</span>, which there is a particular algorithm to solve for it.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-vanKreveldD91">
<p>[1] M.J. van Kreveld, M.T. De Berg, <strong>Finding squares and rectangles in sets of points</strong>, BIT Numerical Mathematics. 31 (1991) 202–219 <a href="https://doi.org/10.1007/BF01931281">10.1007/BF01931281</a>.</p>
</div>
<div id="ref-AlonYZ97">
<p>[2] N. Alon, R. Yuster, U. Zwick, <strong>Finding and counting given length cycles</strong>, Algorithmica. 17 (1997) 209–223 <a href="https://doi.org/10.1007/BF02523189">10.1007/BF02523189</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-02-02. </div>
    <div class="info">Tags: classical, algorithm, computational geometry, graph theory.</div>

</div>]]></description>
    <pubDate>Mon, 02 Feb 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-02-02-rectangle-in-point-set.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Bounded regression on data streams</title>
    <link>https://chaoxuprime.com/blog/posts/2015-01-27-bounded-regression-on-data-streams.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="bounded-regression-on-data-streams"><span class="header-section-number">1</span> Bounded Regression on Data Streams</h1>
<p><a href="http://web.engr.illinois.edu/~hchang17/">Hsien-Chih</a> sent me <a href="http://www.careercup.com/question?id=5207197178920960">this problem</a>. <a href="http://www.quora.com/Given-an-integer-array-what-is-the-algorithmic-approach-to-find-minimum-adjustments-such-that-the-absolute-difference-between-the-adjacent-elements-is-within-target-value">Similar problem has been asked on Quora</a>. He noticed it might be solved in near linear time using min-cost circulation. Here we show a generalization.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Bounded Regression on Data Stream</span></span>
<p>Given</p>
<ol type="1">
<li><span class="math inline">(a_1,\ldots,a_n)\in \R^n</span>,</li>
<li><span class="math inline">(w_1,\ldots,w_n)\in \R^n_+</span>,</li>
<li><span class="math inline">(l_1,\ldots,l_{n-1})\leq (u_1,\ldots,u_{n-1}) \in \R^n</span>.</li>
</ol>
<p>Output <span class="math inline">(x_1,\ldots,x_n)\in \R^n</span> such that <span class="math inline">l_i \leq x_{i+1}-x_i\leq u_i</span> for all <span class="math inline">1\leq i&lt;n</span>, and minimize <span class="math inline">\sum_{i=1}^n w_i |a_i-x_i|</span>.</p>
</section>
<h1 id="reduce-the-problem-to-min-cost-circulation"><span class="header-section-number">2</span> Reduce the problem to min-cost circulation</h1>
<p>It's natural to model this problem as variations of min-cost circulation problem on a graph.</p>
<p>The graph <span class="math inline">G=(V,E)</span> with vertices <span class="math inline">V=\{s,v_0,\ldots,v_n\}</span>.</p>
<p>Edges:</p>
<ol type="1">
<li>Edge <span class="math inline">v_iv_{i+1}</span> for all <span class="math inline">0\leq i &lt;n</span>.</li>
<li>Edge <span class="math inline">sv_i</span> for all <span class="math inline">0\leq i\leq n</span>.</li>
</ol>
<p>Edge Capacity:</p>
<ol type="1">
<li><span class="math inline">sv_i</span> has lower bound <span class="math inline">l_i</span>, upper bound <span class="math inline">u_i</span> for all <span class="math inline">1\leq i\leq n-1</span>.</li>
<li>All other edges are uncapacited. Namely lower bound and upper bound are <span class="math inline">-\infty</span> and <span class="math inline">\infty</span> respectively.</li>
</ol>
<p>Edge Costs: <span class="math inline">v_{i-1}v_i</span> has cost function <span class="math inline">c_i(x)=w_i |a_i-x|</span>. Cost function on other edges are <span class="math inline">0</span>.</p>
<p>A function <span class="math inline">f</span> is called a circulation if <span class="math inline">\sum_{e\in \delta^+(v)} f(e)-\sum_{e\in \delta^-(v)} f(e)=0</span> for all vertex <span class="math inline">v</span>. It is feasible if <span class="math inline">f(e)</span> is within the capacity. It is min-cost if <span class="math inline">\sum_{e} c_e(f(e))</span> is minimized.</p>
<p>Solving the min-cost circulation problem would give us the desired <span class="math inline">x_i</span> by setting <span class="math inline">x_i=f(v_{i-1}v_i)</span>.</p>
<h1 id="min-cost-circulation-on-series-parallel-graphs"><span class="header-section-number">3</span> min-cost circulation on series-parallel graphs</h1>
<p>The constructed graph is a two terminal <a href="http://en.wikipedia.org/wiki/Series-parallel_graph">series-parallel graph</a>. There is a simple procedure to solve min-cost flow problem on series-parallel graphs. Consider a series connection of two edges, each with cost function <span class="math inline">f</span> and <span class="math inline">g</span>. We can replace it with an edge with cost function <span class="math inline">f + g</span>. If it is a parallel connection, then we can replace it with one edge and a cost function <span class="math inline">f~\square~g</span>, where <span class="math inline">\square</span> is the infimal convolution: <span class="math inline">(f~\square~g)(x)= \inf_y f(x-y) + g(y)</span>.</p>
<p>Once we have a good data structure to represent the costs, we can reduce the graph to one single edge easily, and find the minimum cost circulation. In particular, if the cost are continuous, convex and piecewise linear in a interval and <span class="math inline">\infty</span> everywhere else, and the total number of breakpoints is <span class="math inline">n</span>, then Booth and Tarjan has an algorithm that runs in <span class="math inline">O(n\log n)</span> time <span class="citation" data-cites="Booth1993416">[<a href="#ref-Booth1993416">1</a>]</span>.</p>
<p>Because all edge has a cost function with at most <span class="math inline">1</span> breakpoint. The bounded regression problem can be solved in <span class="math inline">O(n\log n)</span> time.</p>
<h1 id="isotonic-regression"><span class="header-section-number">4</span> Isotonic regression</h1>
<p>We can try to minimize <span class="math inline">\sqrt{\sum_{i=1}^n w_i (a_i-x_i)^2}</span> instead (<span class="math inline">L_2</span> error). It is a generalization of the lipschitz isotonic regression problem <span class="citation" data-cites="ISI:000279661700033">[<a href="#ref-ISI:000279661700033">2</a>]</span> when <span class="math inline">l_i=0</span> and <span class="math inline">u_i=u</span> for some constant <span class="math inline">u</span>. We can also ask to minimize the <span class="math inline">L_\infty</span> error.</p>
<p>If the upper bounds are <span class="math inline">\infty</span> and all lower bounds are <span class="math inline">0</span>, then the problem is called the isotonic regression problem. I have solved <a href="http://cs.stackexchange.com/questions/41519/efficient-algorithm-for-this-optimization-problem-dynamic-programming/">a interesting problem using isotonic regression</a>.</p>
<p>We can express all the problems as min-cost circulation problem on a appropriate graph. If the min-cost circulation algorithm on those graphs have the same running time as current best algorithm, it would imply something more general is acting in the background.</p>
<p>Here is what we know.</p>
<ol type="1">
<li><span class="math inline">L_1</span> error: This post shows it can be solved in <span class="math inline">O(n\log n)</span> time using the min-cost circulation formulation. It matches the running time of specialized algorithms.</li>
<li><span class="math inline">L_2</span> error: It can be solved in <span class="math inline">O(n)</span> time, but doesn't come from the quadratic cost min-cost circulation formulation.</li>
<li><span class="math inline">L_\infty</span> error: It can be solved in <span class="math inline">O(n)</span> time. However, it doesn't come from the minimax circulation problem. (In the minimax circulation, the cost is the largest edge cost incurred by the circulation).</li>
</ol>
<p>This prompt the following two natural problems:</p>
<ol type="1">
<li><p><em>Can min-cost circulation with quadratic cost on series parallel graph have <span class="math inline">O(n)</span> time solution?</em> This is in fact possible when all edges have no capacity<span class="citation" data-cites="Zohar2007691">[<a href="#ref-Zohar2007691">3</a>]</span>. But with capacity, even for a edge with a lower bound of <span class="math inline">0</span> and <span class="math inline">0</span> cost, we don't know.</p></li>
<li><p><em>What about minimax circulation?</em> We can't find any study of minimax circulation on series-parallel graphs.</p></li>
</ol>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Booth1993416">
<p>[1] H. Booth, R. Tarjan, <strong>Finding the minimum-cost maximum flow in a series-parallel network</strong>, Journal of Algorithms. 15 (1993) 416–446 <a href="https://doi.org/10.1006/jagm.1993.1048">10.1006/jagm.1993.1048</a>.</p>
</div>
<div id="ref-ISI:000279661700033">
<p>[2] P.K. Agarwal, J.M. Phillips, B. Sadri, Lipschitz unimodal and isotonic regression on paths and trees, in: A. LopezOrtiz (Ed.), LATIN 2010: THEORETICAL Informatics, 2010: pp. 384–396 <a href="https://doi.org/10.1007/978-3-642-12200-2_34">10.1007/978-3-642-12200-2_34</a>.</p>
</div>
<div id="ref-Zohar2007691">
<p>[3] R. Zohar, D. Geiger, <strong>Estimation of flows in flow networks</strong>, European Journal of Operational Research. 176 (2007) 691–706 <a href="https://doi.org/10.1016/j.ejor.2005.08.009">10.1016/j.ejor.2005.08.009</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2015-01-27. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Tue, 27 Jan 2015 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2015-01-27-bounded-regression-on-data-streams.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>TSP, Max TSP and Supnick</title>
    <link>https://chaoxuprime.com/blog/posts/2014-12-13-tsp-supnick-matrix.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given <span class="math inline">f</span> and <span class="math inline">x_1,\ldots,x_n</span>. Find a permutation <span class="math inline">\pi</span> that maximizes (minimizes) <span class="math display">\displaystyle 
\sum_{i=1}^n f(x_{\pi(i)},x_{\pi(i+1)}).
</span></p>
</section>
<p>All our index calculations are mod <span class="math inline">n</span>.</p>
<p>Assume <span class="math inline">f</span> can be evaluated in <span class="math inline">O(1)</span> time. The TSP problem reduces to this one.</p>
<section class="theorem-environment Definition" id="Definition-2">
<span class="theorem-header"><span class="type">Definition</span><span class="index">2</span><span class="name">Supnick</span></span>
<p>For all <span class="math inline">x\leq x&#39;</span>, <span class="math inline">y\leq y&#39;</span>, <span class="math inline">f:\R^2\to \R</span> is called Supnick if it has the following properties:</p>
<ol type="1">
<li>Monge: <span class="math inline">f(x,y)+f(x&#39;,y&#39;)\leq f(x&#39;,y)+f(x,y&#39;)</span>.</li>
<li>Symmetric: <span class="math inline">f(x,y)=f(y,x)</span>.</li>
</ol>
</section>
<p>The name Supnick comes from <a href="http://en.wikipedia.org/wiki/Supnick_matrix">Supnick matrix</a>, which are symmetric Monge matrices. The following theorem implies an <span class="math inline">O(n\log n)</span> algorithm to solve the TSP problem if the distance matrix is Supnick <span class="citation" data-cites="supnick">[<a href="#ref-supnick">1</a>]</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span><span class="name">Supnick’s</span></span>
<p>Let <span class="math inline">x_1\leq x_2 \leq \ldots \leq x_n</span>, <span class="math inline">f</span> is Supnick, then <span class="math display">\displaystyle 
    \sum_{i=1}^n f(x_{\pi(i)},x_{\pi(i+1)})
</span></p>
<ol type="1">
<li><p>is minimized when <span class="math inline">\pi = (1~3~5~7~\ldots~8~6~4~2)</span>.</p></li>
<li><p>is maximized when <span class="math inline">\pi = (n ~ 2 ~ (n-2) ~ 4 ~ (n-4) ~\ldots~5~ (n-3) ~3~ (n-1)~1)</span>.</p></li>
</ol>
</section>
<p>Supnick matrices appears at many places. For example, <a href="http://www.chaoxuprime.com/posts/2012-08-08-maximize-the-area-of-a-radar-chart.html">maximize the area of a radar chart</a> and <a href="http://cstheory.stackexchange.com/questions/27808/finding-a-permutation-x-p-1x-p-2-x-p-n-of-x-1-x-2-x-n-whi">find a permutation maximize sum of adjacent distance</a>.</p>
<p>It is a special case of a even larger class of problem that has the above permutation as solution: Quadratic assignment problem where the matrices are monotone antimonge and benevolent symmetric toeplitz matrix <span class="citation" data-cites="burkardQA">[<a href="#ref-burkardQA">2</a>]</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-supnick">
<p>[1] F. Supnick, <strong>Extreme hamiltonian lines</strong>, Annals of Mathematics. Second Series. 66 (1957) 179–201.</p>
</div>
<div id="ref-burkardQA">
<p>[2] R. Burkard, E. Çela, G. Rote, G. Woeginger, <strong>The quadratic assignment problem with a monotone anti-monge and a symmetric toeplitz matrix: Easy and hard cases</strong>, Mathematical Programming. 82 (1998) 125–158 <a href="https://doi.org/10.1007/BF01585868">10.1007/BF01585868</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-12-13. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Sat, 13 Dec 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-12-13-tsp-supnick-matrix.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Applications of finger trees</title>
    <link>https://chaoxuprime.com/blog/posts/2014-11-22-applications-of-finger-tree.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="finger-trees"><span class="header-section-number">1</span> Finger trees</h1>
<p>Consider a data structure <span class="math inline">S</span> that maintains a sequence of monoid elements from <span class="math inline">(M,\cdot)</span>. Say, the sequence is <span class="math inline">a_1,\ldots,a_n</span>. It has four operations. All time are amortized and not worst case.</p>
<ol type="1">
<li><p><span class="math inline">split(S,p)</span>, <span class="math inline">p:M\to \{0,1\}</span> is a monotonic predicate on <span class="math inline">M</span>, i.e. <span class="math inline">p(ab)\geq p(a)</span>. It split the sequence at position <span class="math inline">t</span>, such that <span class="math inline">p(\prod_{i=1}^j a_i) = 0</span> for all <span class="math inline">j &lt; t</span>, and <span class="math inline">p(\prod_{i=1}^j a_i) = 1</span> for all <span class="math inline">j\geq t</span>. This takes <span class="math inline">O(\log \min(n,n-t))</span> time.</p></li>
<li><p><span class="math inline">concat(S,T)</span>, concatenate sequence represented by <span class="math inline">S</span> and the sequence represented by <span class="math inline">T</span>. If the length of the sequences are <span class="math inline">n</span> and <span class="math inline">m</span>, respectively, then this operation takes <span class="math inline">O(\log \min(n,m))</span> time.</p></li>
<li><p><span class="math inline">product(S)</span>, returns <span class="math inline">\prod_{i=1}^n a_i</span> in <span class="math inline">O(1)</span> time.</p></li>
<li><p><span class="math inline">map(S,f)</span>, apply <span class="math inline">f</span> to every entry in the sequence. So <span class="math inline">S</span> would represent <span class="math inline">f(a_1),\ldots,f(a_n)</span>. This operation takes <span class="math inline">O(1)</span> time.</p></li>
</ol>
<p>There is one operation <span class="math inline">Empty()</span> that produce an empty sequence.</p>
<p>We have to first make a few assumptions: All monoid operations take <span class="math inline">O(1)</span> time. All map we consider can be evaluated in <span class="math inline">O(1)</span> time AND we can compute <span class="math inline">h = f\circ g</span> in <span class="math inline">O(1)</span> time. Note this means we compute (a representation) of the function <span class="math inline">h</span> itself, and we can use this representation to compute <span class="math inline">h(x)</span> in <span class="math inline">O(1)</span> time.</p>
<p>Otherwise, all &quot;<span class="math inline">O(T)</span> time&quot; should be replaced with &quot;<span class="math inline">O(T)</span> monoid operation, function evaluation, function composition and constant time operations.&quot;.</p>
<p>Such data structure exists. The first <span class="math inline">3</span> operation are supported by finger tree <span class="citation" data-cites="Hinze2006">[<a href="#ref-Hinze2006">1</a>]</span>. It is not hard to add the last operation, the idea is to tag nodes with an function <span class="math inline">f</span>(in the beginning <span class="math inline">f</span> is just the identity), and it means &quot;apply <span class="math inline">f</span> to everything below!&quot;. It propagate only when the lower level nodes need to be accessed, therefore the cost would be charged into the other operations. Many other binary search trees probably can implement these operations too. For example, if the dynamic optimality conjecture for splay tree is true, it be best to use splay tree for implementation. However, that's beside the point. The point is to have an abstract data structure over a monoid sequence. The abstraction deals away with all the mess hidden by the data structure.</p>
<h1 id="extend-its-power"><span class="header-section-number">2</span> Extend its power</h1>
<p>Finger tree can be extended to query elements by giving indices of the element: take the Cartesian product of the monoid and <span class="math inline">(\N,+)</span>, and we get a new monoid. So we can just assume our data structure has the following extensions:</p>
<ol type="1">
<li><p><span class="math inline">splitAt(S,i)</span>, split the sequence to two sequence <span class="math inline">A</span> and <span class="math inline">B</span> at the <span class="math inline">i</span>th index in <span class="math inline">O(\log \min(n,n-i))</span> time.</p></li>
<li><p><span class="math inline">insertAt(S,i, x)</span>, insert element to the <span class="math inline">i</span>th position.</p></li>
<li><p><span class="math inline">delete(S,i)</span>, delete the element at <span class="math inline">i</span>th position.</p></li>
</ol>
<p>Another interesting extension is allowing one to <span class="math inline">reverse(S)</span> the sequence in <span class="math inline">O(\log n)</span> time. This become much more complicated.</p>
<h1 id="application"><span class="header-section-number">3</span> Application</h1>
<p>There are some common application of finger trees.</p>
<ol type="1">
<li><p>Stack, queue, dequeue with product operation, all amortized constant time. As a special case, it would solve the <a href="http://www.geeksforgeeks.org/design-and-implement-special-stack-data-structure/">min stack problem</a>.</p></li>
<li><p>Random access sequence, which is related to the <a href="http://en.wikipedia.org/wiki/Rope_%28data_structure%29">rope</a> data structure.</p></li>
<li><p>Ordered sequence(sorted list).</p></li>
<li><p>Priority queues.</p></li>
<li><p>Interval trees, segment trees.</p></li>
</ol>
<p>Most of the above has been described in <span class="citation" data-cites="Hinze2006">[<a href="#ref-Hinze2006">1</a>]</span>, but we will talk about two specifics that usually not mentioned by others.</p>
<h2 id="merge-sorted-lists-in-optimal-time-bound"><span class="header-section-number">3.1</span> Merge sorted lists in optimal time bound</h2>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>If <span class="math inline">S</span> and <span class="math inline">T</span> are two ordered sequences of length <span class="math inline">n</span> and <span class="math inline">m</span>, respectively. <span class="math inline">n\leq m</span>. Both ordered sequences are represented by finger trees. Compute the finger tree representation of <span class="math inline">S\cup T</span> takes <span class="math inline">O(n\log \frac{m}{n})</span> time.</p>
</section>
<p>Split <span class="math inline">T</span> into <span class="math inline">n</span> pieces one by one by split along the <span class="math inline">i</span>th element of <span class="math inline">S</span> to the second part of the <span class="math inline">i</span>th produced piece for all <span class="math inline">i</span>, then concatenate all of them. The splitting takes <span class="math inline">\sum_{i=1}^n \log t_i</span> time, where <span class="math inline">t_i</span> is the size of the <span class="math inline">i</span>th piece. By concavity, we have the time for split is <span class="math inline">\sum_{i=1}^n \log t_i \leq n \log \frac{m}{n}</span>, and concatenation time is similar.</p>
<h2 id="solve-the-klees-measure-problem"><span class="header-section-number">3.2</span> Solve the Klee's measure problem</h2>
<p>This section shows how the map operation is quite crucial because we can make <em>range updates</em>.</p>
<p>The motivation came from the following question. Can finger tree substitute for the <a href="http://letuskode.blogspot.com/2013/01/segtrees.html">popular competitive programming data structure segment tree</a>, a special case of the real <a href="http://en.wikipedia.org/wiki/Segment_tree">segment tree</a>? This is not possible, and it's not because the large hidden constants. The abstract definition in this article goes cannot do the following common operation on an sequence of integers: increment the <span class="math inline">i</span>th number by <span class="math inline">i</span>. This operation make little sense if we allow insert and deletions, but many use of segment tree do not consider insert and deletes.</p>
<p>Fortunately, <a href="http://en.wikipedia.org/wiki/Klee%27s_measure_problem">Klee's measure problem</a>, the problem that caused the invention of segment tree can be solved with a finger tree. We show how to solve it in 1D. It's well known how to <a href="http://cstheory.stackexchange.com/questions/17252/number-of-maximum-overlap-in-n-dimensions/17374">use it for solving the <span class="math inline">n</span>D version</a>.</p>
<p>We produce another data structure, such that each operation takes <span class="math inline">O(\log n)</span> amortized time. Where <span class="math inline">n</span> is the number of times we called insert.</p>
<p>We maintain a collection of intervals with data structure <span class="math inline">D</span>, there are 3 operations.</p>
<ol type="1">
<li><span class="math inline">insert(D,a,b)</span>, insert interval <span class="math inline">(a,b)</span> into the collection.</li>
<li><span class="math inline">delete(D,a,b)</span>. Delete a interval <span class="math inline">(a,b)</span> from the collection, we assume it's always a interval inserted before.</li>
<li><span class="math inline">measure(D)</span>. Find the measure of the union of all intervals in the collection.</li>
</ol>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>It can be sharpened such that <span class="math inline">n</span> is the number of intervals inside the data structure. We just do a global rebuild if the number of interval doubled or reduced to half since the last global update. Also, <span class="math inline">measure()</span> actually only take constant time.</p>
</section>
<p>The finger tree stores a sequence of elementary intervals that partitions the space, and how many copies of that interval exists. Thus we can represent it as <span class="math inline">((l,r),c)</span>, where <span class="math inline">(l,r)</span> is the elementary interval with left and right boundary, and <span class="math inline">c</span> is the number of copies.</p>
<p>To insert a interval, consider it's left point <span class="math inline">l</span>. The data structure find a elementary interval contains <span class="math inline">l</span>, and split it into two elementary intervals. Similarly, we do the same with the right endpoint. This takes <span class="math inline">O(\log n)</span> time, and we increase the number of elementary intervals by at most <span class="math inline">2</span>. <span class="math inline">increment</span> is an automorphism defined as <span class="math inline">increment(((a,b),c))=((a,b),c+1)</span>. For each insertion of interval <span class="math inline">(a,b)</span>, <span class="math inline">increment</span> gets applied to all elementary interval in the range. For deletion, we apply <span class="math inline">decrement = increment^{-1}</span> instead.</p>
<p>The monoid product is simply <span class="math inline">\prod_{i=1}^n ( (l_i, r_i),c) = \sum_{i=1}^n \min(c,1)(r_i-l_i)</span>, and this is exactly what <span class="math inline">measure(D)</span> should output.</p>
<h2 id="the-local-ranking-sequence"><span class="header-section-number">3.3</span> The local ranking sequence</h2>
<p>The ranking sequence of a sequence of distinct numbers <span class="math inline">a_1,\ldots,a_n</span> is defined as <span class="math inline">b_1,\ldots,b_n</span>, where <span class="math inline">a_i</span> is the <span class="math inline">b_i</span>th smallest element. Given a sequence of unique integers <span class="math inline">a_1,\ldots,a_n</span>, we want to design a data structure to query <span class="math inline">Q(i,j)</span>, which returns the ranking sequence of <span class="math inline">a_i,\ldots,a_j</span>.</p>
<p>This can be solved by storing sorted subsequences. We just have to return sorted sequence of <span class="math inline">a_i,\ldots,a_j</span> during the query, and then it become simple to figure out the ranking sequence. This will make sure the running time for <span class="math inline">Q(i,j)</span> to be <span class="math inline">O(j-i)</span>. There are a few other variants, but seems quite hard to adopt a finger tree for <span class="citation" data-cites="Chang2012517">[<a href="#ref-Chang2012517">2</a>]</span>.</p>
<h1 id="reference" class="unnumbered">Reference</h1>
<div id="refs" class="references">
<div id="ref-Hinze2006">
<p>[1] R. Hinze, R. Paterson, <strong>Finger trees: A simple general-purpose data structure</strong>, J. Funct. Program. 16 (2006) 197–217 <a href="https://doi.org/10.1017/S0956796805005769">10.1017/S0956796805005769</a>.</p>
</div>
<div id="ref-Chang2012517">
<p>[2] C.-J. Chang, K.-M. Chao, <strong>Efficient algorithms for local ranking</strong>, Information Processing Letters. 112 (2012) 517–522 <a href="https://doi.org/10.1016/j.ipl.2012.03.011">10.1016/j.ipl.2012.03.011</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-11-22. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Sat, 22 Nov 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-11-22-applications-of-finger-tree.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Speed up incremental computation with two stacks</title>
    <link>https://chaoxuprime.com/blog/posts/2014-11-15-speedup-incremental-computation-with-two-stacks.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Consider a knapsack of capacity <span class="math inline">C</span> and a empty sequence of objects. One can update the sequence by add or delete objects from either end of the sequence. Construct a data structure, such that we can output the maximum possible value of the knapsack after every update if we pack the knapsack using the objects in the sequence.</p>
</section>
<p>This is a generalization of the <a href="http://codeforces.com/blog/entry/14366">online knapsack problem</a>, which is an generalization of a hard <a href="https://www.hackerrank.com/contests/cs-quora/challenges/quora-feed-optimizer">offline knapsack problem</a> used by Quora.</p>
<p>A naive algorithm just recompute the knapsack each time using a dynamic programming algorithm. This would take <span class="math inline">O(mnC)</span> time, where <span class="math inline">m</span> is the total number of updates, <span class="math inline">n</span> is the maximum number of objects in the sequence. The rest of the article describe the idea of decomposable function, which lead to an solution that solves this problem in <span class="math inline">O(mC)</span> time.</p>
<h1 id="decomposable-function"><span class="header-section-number">2</span> Decomposable function</h1>
<section class="theorem-environment Definition" id="Definition-2">
<span class="theorem-header"><span class="type">Definition</span><span class="index">2</span></span>
<p>A function <span class="math inline">f:\cup_{i=1}^\infty X^i \to Y</span> is called <span class="math inline">(\triangleright,\bowtie,\triangleleft)</span>-decomposable, if for all <span class="math inline">1 \leq k \leq n</span>, <span class="math display">\displaystyle 
f(x_1,\ldots,x_n)=(x_1 \triangleright \ldots \triangleright x_k \triangleright id_{\triangleright}) \bowtie (id_{\triangleleft} \triangleleft x_{k+1}\triangleleft \ldots \triangleleft x_n)
</span> where</p>
<ol type="1">
<li><span class="math inline">\triangleright:X\times Y_{\triangleright}\to Y_{\triangleright}</span> is right associative.</li>
<li><span class="math inline">\triangleleft:Y_{\triangleleft} \times X\to Y_{\triangleleft}</span> is left associative.</li>
<li><span class="math inline">\bowtie:Y_{\triangleright}\times Y_{\triangleleft}\to Y</span>.</li>
</ol>
</section>
<section class="theorem-environment Problem" id="Problem-3">
<span class="theorem-header"><span class="type">Problem</span><span class="index">3</span></span>
<p>Let <span class="math inline">f</span> be a <span class="math inline">(\triangleright,\bowtie,\triangleleft)</span>-decomposable function. Let <span class="math inline">S</span> be a finite sequence of elements, such that <span class="math inline">S</span> is in the domain of <span class="math inline">f</span>. Dynamically output <span class="math inline">f(S)</span> after every deque operation on <span class="math inline">S</span>, such that we call <span class="math inline">\triangleright,\bowtie</span> and <span class="math inline">\triangleleft</span> amortized constant number of times per operation.</p>
</section>
<p>We will use <span class="math inline">\bigtriangleright_{i=1}^n x_i</span> to mean <span class="math inline">x_1 \triangleright \ldots \triangleright x_n \triangleright id_{\triangleright}</span>, and <span class="math inline">\bigtriangleleft_{i=1}^n x_i</span> to mean <span class="math inline">id_{\triangleright} \triangleleft x_1 \triangleleft \ldots \triangleleft x_n</span>.</p>
<p><span class="math inline">f</span> is called decomposable if there exist <span class="math inline">(\triangleright,\bowtie,\triangleleft)</span> such that it's decomposable.</p>
<p>The intuition is the function <span class="math inline">f</span> can be decomposed into solving two pieces of problems. Each piece of the problem has a incremental nature.</p>
<p><span class="math inline">D_C(x_1,\ldots,x_n)</span>, the maximum value possible given objects <span class="math inline">x_1,\ldots,x_n</span> and a knapsack of capacity <span class="math inline">C</span> is a decomposable function. If <span class="math inline">x_1\triangleright \ldots \triangleright x_n</span> produces the last row of the common dynamic programming algorithm for the knapsack, then we can let <span class="math inline">\bowtie</span> to be an operation that combine the last rows to output a value.</p>
<h1 id="implement-the-data-structure"><span class="header-section-number">3</span> Implement the data structure</h1>
<p>Intuitively, <span class="math inline">\triangleright</span> and <span class="math inline">\triangleleft</span> produces two stacks. <span class="math inline">\bowtie</span> combines the information on the stack to produce the solution to <span class="math inline">f</span>.</p>
<h2 id="triangleleft-a-stack"><span class="header-section-number">3.1</span> <span class="math inline">\triangleleft</span>, a stack</h2>
<section class="theorem-environment Problem" id="Problem-4">
<span class="theorem-header"><span class="type">Problem</span><span class="index">4</span></span>
<p>We have a stack of elements <span class="math inline">S</span>, dynamically maintain <span class="math inline">foldl \triangleleft</span> in <span class="math inline">O(1)</span> <span class="math inline">\triangleleft</span> per operation.</p>
</section>
<p>Say <span class="math inline">S=x_1,\ldots,x_n</span>. We store <span class="math inline">\bigtriangleleft_{i=1}^k x_i</span> for all <span class="math inline">1\leq k\leq n</span>, and whenever there is an insertion, we compute <span class="math inline">\bigtriangleleft_{i=1}^{n+1} x_i = \bigtriangleleft_{i=1}^n x_i \triangleleft x_{n+1}</span> in one monoid operation. Deletion can be handled by discarding a value. In the worst case, <span class="math inline">\triangleleft</span> gets called only once.</p>
<p>But this requires us to store <span class="math inline">O(n)</span> values after the fold. We can decrease the extra space to store only <span class="math inline">O(\sqrt{n})</span> prefix sums.</p>
<p>Let <span class="math inline">S(k) = \bigtriangleleft_{i=1}^k x_i</span>. Originally we store <span class="math inline">S(k)</span> for all <span class="math inline">1 \leq k\leq n</span>. We show how we store only when <span class="math inline">k</span> is a perfect square and around <span class="math inline">\sqrt{n}</span> other elements. If <span class="math inline">k^2\leq n&lt;(k+1)^2</span>, we make sure we store <span class="math inline">S(i)</span> for all <span class="math inline">i</span> between <span class="math inline">k^2</span> and <span class="math inline">n</span>, and do not store any non perfect square <span class="math inline">i</span> smaller than <span class="math inline">(k-1)^2</span>(this means we actively clean them up as <span class="math inline">n</span> grows large). Assume we are deleting, we can delete around <span class="math inline">\sqrt{n}</span> elements before we hit a perfect square, in that case we would need to recompute the sums from the previous perfect square. It's not hard to see some amortized analysis, the extra space can be made into <span class="math inline">O(\sqrt{n})</span>.</p>
<p>Actually, there is a entire range of space/time trade-offs possible. <span class="math inline">O(1/\epsilon)</span> amortized time per operation and <span class="math inline">O(n^{\epsilon})</span> extra space <span class="citation" data-cites="swamy1983">[<a href="#ref-swamy1983">1</a>]</span>.</p>
<h2 id="bowtie-combine-two-stacks-to-simulate-a-deque"><span class="header-section-number">3.2</span> <span class="math inline">\bowtie</span>, combine two stacks to simulate a deque</h2>
<p>First, let's consider we are allowed to add on both side of the sequence, but deletion is only at the beginning of the sequence.</p>
<p>The idea is to build this through two stacks. This is a very common problem, and we can see the <a href="http://www.cs.cmu.edu/afs/cs/academic/class/15750-s01/www/notes/lect0123">solutions here</a>. One thing to remember is that the left stack uses <span class="math inline">\triangleright</span>, the right stack uses <span class="math inline">\triangleleft</span>.</p>
<p>We can try to simulate the deque with 3 stacks(where <span class="math inline">n</span> deque operation maps to <span class="math inline">9n</span> stack operations) <span class="citation" data-cites="Petersen2001">[<a href="#ref-Petersen2001">2</a>]</span>, but that is just an interesting exercise. We just need to use our two stack set up as in the queue and occasionally rebuild everything. When our front stack become empty and we remove an element in front of our sequence, we just rebuild the structure with two stacks of the same size. There are ways to do the rebuilding without use extra space. The case on the other side is handled symmetrically. Therefore we still maintain <span class="math inline">O(1)</span> amortized monoid time per operation and <span class="math inline">O(\sqrt{n})</span> extra space. Finally, we combine the result through <span class="math inline">\bowtie</span>.</p>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>There exist worst case constant time simulation of deque using a few stacks <span class="citation" data-cites="Petersen2001">[<a href="#ref-Petersen2001">2</a>]</span>. Thus it is conceivable to make everything from amortized to worst case, with obvious increase in space.</p>
</section>
<h1 id="examples"><span class="header-section-number">4</span> Examples</h1>
<p>I have the code sample for the entire <a href="https://gist.github.com/chaoxu/8c63f1c7e464f26053e6">framework</a> along with the examples. There are only <span class="math inline">6</span> functions.</p>
<p><code>emptyDecomposableDequeue</code> initialize the data structure with the corresponding functions. <code>pushFront</code>, <code>pushBack</code>, <code>popFront</code> and <code>popBack</code> manipulates the sequences. <code>measure</code> returns the result after apply our decomposable function to the sequence.</p>
<h2 id="knapsack"><span class="header-section-number">4.1</span> Knapsack</h2>
<p>Our common dynamic programming formulation is to sequentially compute tables <span class="math inline">D_S</span>, such that <span class="math inline">D_S[C]</span> contains the maximum value picking objects from <span class="math inline">S</span> with knapsack capacity <span class="math inline">C</span>.</p>
<p>Usually, we order the objects as <span class="math inline">x_1,\ldots,x_n</span>, and <span class="math inline">S_i=\{x_1,\ldots,x_i\}</span>. We compute table <span class="math inline">D_{S_{i+1}}</span> from <span class="math inline">D_{S_i}</span> in <span class="math inline">O(C)</span> time. This should be the operation for <span class="math inline">\triangleright</span> and <span class="math inline">\triangleleft</span>. To get the particular entry <span class="math inline">D_{S\cup T}[C]</span>, <span class="math inline">O(C)</span> time suffice if we are given table for <span class="math inline">D_S</span> and <span class="math inline">D_T</span>. This would be the <span class="math inline">\bowtie</span> operation.</p>
<p>This implies if the sequence size is at most <span class="math inline">n</span>, then for any sequence of <span class="math inline">m</span> operations, we can dynamically compute all <span class="math inline">f</span> in <span class="math inline">O(mC)</span> time using only <span class="math inline">O(\sqrt{n}C)</span> space. Notice once we convert the general algorithm to work in this special case, it is essentially the <a href="http://codeforces.com/blog/entry/14366#comment-193779">solution by Lei Huang</a>. In fact, this general data structure is inspired by his solution.</p>
<h2 id="maximum-subarray-sum"><span class="header-section-number">4.2</span> Maximum subarray sum</h2>
<p>The common dynamic programming problem of finding the maximum sum in an array(or, here we consider as a sequence) with both negative and positive numbers. One can compute it in linear time with Kadane's algorithm. This is a decomposable function, too.</p>
<p>Let <span class="math inline">\bigtriangleright_{i=j}^k x_i=(a,b,c,d)</span>, where <span class="math inline">a</span> is the maximum sum using the beginning, <span class="math inline">b</span> is the sum of all elements from the beginning, <span class="math inline">c</span> is the maximum using the current element and <span class="math inline">d</span> is the maximum seen so far. <span class="math inline">\triangleleft</span> is defined similarly. One can see that <span class="math inline">(a,b,c,d&#39;)\bowtie (a&#39;,b&#39;,c&#39;,d&#39;) = \max(a+a&#39;,d,d&#39;)</span>.</p>
<h2 id="dynamic-sum-of-a-sequence-of-elements"><span class="header-section-number">4.3</span> Dynamic sum of a sequence of elements</h2>
<section class="theorem-environment Problem" id="Problem-5">
<span class="theorem-header"><span class="type">Problem</span><span class="index">5</span></span>
<p>Let <span class="math inline">x_1,\ldots,x_n</span> be a finite sequence of elements from a monoid <span class="math inline">(M,+)</span>. Dynamically maintain the sum of all element in the sequence if we can add and delete element in both end of the sequence.</p>
</section>
<p>A simpler version of this problem is asked in <a href="http://cstheory.stackexchange.com/questions/18655/maintaining-the-product-of-a-queue-of-semigroup-elements/">CS theory</a>, where we are allowed to add in one end and delete in another.</p>
<p>Let <span class="math inline">f</span> be the sum of elements in the sequence, then <span class="math inline">f</span> is <span class="math inline">(+,+,+)</span>-decomposable. There is a more general statement:</p>
<section class="theorem-environment Theorem" id="Theorem-6">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">6</span></span>
<p><span class="math inline">f</span> is a homomorphism, then it is decomposable.</p>
</section>
<p>Of course, there is already a data structure support this--a finger tree <span class="citation" data-cites="Hinze2006">[<a href="#ref-Hinze2006">3</a>]</span>. Because of the monoid structure, we can even allow concatenations.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-swamy1983">
<p>[1] S. Swamy, J. Savage, <strong>Space-time tradeoffs for linear recursion</strong>, Mathematical Systems Theory. 16 (1983) 9–27 <a href="https://doi.org/10.1007/BF01744566">10.1007/BF01744566</a>.</p>
</div>
<div id="ref-Petersen2001">
<p>[2] H. Petersen, Stacks versus deques, in: J. Wang (Ed.), Computing and Combinatorics, Springer Berlin Heidelberg, 2001: pp. 218–227 <a href="https://doi.org/10.1007/3-540-44679-6_24">10.1007/3-540-44679-6_24</a>.</p>
</div>
<div id="ref-Hinze2006">
<p>[3] R. Hinze, R. Paterson, <strong>Finger trees: A simple general-purpose data structure</strong>, J. Funct. Program. 16 (2006) 197–217 <a href="https://doi.org/10.1017/S0956796805005769">10.1017/S0956796805005769</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-11-15. </div>
    <div class="info">Tags: algorithmic toolkit.</div>

</div>]]></description>
    <pubDate>Sat, 15 Nov 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-11-15-speedup-incremental-computation-with-two-stacks.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Number of edges in acyclic flow</title>
    <link>https://chaoxuprime.com/blog/posts/2014-11-11-number-of-edges-in-acyclic-flow.html</link>
    <description><![CDATA[<br />
<div>
<p>The graph in this post are simple graphs with unit edge capacity.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span><span class="name">Main Theorem</span></span>
<p>Let <span class="math inline">G=(V,E)</span> be a graph with <span class="math inline">n</span> vertices and <span class="math inline">m</span> edges, then an acyclic integer flow of value <span class="math inline">v</span> saturates <span class="math inline">O(n\sqrt{v})</span> edges.</p>
</section>
<p>Everything here is in the Karger and Levine's paper<span class="citation" data-cites="Karger1998">[<a href="#ref-Karger1998">1</a>]</span>, I'm writing this down for my own sake.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Let <span class="math inline">d</span> to be the distance of the shortest path between <span class="math inline">s</span> and <span class="math inline">t</span>. Let <span class="math inline">v</span> to be the value of a <span class="math inline">s</span>-<span class="math inline">t</span>-flow, then <span class="math inline">v\leq 2(n/d)^2</span> and <span class="math inline">v\leq 2 m/d</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">V_i</span> to be the set of vertices with distance exactly <span class="math inline">i</span> from <span class="math inline">s</span>. The maximum flow is clearly bounded by <span class="math inline">|V_i||V_{i+1}|</span>, as all flows has to go in between the two levels and the maximum number of edges in between happens when it is a complete bipartite graph. Notice in order to maximize this value, we have <span class="math inline">|V_i|=n/d</span>. Hence <span class="math inline">v\leq 2(n/d)^2</span>. Similarly, we can also distribute the number of edges in between every two partitions, and get <span class="math inline">v\leq 2m/d</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>If we take shortest augmenting path successively in the residual graph to find a flow of value <span class="math inline">v</span>, then we saturate <span class="math inline">O(n\sqrt{v})</span> edges.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math inline">v\leq 2(n/d)^2</span>, thus <span class="math inline">d\leq n\sqrt{2}/\sqrt{v}</span>. If we take the shortest path successively, we have the number of edges we use in each augmenting path is</p>
<p><span class="math display">\displaystyle 
	\sum_{i=1}^v n\sqrt{2}/\sqrt{i} = O(n\sqrt{v})
</span></p>
</section>
<p>For the above theorem, one might ask what happens if we use <span class="math inline">v\leq 2m/d</span> inequality instead. Then we get the sum of the length of all the augmenting paths we ever route is <span class="math inline">O(m\log m)</span>, pretty neat.</p>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span><span class="name">Main theorem</span></span>
<p>Let <span class="math inline">f</span> be an acyclic flow of value <span class="math inline">v</span> in <span class="math inline">G</span>. Remove all edges outside <span class="math inline">f</span>, and let the remaining graph be <span class="math inline">G&#39;</span>. Consider use shortest augmenting path algorithm sending a flow of value <span class="math inline">v</span> in <span class="math inline">G&#39;</span>. Notice this would produce <span class="math inline">f</span>. Thus this shows <span class="math inline">f</span> has <span class="math inline">O(n\sqrt{v})</span> edges.</p>
</section>
<section class="theorem-environment Corollary" id="Corollary-4">
<span class="theorem-header"><span class="type">Corollary</span><span class="index">4</span></span>
<p>Let <span class="math inline">G</span> be a simple graph on <span class="math inline">n</span> vertices. There exist <span class="math inline">\lambda(s,t)</span> <span class="math inline">st</span>-edge disjoint paths, such that the <span class="math inline">k</span> shortest paths has total of <span class="math inline">O(\sqrt{k}n)</span> edges for all <span class="math inline">k\leq \lambda(s,t)</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>There exist <span class="math inline">\lambda(s,t)</span> <span class="math inline">st</span>-edge disjoint paths with total length <span class="math inline">O(\sqrt{\lambda(s,t)}n)</span>. The average length is <span class="math inline">O(\frac{n}{\sqrt{\lambda(s,t)}})</span>. The <span class="math inline">k</span> shortest paths has total length <span class="math inline">O(k\frac{n}{\sqrt{\lambda(s,t)}})=O(k\frac{n}{\sqrt{k}}) = O(\sqrt{k}n)</span>.</p>
</section>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Karger1998">
<p>[1] D.R. Karger, M.S. Levine, <strong>Finding maximum flows in undirected graphs seems easier than bipartite matching</strong>, Proceedings of the Thirtieth Annual ACM Symposium on Theory of Computing - STOC ’98. (1998) 69–78 <a href="https://doi.org/10.1145/276698.276714">10.1145/276698.276714</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-11-11. </div>
    <div class="info">Tags: Flow.</div>

</div>]]></description>
    <pubDate>Tue, 11 Nov 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-11-11-number-of-edges-in-acyclic-flow.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Isotonic function preserving grid in <span class="math inline">[0,1]</span></title>
    <link>https://chaoxuprime.com/blog/posts/2014-11-04-isotonic-function-preserving-grid-in-1d.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Definition" id="Definition-1">
<span class="theorem-header"><span class="type">Definition</span><span class="index">1</span></span>
<p>A function <span class="math inline">\varphi:X\to Y</span> is isotonic if <span class="math inline">\|x-y\| &lt; \|w-z\| \implies \|\varphi(x)-\varphi(y)\| &lt; \|\varphi(w)-\varphi(z)\|</span> for all <span class="math inline">x,y,z,w\in X</span>.</p>
</section>
<p>A sequence of points <span class="math inline">x_0,x_1,\ldots,x_n</span> is called <span class="math inline">\delta</span>-grid if <span class="math inline">\delta&lt;\frac{1}{5n}</span>, <span class="math inline">x_0=0</span>, <span class="math inline">x_n=1</span> and for all <span class="math inline">1 \leq i\leq n-1</span>, we have <span class="math inline">x_i-x_{i-1} \in (\frac{1}{n}-\frac{\delta}{2^{i-1}},\frac{1}{n}-\frac{\delta}{2^i})</span>. Note this imply <span class="math inline">x_n-x_{n-1}&gt;\frac{1}{n}</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Let <span class="math inline">X</span> be a <span class="math inline">\delta</span>-grid of <span class="math inline">n</span> points where <span class="math inline">\delta&lt;2^{-n}</span>. <span class="math inline">\varphi: X\to [0,1]</span> is a isotonic function such that <span class="math inline">\varphi(0)=0</span> and <span class="math inline">\varphi(1)=1</span>, then <span class="math inline">|x_i - \varphi(x_i)|&lt;1/n</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>It's easy to see that <span class="math inline">\varphi</span> is a increasing function. Let the points in <span class="math inline">X</span> ordered as <span class="math inline">x_0,x_1,\ldots,x_n</span>. Let <span class="math inline">l_i = |\varphi(x_i)-\varphi(x_{i-1})|</span>. Note that</p>
<ol type="1">
<li><p><span class="math display">\displaystyle 
\sum_{i=1}^n l_i = 1
</span></p></li>
<li><p><span class="math display">\displaystyle |x_i-x_{i-1}|&lt;\frac{1}{n}-\frac{\delta}{2^i}&lt;|x_{i+1}-x_i|</span> thus by isotonic function <span class="math display">\displaystyle |\varphi(x_i)-\varphi(x_{i-1})|&lt;|\varphi(x_{i+1})-\varphi(x_i)|</span>. This is just <span class="math inline">l_i&lt;l_{i+1}</span>.</p></li>
<li><p><span class="math inline">\sum_{i=1}^{m} l_i &gt; \sum_{i=n-(m-2)}^{n} l_i</span> for all <span class="math inline">m</span>, because <span class="math inline">\frac{m}{n}\geq |x_m-x_0| &gt; \frac{m}{n}-\delta &gt; \frac{m-1}{n}+2\delta&gt;|x_n - x_{n-(m-2)}|</span>, thus <span class="math display">\displaystyle |\varphi(x_m)-\varphi(x_{0})|&lt;|\varphi(x_{n})-\varphi(x_{n-(m-2)})|</span>.</p></li>
</ol>
<p>Combine the relations above, we have <span class="math display">\displaystyle 
	\frac{m}{n} \geq \sum_{i=1}^m l_i &gt; \sum_{i=n-(m-2)}^{n} l_i \geq \frac{m-1}{n}
</span></p>
<p>But <span class="math inline">\sum_{i=1}^m l_i = \varphi(x_m)</span>, so <span class="math inline">m/n\geq x_m&gt;m/n-\delta</span>, <span class="math inline">m/n\geq \varphi(x_m)&gt;(m-1)/n</span>. Since <span class="math inline">\delta</span> is small, we have <span class="math inline">|x_i-\varphi(x_i)|&lt;1/n</span>.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-11-04. </div>
    <div class="info">Tags: analysis.</div>

</div>]]></description>
    <pubDate>Tue, 04 Nov 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-11-04-isotonic-function-preserving-grid-in-1d.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Reducing edge connectivity to vertex connectivity with small increase in edges</title>
    <link>https://chaoxuprime.com/blog/posts/2014-10-30-reducing-edge-connectivity-to-vertex-connectivity-with-small-increas-in-edges.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Let <span class="math inline">G=(V,E)</span> be a graph, we are interested in finding a graph <span class="math inline">G&#39;=(V&#39;,E&#39;)</span>, such that <span class="math inline">G</span> is a minor of <span class="math inline">G&#39;</span>. We want a partition <span class="math inline">P</span> of <span class="math inline">V&#39;</span> and a bijection <span class="math inline">f:P\to V</span>, such that for any <span class="math inline">s\in S</span>, <span class="math inline">t\in T</span> and <span class="math inline">S,T\in P</span>, we have <span class="math inline">\kappa_{G&#39;}(s,t) = \lambda_{G}(f(S),f(T))</span>.</p>
</section>
<p>Although there is rarely a reason to reduce edge connectivity computation to vertex connectivity computation, because vertex connectivity is much harder in almost every way. It is still a interesting exercise.</p>
<p>The naive method: For each vertex <span class="math inline">v</span>, expand it into a clique of size <span class="math inline">deg(v)</span>, and find a bijective label between new vertex in the clique with the edges incident to <span class="math inline">v</span>. Connect all the vertices with the same label. Thus in the worst case, we can loosely bound the edges in <span class="math inline">G&#39;</span> to be <span class="math inline">\sum_{v} deg^2(v)\leq \sum_{v} (m/n)^2 = m^2/n = O(nm)</span>.</p>
<p>There is another way with the edge blow up to be <span class="math inline">O(nm)</span> <span class="citation" data-cites="Galil:1991:REC:122413.122416">[<a href="#ref-Galil:1991:REC:122413.122416">1</a>]</span>.</p>
<p>However, we want to blow up the number of edges by at most <span class="math inline">O(m)</span>.</p>
<section class="theorem-environment Definition" id="Definition-2">
<span class="theorem-header"><span class="type">Definition</span><span class="index">2</span></span>
<p>A <span class="math inline">n</span>-connector is a graph with two disjoint set of vertices <span class="math inline">I</span> (inputs) and <span class="math inline">O</span> (outputs) such that <span class="math inline">|I|=|O|=n</span>, and for any bijection <span class="math inline">f:I\to O</span>, there exist vertex disjoint paths connecting <span class="math inline">v</span> and <span class="math inline">f(v)</span> simultaneously.</p>
</section>
<p>It is known a <span class="math inline">n</span>-connector exists with <span class="math inline">O(n)</span> edges, because there is a even stronger notion of <span class="math inline">n</span>-nonblocking graph<span class="citation" data-cites="BLTJ:BLTJ2972">[<a href="#ref-BLTJ:BLTJ2972">2</a>]</span>.</p>
<p><span class="math inline">n</span>-connector seems to be what we need here, but it forces us to have input and output vertices. Thus we can define the following.</p>
<section class="theorem-environment Definition" id="Definition-3">
<span class="theorem-header"><span class="type">Definition</span><span class="index">3</span></span>
<p>A <span class="math inline">n</span>-symmetric-connector is a graph with a set of <span class="math inline">n</span> vertices <span class="math inline">T</span>, such that for any <span class="math inline">f</span> a bijection between two disjoint subsets of <span class="math inline">T</span>, there exist vertex disjoint paths connecting <span class="math inline">v</span> and <span class="math inline">f(v)</span> simultaneously.</p>
</section>
<p>Let <span class="math inline">G</span> be a <span class="math inline">n</span>-connected with inputs <span class="math inline">I</span> and outputs <span class="math inline">O</span>, we construct a <span class="math inline">n</span>-symmetric connector by make a copy of <span class="math inline">O</span> as <span class="math inline">O&#39;</span>, maintaining the edges of the copies too. Then we pick <span class="math inline">f</span> any bijection between <span class="math inline">I</span> and <span class="math inline">O</span>, and contract <span class="math inline">v</span> and <span class="math inline">f(v)</span> into one vertex. The contracted vertex will be the set <span class="math inline">T</span>, and the new graph is a <span class="math inline">n</span>-symmetric-connector.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Galil:1991:REC:122413.122416">
<p>[1] Z. Galil, G.F. Italiano, <strong>Reducing edge connectivity to vertex connectivity</strong>, SIGACT News. 22 (1991) 57–61 <a href="https://doi.org/10.1145/122413.122416">10.1145/122413.122416</a>.</p>
</div>
<div id="ref-BLTJ:BLTJ2972">
<p>[2] F.R.K. Chung, <strong>On concentrators, superconcentrators, generalizers, and nonblocking networks</strong>, Bell System Technical Journal. 58 (1979) 1765–1777 <a href="https://doi.org/10.1002/j.1538-7305.1979.tb02972.x">10.1002/j.1538-7305.1979.tb02972.x</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-10-30. </div>
    <div class="info">Tags: connectivity.</div>

</div>]]></description>
    <pubDate>Thu, 30 Oct 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-10-30-reducing-edge-connectivity-to-vertex-connectivity-with-small-increas-in-edges.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Maximum sum <span class="math inline">k</span>-disjoint subarrays</title>
    <link>https://chaoxuprime.com/blog/posts/2014-10-13-maximum-sum-k-disjoint-subarrays.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>A common problem, the <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem">maximum subarray problem</a> asks the subarray with the maximum sum.</p>
<p>There are many generalizations, for example into higher dimensions. In 2D, a <span class="math inline">n\times n</span> matrix, a common solution takes <span class="math inline">O(n^3)</span> time<span class="citation" data-cites="TamakiT98 Takaoka02">[<a href="#ref-TamakiT98">1</a>,<a href="#ref-Takaoka02">2</a>]</span>. There is no <span class="math inline">O(n^{3-\e})</span> algorithm assuming All-Pairs Shortest Paths cannot be solved in <span class="math inline">O(n^{3-\e})</span> for some constant <span class="math inline">\e&gt;0</span> <span class="citation" data-cites="BackursDT16">[<a href="#ref-BackursDT16">3</a>]</span>.</p>
<p>Another way is to understand it as a graph problem. We are given a path, and there are weights on the vertices. We require a maximum weight connected subgraph. The problem is NP-hard even for planar graphs. However, it is solvable in polynomial time for bounded treewidth graphs <span class="citation" data-cites="Álvarez-MirandaLM13">[<a href="#ref-Álvarez-MirandaLM13">4</a>]</span>.</p>
<p>We consider a similar problem where instead of a single subarray, we want at most <span class="math inline">k</span> disjoint subarrays, such that the sum together is maximized. In fact, this is the <a href="http://www.lintcode.com/en/problem/maximum-subarray-iii/">Maximum Subarray III problem on LintCode</a>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Maximum <span class="math inline">k</span>-Disjoint Subarray Problem</span></span>
<p>Given array <span class="math inline">A[1..n]</span>, find a non-decreasing sequence of indices <span class="math inline">i_1,\ldots,i_{2k}</span>, such that <span class="math inline">\sum_{i=1}^k \sum_{j=i_{2i-1}}^{2i} A[j]</span> is maximized.</p>
</section>
<p>There is obviously an <span class="math inline">O(nk)</span> algorithm by extending the dynamic programming algorithm for the <span class="math inline">k=1</span> case.</p>
<h1 id="solutions"><span class="header-section-number">2</span> Solutions</h1>
<h2 id="dynamic-programming"><span class="header-section-number">2.1</span> Dynamic Programming</h2>
<p>Let <span class="math inline">f(i,k)</span> to be the maximum value obtainable by <span class="math inline">k</span> subarray of <span class="math inline">A[1..i]</span>. Let <span class="math inline">g(i,k)</span> to be the maximum value obtainable by <span class="math inline">k</span> subarray of <span class="math inline">A[1..i]</span>, that uses the <span class="math inline">i</span>th value in the last subarray. The recurrence <span class="math inline">f(i,k) = \min(f(i,k-1),f(i-1,k),g(i,k))</span>, and <span class="math inline">g(i,k) = \min(g(i-1,k)+A[i],f(i-1,k-1)+A[i])</span> solves the problem.</p>
<h2 id="greedy"><span class="header-section-number">2.2</span> Greedy</h2>
<p>This kind of solution would possibly work on interviews. But can we do better? It is in fact possible to get <span class="math inline">O(n\log n)</span> with some care.</p>
<p>wlog, let's assume the array is alternating, where all odd index are positive and all even index are negative. If we have the solution for the <span class="math inline">k</span> case, we can get a solution for <span class="math inline">k-1</span> case by either discard one of the arrays or &quot;merge&quot; two adjacent arrays by taking a negative piece in the middle.</p>
<p>This shows that once we have the solution for the <span class="math inline">k</span> case, we can just &quot;contract&quot; a entire subarray into one single value. Csűrös showed that we can just use one merge operation<span class="citation" data-cites="Csuros04">[<a href="#ref-Csuros04">5</a>]</span>. It find a array element with minimum absolute value, say it's <span class="math inline">A[i]</span>, then it is replaced by <span class="math inline">A[i-1]+A[i]+A[i+1]</span>, and then we remove <span class="math inline">A[i-1]</span> and <span class="math inline">A[i+1]</span> from the array. (For boundary cases, assume <span class="math inline">A[0]=A[n+1]=0</span>). The idea is a merge can &quot;discard&quot; a value, and a merge is also adding a negative piece and then do contraction. This operation is done until there are exactly <span class="math inline">k</span> positive numbers, which in that case, the best solution is to just take all <span class="math inline">k</span> of them.</p>
<p>Thus this implies a <span class="math inline">O(n\log n)</span> greedy algorithm, by keep merging and keep track of min absolute value item using a heap. Interestingly, this algorithm was also suggested by students in <a href="https://courses.engr.illinois.edu/cs473/">CS 473</a>. <a href="http://web.engr.illinois.edu/~hchang17/">Hsien-Chih</a> and I discovered it is correct by failing to find counterexamples to the greedy approach.</p>
<h2 id="speed-up-greedy"><span class="header-section-number">2.3</span> Speed up greedy</h2>
<p>One can see the smallest absolute value does not decrease throughout the algorithm, so instead of just keep finding and merging the item with smallest absolute value, what if one just keep merge merge item with absolute value smaller than <span class="math inline">t</span>? There are three possibilities: we picked <span class="math inline">t</span> so nicely that after all the merges, we get exactly <span class="math inline">k</span> positive elements left. We picked <span class="math inline">t</span> too large, we get less than <span class="math inline">k</span> positive elements. We picked <span class="math inline">t</span> too small, and we get more than <span class="math inline">k</span> positive elements.</p>
<p>Bengtsson and Chen uses this idea<span class="citation" data-cites="Bengtsson06">[<a href="#ref-Bengtsson06">6</a>]</span>. They showed they can guess <span class="math inline">t</span> in a way such that the some measure of the problem size gets smaller by at least <span class="math inline">2/3</span>, and also shows how to keep track of the merges so it takes <span class="math inline">O(n\alpha(n))</span> time. Later on, they removed the need of the union-find data structure improved the time bound to the optimal <span class="math inline">O(n)</span> time <span class="citation" data-cites="Bengtsson07">[<a href="#ref-Bengtsson07">7</a>]</span>.</p>
<h2 id="optimal-running-time-reducing-to-k1-queries"><span class="header-section-number">2.4</span> Optimal running time reducing to <span class="math inline">k=1</span> queries</h2>
<p>There are other approaches to obtain the same running time. We can consider a query version of the problem when <span class="math inline">k=1</span>. Given indices <span class="math inline">i</span> and <span class="math inline">j</span>, find indices <span class="math inline">i&#39;</span> and <span class="math inline">j&#39;</span> such that <span class="math inline">i\leq i&#39;\leq j&#39;\leq j</span>, and sum of the elements in <span class="math inline">A[i&#39;..j&#39;]</span> is maximized. Chen and Chao showed how to use a data structure that can be built in <span class="math inline">O(n)</span> time, and return the solution to the above query in <span class="math inline">O(1)</span> time <span class="citation" data-cites="ChenC07">[<a href="#ref-ChenC07">8</a>]</span>. It is not a simple data structure. Gawrychowski and Nicholson showed such data structure can be used to solve the <a href="#Problem-1">Problem 1</a> in <span class="math inline">O(n)</span> time <span class="citation" data-cites="GawrychowskiN15">[<a href="#ref-GawrychowskiN15">9</a>]</span>. The reduction is easy, but again the bottleneck is the heavy hammers to build the data structure.</p>
<h2 id="a-very-simple-solution"><span class="header-section-number">2.5</span> A very simple solution</h2>
<p>Recently, I've seen a truly simple result. A related problem is the following.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given array <span class="math inline">B[1..n]</span>, find a non-decreasing sequence of indices <span class="math inline">i_1,\ldots,i_{2k}</span>, such that <span class="math inline">\sum_{i=1}^k B[i_{2i}]-B[i_{2i-1}]</span> is maximized.</p>
</section>
<p>This problem is featured in interviews, and is also <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">on leetcode as Best time to buy an sell stock IV</a> and showed up in codeforces as <a href="http://codeforces.com/contest/391/problem/F3">stock trading</a>. <a href="#Problem-1">Problem 1</a> and <a href="#Problem-2">Problem 2</a> can be reduced to each other in linear time. For one direction, we can define <span class="math inline">B[i]=\sum_{j=1}^i A[j]</span>. The other direction, we let <span class="math inline">A[i]=B[i]-B[i-1]</span> for all <span class="math inline">i</span>. The editorial in codeforces showed <a href="http://codeforces.com/blog/entry/10727">a solution similar to <span class="citation" data-cites="Bengtsson07">[<a href="#ref-Bengtsson07">7</a>]</span></a> for <a href="#Problem-2">Problem 2</a>.</p>
<p>A surprising algorithm for <a href="#Problem-2">Problem 2</a> was found by <a href="https://zhiqingxiao.weebly.com">Zhiqing Xiao</a> that claims to solve the problem in <span class="math inline">O(n)</span> time by building upon the <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54118/C%2B%2B-Solution-with-O(n-%2B-klgn)-time-using-Max-Heap-and-Stack">observation of leetcode user yishiluo</a>. Hence it shows <a href="#Problem-1">Problem 1</a> can be solved in linear time, and the only (a bit) heavy hammer is the <a href="https://en.wikipedia.org/wiki/Selection_algorithm">selection algorithm</a>. Although the solution is simple, it is fairly unclear how to prove correctness. <a href="http://maskray.me">Fangrui Song</a> wrote <a href="http://maskray.me/blog/2015-03-27-leetcode-best-time-to-buy-and-sell-stock-iv">a better explanation</a> in Chinese. Although it still does not fully prove correctness, it is a step toward a proof.</p>
<h1 id="open-problem"><span class="header-section-number">3</span> Open problem</h1>
<p>Can we find a linear time algorithm for trees? (either weights on edges or on vertices)</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-TamakiT98">
<p>[1] H. Tamaki, T. Tokuyama, Algorithms for the maximum subarray problem based on matrix multiplication, in: Proceedings of the Ninth Annual Acm-Siam Symposium on Discrete Algorithms, Society for Industrial; Applied Mathematics, Philadelphia, PA, USA, 1998: pp. 446–452.</p>
</div>
<div id="ref-Takaoka02">
<p>[2] T. Takaoka, <strong>Efficient algorithms for the maximum subarray problem by distance matrix multiplication</strong>, Electronic Notes in Theoretical Computer Science. 61 (2002) 191–200 <a href="https://doi.org/https://doi.org/10.1016/S1571-0661(04)00313-5">https://doi.org/10.1016/S1571-0661(04)00313-5</a>.</p>
</div>
<div id="ref-BackursDT16">
<p>[3] A. Backurs, N. Dikkala, C. Tzamos, Tight Hardness Results for Maximum Weight Rectangles, in: I. Chatzigiannakis, M. Mitzenmacher, Y. Rabani, D. Sangiorgi (Eds.), 43rd International Colloquium on Automata, Languages, and Programming (Icalp 2016), Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany, 2016: pp. 81:1–81:13 <a href="https://doi.org/10.4230/LIPIcs.ICALP.2016.81">10.4230/LIPIcs.ICALP.2016.81</a>.</p>
</div>
<div id="ref-Álvarez-MirandaLM13">
<p>[4] E. Álvarez-Miranda, I. Ljubić, P. Mutzel, The maximum weight connected subgraph problem, in: M. Jünger, G. Reinelt (Eds.), Facets of Combinatorial Optimization: Festschrift for Martin Grötschel, Springer Berlin Heidelberg, Berlin, Heidelberg, 2013: pp. 245–270 <a href="https://doi.org/10.1007/978-3-642-38189-8_11">10.1007/978-3-642-38189-8_11</a>.</p>
</div>
<div id="ref-Csuros04">
<p>[5] M. Csürös, <strong>Maximum-scoring segment sets</strong>, IEEE/ACM Trans. Comput. Biology Bioinform. 1 (2004) 139–150 <a href="https://doi.org/10.1109/TCBB.2004.43">10.1109/TCBB.2004.43</a>.</p>
</div>
<div id="ref-Bengtsson06">
<p>[6] F. Bengtsson, J. Chen, Computing maximum-scoring segments in almost linear time, in: Computing and Combinatorics, 12th Annual International Conference, COCOON 2006, Taipei, Taiwan, August 15-18, 2006, Proceedings, 2006: pp. 255–264 <a href="https://doi.org/10.1007/11809678_28">10.1007/11809678_28</a>.</p>
</div>
<div id="ref-Bengtsson07">
<p>[7] F. Bengtsson, J. Chen, <strong>Computing maximum-scoring segments optimally</strong>, Luleå University of Technology, 2007.</p>
</div>
<div id="ref-ChenC07">
<p>[8] K.-Y. Chen, K.-M. Chao, <strong>On the range maximum-sum segment query problem</strong>, Discrete Applied Mathematics. 155 (2007) 2043–2052 <a href="https://doi.org/https://doi.org/10.1016/j.dam.2007.05.018">https://doi.org/10.1016/j.dam.2007.05.018</a>.</p>
</div>
<div id="ref-GawrychowskiN15">
<p>[9] P. Gawrychowski, P.K. Nicholson, Encodings of range maximum-sum segment queries and applications, in: F. Cicalese, E. Porat, U. Vaccaro (Eds.), Combinatorial Pattern Matching, Springer International Publishing, Cham, 2015: pp. 196–206.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-10-13. </div>
    <div class="info">Tags: classic, algorithm.</div>

</div>]]></description>
    <pubDate>Mon, 13 Oct 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-10-13-maximum-sum-k-disjoint-subarrays.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Pack a histogram</title>
    <link>https://chaoxuprime.com/blog/posts/2014-10-12-pack-a-histogram.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider we have a histogram of <span class="math inline">n</span> values and <span class="math inline">n</span> distinct colors. The <span class="math inline">i</span>th bar is a rectangle of size <span class="math inline">1\times v_i</span>, where <span class="math inline">v_i</span> is the value and has color <span class="math inline">i</span>. The total area of all the bars are <span class="math inline">n</span>. We are interested in make a few cuts to pack it into <span class="math inline">n</span> squares each one of area <span class="math inline">1</span>, such that each square is consist of at most <span class="math inline">2</span> different colors.</p>
<p>Formally, we are seeking an algorithm for the following problem:</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Input: <span class="math inline">(v_1,1),\ldots,(v_n,n)</span>.</p>
<p>Output: <span class="math inline">S=\{s_1,\ldots,s_n\}</span>, such that <span class="math inline">s_i = \{(x_{2i-1},c_{2i-1}),(x_{2i},c_{2i})\}</span>, <span class="math inline">x_{2i}+x_{2i-1}=1</span> and for all <span class="math inline">1 \leq i\leq n</span>, <span class="math display">\displaystyle 
\sum_{s\in S} \sum_{(x,i)\in s} x = v_i.
</span></p>
</section>
<p>Here is an algorithm that make sure this can be done in linear time. The idea is to separate the numbers into two bins. <span class="math inline">(v_i,i)</span> is in the large bin if <span class="math inline">v_i &gt; 1</span>, and it is in the small bin otherwise. The idea is always pick two elements, one in large bin one in small bin, say <span class="math inline">(x,i)</span> and <span class="math inline">(y,j)</span>, where <span class="math inline">x\leq 1&lt; y</span>. Now we create a set <span class="math inline">\{(x,i),(1-x,j)\}</span>, and put <span class="math inline">(y-(1-x),j)</span> back into the bins.</p>
<p>If we can always prove that there is an element in the small bin during the execution of the algorithm, then we find an linear time algorithm for this problem. This is clear by simple induction.</p>
<p>This problem come up in order to implement the alias method. I recommend a good read on this topic <a href="http://www.keithschwarz.com/darts-dice-coins/">Darts, Dice, and Coins: Sampling from a Discrete Distribution</a> by <a href="http://www.keithschwarz.com">Keith Schwarz</a>.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-10-12. </div>
    <div class="info">Tags: classical, algorithm.</div>

</div>]]></description>
    <pubDate>Sun, 12 Oct 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-10-12-pack-a-histogram.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Induced subgraph with constant diameter</title>
    <link>https://chaoxuprime.com/blog/posts/2014-09-21-augment-induced-subtree-constant-diameter.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">T</span> be a rooted tree on vertices <span class="math inline">V</span>. <span class="math inline">T_v</span> to be the subtree of <span class="math inline">T</span> rooted at <span class="math inline">v</span>. Let <span class="math inline">\mathbb{G}_T^k</span> contains all graphs <span class="math inline">G</span> on <span class="math inline">V</span> with the property that for every <span class="math inline">v</span>, the diameter of <span class="math inline">G[V(T_v)]</span> is at most <span class="math inline">k</span>.</p>
<p>Let <span class="math inline">G_T^k</span> to be the graph in <span class="math inline">\mathbb{G}_T^k</span> with minimum number of edges(break ties arbitrarily), what can we say about the number of edges in <span class="math inline">G_T^2</span>?</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>If <span class="math inline">T</span> has <span class="math inline">n</span> vertices, then <span class="math inline">G_T^2</span> have <span class="math inline">O(n \log n)</span> edges.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">|G|</span> to be the number of vertices in <span class="math inline">|G|</span>.</p>
<p>We construct a graph <span class="math inline">G\in \mathbb{G}_T^2</span> recursively. For each <span class="math inline">T_v</span>, we construct a <span class="math inline">G_v</span> on the same vertex set such that it has the property there exist a vertex that connects to all other vertex in <span class="math inline">G_v</span>. Call such vertex a golden vertex of <span class="math inline">G_v</span>. <span class="math inline">G_v</span> would be a union of all <span class="math inline">G_u</span>, where <span class="math inline">u</span> is a child of <span class="math inline">T_v</span> with some extra edges. Let <span class="math inline">u</span> to be the child of <span class="math inline">v</span> such that <span class="math inline">G_u</span> has the maximum number of vertices (break ties arbitrarily), and <span class="math inline">u&#39;</span> is the golden vertex of <span class="math inline">G_u</span>, then we add edges from <span class="math inline">u&#39;</span> to all other vertices in <span class="math inline">G_v</span>. Let <span class="math inline">G=G_r</span>, where <span class="math inline">r</span> is the root of <span class="math inline">T</span>.</p>
<p>The distance between any two vertex is at most <span class="math inline">2</span> in <span class="math inline">G[V(T_v))]=G_v</span> for all <span class="math inline">v</span>, because any two vertex is connected by a golden vertex in the induced subgraph.</p>
<p>The number of edges is at most <span class="math inline">O(n\log n)</span>. Label <span class="math inline">v</span> with <span class="math inline">|T_v|</span>. The number of edges added at the step to build <span class="math inline">G_v</span> is <span class="math inline">|T_v|-|T_u|</span>, where <span class="math inline">G_u</span> contains the golden vertex, and it also have the most number of vertices among all <span class="math inline">G_c</span> where <span class="math inline">c</span> is a child of <span class="math inline">v</span> in <span class="math inline">T</span>. Sum of all labels over the tree <span class="math inline">T</span> except the heaviest child is <span class="math inline">O(n\log n)</span> using analysis akin to heavy-light decomposition.</p>
</section>
<p>This bound is in fact best possible by considering a complete binary tree and the following lemma:</p>
<section class="theorem-environment Lemma" id="Lemma-2">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">2</span></span>
<p>If <span class="math inline">G=(V,E)</span> is a graph with diameter <span class="math inline">2</span>, then for any cut <span class="math inline">\delta(U)</span>, we have <span class="math inline">|\delta(U)|\geq min(|U|,|V\setminus U|)</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>wlog, let <span class="math inline">|U|\leq |V\setminus U|</span>. If all vertex in <span class="math inline">U</span> has an neighbor in <span class="math inline">V\setminus U</span>, then <span class="math inline">|\delta(U)|\geq |U|</span> and we are done. Otherwise, there is an vertex <span class="math inline">u\in U</span> has no neighbor in <span class="math inline">V\setminus U</span>, then for any <span class="math inline">v\not\in U</span>, there is an <span class="math inline">u&#39;\in U</span>, and there is a path <span class="math inline">uu&#39;v</span>. This implies there are at least <span class="math inline">|V|</span> edges in <span class="math inline">\delta(U)</span>.</p>
</section>
<p>Is this the best possible for general <span class="math inline">G_T^k</span> too? Not at all. To show this, we introduce an algorithmic problem.</p>
<section class="theorem-environment Problem" id="Problem-3">
<span class="theorem-header"><span class="type">Problem</span><span class="index">3</span></span>
<p>Preprocess a rooted tree <span class="math inline">T</span> where the elements in the tree <span class="math inline">T</span> has weights from a semigroup <span class="math inline">(S,+)</span>, such that we can answer the following query in <span class="math inline">k</span> semigroup operations.</p>
<p><strong>Query Input</strong>: <span class="math inline">x</span> and <span class="math inline">y</span> where <span class="math inline">x</span> is an ancestor of <span class="math inline">y</span>.</p>
<p><strong>Query Output</strong>: The sum of weights of the unique simple path between <span class="math inline">x</span> and <span class="math inline">y</span>.</p>
</section>
<p>Alon and Schieber showed this problem can be solved by precompute <span class="math inline">O(n\lambda(k,n))</span> path sums <span class="citation" data-cites="Alon87optimalpreprocessing">[<a href="#ref-Alon87optimalpreprocessing">1</a>]</span>. Where <span class="math inline">\lambda(k,n)</span> is related to the inverse Ackermann function, and <span class="math inline">\lambda(4,n)=O(n\log^*n)</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-4">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">4</span></span>
<p>If <span class="math inline">T</span> has <span class="math inline">n</span> vertices, then <span class="math inline">G_T^k</span> have <span class="math inline">O(n \lambda(k,n))</span> edges.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>A simple reduction from our tree problem by input our rooted tree <span class="math inline">T</span> into Alon and Schieber's algorithm. For each path sum they preprocess, we create an edge in our <span class="math inline">G</span>. The diameter of all <span class="math inline">G_v</span> is at most <span class="math inline">2k</span>, since for any 2 vertices <span class="math inline">x</span> and <span class="math inline">y</span>, we find it's lowest common ancestor <span class="math inline">w</span> in <span class="math inline">T</span>, then there is a path of length <span class="math inline">k</span> from <span class="math inline">x</span> to <span class="math inline">w</span> and another of length at most <span class="math inline">k</span> from <span class="math inline">w</span> to <span class="math inline">y</span>.</p>
</section>
<p>Their paper argued an lower bound of preprocess <span class="math inline">\Omega(n\lambda_k(n))</span> path sums for a single rooted path. In our model, we can add <span class="math inline">O(n)</span> edges is sufficient. An edge from the leaf to every other vertex, making the diameter only <span class="math inline">2</span>. This is because we have a lot more freedom in our diameter problem.</p>
<p>In their problem, their path sum is actually divide the path into <span class="math inline">k</span> subpaths, our path of length <span class="math inline">2</span> would imply there is an overlap in the sum.</p>
<p>One might to think the reason we can do it in <span class="math inline">O(n)</span> edges comes directly from in the undirected model we can traverse back from the leaf and allow overlaps. Maybe the following problem might give us an lower bound.</p>
<section class="theorem-environment Problem" id="Problem-5">
<span class="theorem-header"><span class="type">Problem</span><span class="index">5</span></span>
<p>Preprocess a rooted tree <span class="math inline">T</span> where the elements in the tree <span class="math inline">T</span> has weights from a semigroup <span class="math inline">(S,+)</span>, such that we can answer the following query in <span class="math inline">k</span> semigroup operations.</p>
<p><strong>Query Input</strong>: <span class="math inline">x</span> and <span class="math inline">y</span> where <span class="math inline">x</span> is an ancestor of <span class="math inline">y</span> and <span class="math inline">y</span> is a leaf.</p>
<p><strong>Query Output</strong>: The sum of weights of any walk lies strictly in between <span class="math inline">xy</span> and that start at <span class="math inline">x</span> and ends at <span class="math inline">y</span>.</p>
</section>
<p>Unfortunately, this does not give us an lower bound. Following the proof in Alon's and Schieber's paper, we can show any algorithm would need to precompute at least <span class="math inline">O(n\lambda_k(n))</span> paths in order to output the solution using <span class="math inline">k</span> semigroup operations on this particular tree: <span class="math inline">T</span> is a rooted tree consist of one single path of length <span class="math inline">n</span>, and for each vertex, we add one single dangling leaf.</p>
<p>Again, for this graph, we can add at most <span class="math inline">n</span> edges and force diameter to be at most <span class="math inline">2</span>. Take the lowest leaf and add edge to all other vertices. Here would be an formulation that could result an lower bound.</p>
<section class="theorem-environment Problem" id="Problem-6">
<span class="theorem-header"><span class="type">Problem</span><span class="index">6</span></span>
<p>Preprocess a rooted tree <span class="math inline">T</span> where the elements in the tree <span class="math inline">T</span> has weights from a semigroup <span class="math inline">(S,+)</span>, such that we can answer the following query in <span class="math inline">k</span> semigroup operations.</p>
<p><strong>Query Input</strong>: <span class="math inline">x</span> and <span class="math inline">y</span> where <span class="math inline">x</span> is an ancestor of <span class="math inline">y</span>.</p>
<p><strong>Query Output</strong>: The sum of weights of any walk from <span class="math inline">x</span> to <span class="math inline">y</span> that lies strictly inside the subtree rooted at <span class="math inline">x</span>.</p>
</section>
<p>Finally, here is a conjecture. Instead of using tree, we use Laminar family to simplify the wording of the conjecture.</p>
<section class="theorem-environment Conjecture" id="Conjecture-7">
<span class="theorem-header"><span class="type">Conjecture</span><span class="index">7</span></span>
<p>For every constant <span class="math inline">k</span>, there exist a Laminar family <span class="math inline">X</span> over ground set <span class="math inline">V</span> of <span class="math inline">n</span> vertices, such that for any graph <span class="math inline">G=(V,E)</span> such that <span class="math inline">G[A]</span> has diameter at most <span class="math inline">k</span> for all <span class="math inline">A\in X</span>, then <span class="math inline">|E|=\Omega(n\lambda_k(n))</span>.</p>
</section>
<p>If diameter is <span class="math inline">3</span>, then we can show there is a <span class="math inline">\Omega(n\log \log n)</span> lower bound by consider the Laminar family such that a set of size <span class="math inline">n</span> gets partitioned into <span class="math inline">\sqrt{n}</span> children each with <span class="math inline">\sqrt{n}</span> vertices, and it is applied recursively.</p>
<p>The idea is at any level, say has <span class="math inline">n</span> elements and <span class="math inline">\sqrt{n}</span> subsets. A vertex is called interior if it does not connect to any vertex outside the subset, and exterior otherwise. A subset is shy if it contains a interior vertex. We show there is at least <span class="math inline">1/5 n</span> edges in between the subsets. If there are at least <span class="math inline">1/2n</span> exterior vertices, then we are done. Otherwise, there are at lease <span class="math inline">1/2n</span> interior vertices. We call the subsets with at least one interior vertex shy. At least <span class="math inline">\sqrt{n}/2</span> of those subsets are shy. Consider any two distinct shy subset and pick a interior vertex from each. In order to have a distance 3 path between two interior vertices, the path has to contain two exterior vertex, one in each shy subset. But this shows if we contract all the shy subsets to one vertex, we get a clique. This means there has to be at least <span class="math inline">(\sqrt{n}/2-1)^2&gt;1/5n</span> edges in between the subsets (for large enough <span class="math inline">n</span>).</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Alon87optimalpreprocessing">
<p>[1] N. Alon, B. Schieber, <strong>Optimal preprocessing for answering on-line product queries</strong>, Tel Aviv University, 1987.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-09-21. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Sun, 21 Sep 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-09-21-augment-induced-subtree-constant-diameter.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>2014 APL Programming Contest 3rd place entry</title>
    <link>https://chaoxuprime.com/blog/posts/2014-09-14-2014-apl-programming-contest-3rd-place-entry.html</link>
    <description><![CDATA[<br />
<div>
<p>Again, I'm the <a href="http://www.dyalog.com/news/94/420/2014-APL-Programming-Contest-Winners.htm">3rd place</a>. Here are the <a href="https://studentcompetitions-general.s3.amazonaws.com/testing-challenge/dyalog/2014%20APL%20Problem%20Solving%20Competition%20Phase%20II%20Problems.pdf">problems</a> and the code.</p>
<script src="https://gist.github.com/chaoxu/8b82b8574256b23a1de0.js"></script>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-09-14. </div>
    <div class="info">Tags: APL.</div>

</div>]]></description>
    <pubDate>Sun, 14 Sep 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-09-14-2014-apl-programming-contest-3rd-place-entry.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Reduction between vertex disjoint paths and maximum matching</title>
    <link>https://chaoxuprime.com/blog/posts/2014-09-03-reduce-vertex-disjoint-paths-to-maximum-matching.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="reduce-maximum-bipartite-matching-to-maximum-vertex-disjoint-paths"><span class="header-section-number">1</span> Reduce maximum bipartite matching to maximum vertex disjoint paths</h1>
<p>Given a bipartite graph <span class="math inline">G=(S,T,E)</span>, add a vertex <span class="math inline">s</span> and <span class="math inline">t</span>, such that <span class="math inline">s</span> connect to all vertices in <span class="math inline">S</span> and <span class="math inline">t</span> connect to all vertices in <span class="math inline">T</span>. For each vertex disjoint path from <span class="math inline">s</span> to <span class="math inline">t</span>, alternately remove the edges, the remaining is a maximum matching.</p>
<h1 id="reduce-maximum-vertex-disjoint-paths-to-two-maximum-bipartite-matching"><span class="header-section-number">2</span> Reduce maximum vertex disjoint paths to two maximum bipartite matching</h1>
<p>This is a slight modification of the reduction in Sankowski's paper on bipartite matching<span class="citation" data-cites="Sankowski20094480">[<a href="#ref-Sankowski20094480">1</a>]</span>. It is also a solution to the first problem of the <a href="http://duch.mimuw.edu.pl/~sank/wordpress/wp-content/uploads/2014/03/homework1.pdf">algorithmic trends hw 1</a>.</p>
<p>Notice this consist of two parts, find the value of a maximum matching, and then find a perfect matching on two modified graphs.</p>
<p>Let <span class="math inline">G=(V,E)</span> to be a directed graph with specified nodes <span class="math inline">s</span> and <span class="math inline">t</span>(for simplicity, assume <span class="math inline">st\not\in E</span>). Define <span class="math inline">G_k=(V^- \cup S_k ,V^+ \cup T_k,E&#39;)</span> be a bipartite graph of <span class="math inline">O(m+k^2)=O(n^2)</span> edges and <span class="math inline">O(n)</span> vertices, where <span class="math inline">V^- = \{v^-|v\in V\}</span>, <span class="math inline">V^+ = \{v^+|v\in V\}</span>, <span class="math inline">S_k=\{s_1,\ldots,s_k\}</span> and <span class="math inline">T_k=\{t_1,\ldots,t_k\}</span>. Notice it is similar to the common vertex split in max flow, where <span class="math inline">v</span> get's split into <span class="math inline">v^-</span> and <span class="math inline">v^+</span>.</p>
<p><span class="math inline">E&#39;</span> consist of following edges:</p>
<ol type="1">
<li><span class="math inline">u^-v^+\in E&#39;</span> if <span class="math inline">uv\in E</span> and <span class="math inline">\{u,v\}\cap \{s,t\} = \emptyset</span>.</li>
<li><span class="math inline">u^-u^+\in E&#39;</span> for all <span class="math inline">u\in V</span>.</li>
<li><span class="math inline">s_iv^+\in E&#39;</span> for all <span class="math inline">1\leq i\leq k</span> and <span class="math inline">sv\in E</span>.</li>
<li><span class="math inline">v^-t_i\in E&#39;</span> for all <span class="math inline">1\leq i\leq k</span> and <span class="math inline">vt\in E</span>.</li>
</ol>
<p>We can find maximum number of vertex disjoint paths from <span class="math inline">s</span> to <span class="math inline">t</span> by solving a maximum matching problem on a bipartite graph <span class="math inline">G_n</span>. Any matching that covers both <span class="math inline">V^-</span> and <span class="math inline">V^+</span> would induce some set of vertex disjoint paths by contracting <span class="math inline">v^-v^+</span> into <span class="math inline">v</span>. It's clear no such path can start and end in <span class="math inline">s_i</span> and <span class="math inline">s_j</span> for some <span class="math inline">i</span> and <span class="math inline">j</span>, similarly no path can start at <span class="math inline">t_i</span> and end at <span class="math inline">t_j</span>. Thus we can contract <span class="math inline">S_n</span> into <span class="math inline">s</span> and <span class="math inline">T_n</span> into <span class="math inline">t</span> and remove paths doesn't involves any <span class="math inline">s</span> and <span class="math inline">t</span> to get the set of disjoint paths. The number of such disjoint paths can be readily read from the size of the maximum matching, because the number equals to the number of <span class="math inline">s_i</span> and <span class="math inline">t_j</span>'s matched. Of course, an algorithm for maximum matching might not return a maximum matching that covers both <span class="math inline">V^-</span> and <span class="math inline">V^+</span>, but we use a value to build such an graph.</p>
<p>Let the size of the maximum matching be <span class="math inline">n+l</span>, then there exist <span class="math inline">l</span> maximum vertex disjoint paths. Build graph <span class="math inline">G_l</span> and find a maximum matching in <span class="math inline">G_l</span>. This time the matching would be a perfect matching, and use the same idea as above gives the <span class="math inline">l</span> vertex disjoint paths between <span class="math inline">s</span> and <span class="math inline">t</span>.</p>
<h1 id="reference" class="unnumbered">Reference</h1>
<div id="refs" class="references">
<div id="ref-Sankowski20094480">
<p>[1] P. Sankowski, <strong>Maximum weight bipartite matching in matrix multiplication time</strong>, Theoretical Computer Science. 410 (2009) 4480–4488 <a href="https://doi.org/10.1016/j.tcs.2009.07.028">10.1016/j.tcs.2009.07.028</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-09-03. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Wed, 03 Sep 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-09-03-reduce-vertex-disjoint-paths-to-maximum-matching.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Minimum of submodular function over family of subsets</title>
    <link>https://chaoxuprime.com/blog/posts/2014-08-13-minimum-of-submodular-function-over-subsets.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>Let <span class="math inline">L</span> and <span class="math inline">L&#39;</span> are two lattices. If <span class="math inline">f:L \to \R</span> is a submodular function and <span class="math inline">P:L&#39;\to 2^{L}</span> is a function with the property that if <span class="math inline">X\in P(A)</span> and <span class="math inline">Y\in P(B)</span>, then <span class="math inline">X\wedge Y\in P(A\wedge B)</span> and <span class="math inline">X\vee Y\in P(A\vee B)</span>. <span class="math inline">f_P:L&#39;\to \R</span> defined as <span class="math display">\displaystyle 
	f_P(X) = \min_{Y\in P(X)} f(Y)\\
</span> is submodular.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">X^* = \argmin_{Y\in P(X)} f(Y)</span>, note since <span class="math inline">X^*\in P(X)</span> and <span class="math inline">Y^*\in P(Y)</span>, we have <span class="math inline">X^*\vee Y^* \in P(X\vee Y)</span> and <span class="math inline">X^*\vee Y^* \in P(X\wedge Y)</span>. <span class="math display">\displaystyle \begin{aligned}
f_P(X) + f_P(Y) &amp;= f(X^*) + f(Y^*)\\
                &amp;\geq f(X^* \vee Y^*) + f(X^*\wedge Y^*)\\
                &amp;\geq f((X\vee Y)^*) + f((X\wedge Y)^*)\\
                &amp;= f_P(X\vee Y) + f_P(X\wedge Y)
\end{aligned}</span></p>
</section>
<p>This is quite useful, for starters, it proves that we can create a monotone submodular function from any submodular function.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Let <span class="math inline">f:2^V\to \R</span> be a submodular function, then <span class="math inline">f_*,f^*:2^V\to \R</span> defined as <span class="math display">\displaystyle 
	f_*(X) = \min \{f(Y)|Y\subset X\}\\
	f^*(X) = \min \{f(Y)|X\subset Y\}
</span> are monotone and submodular.</p>
</section>
<p>A practical application is to generalize the cut function. Consider for a directed graph graph <span class="math inline">G=(V,E)</span>. We would define <span class="math inline">\delta^+(A)</span> to be the set of out going edges from <span class="math inline">A</span> to <span class="math inline">V\setminus A</span>. <span class="math inline">f=|\delta^+|</span> is a submodular function. An alternate definition for <span class="math inline">f</span> is the minimum number of edges to be removed so there is no path from <span class="math inline">A</span> to <span class="math inline">V\setminus A</span>.</p>
<p>A simple generalization is when we only care about <span class="math inline">T\subset V</span>. We can define <span class="math inline">f_T(A)</span> to be the minimum number of edges to be removed so there is no path from <span class="math inline">A</span> to <span class="math inline">T\setminus A</span>. Amazingly(or not not surprisingly, depending on your intuition), <span class="math inline">f_T</span> is also a submodular function by invoking the next theorem, which is a direct corollary of our first theorem.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>Let <span class="math inline">f:2^V\to \R</span> be a submodular function, then <span class="math inline">f_T:2^T\to \R</span> defined as <span class="math display">\displaystyle 
	f_T(X) = \min \{f(Y)|Y\subset X, T\setminus X\subset V\setminus Y\}\\
</span> is submodular.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-08-13. </div>
    <div class="info">Tags: submodular.</div>

</div>]]></description>
    <pubDate>Wed, 13 Aug 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-08-13-minimum-of-submodular-function-over-subsets.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Sum over products of weighted subset of certain size</title>
    <link>https://chaoxuprime.com/blog/posts/2014-08-11-sum-over-products-of-weighted-subset-of-certain-size.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider a commutative semiring <span class="math inline">(R,+,\cdot)</span>. <span class="math inline">\mathbb{0}</span> is the identity for <span class="math inline">(R,+)</span>, and <span class="math inline">\mathbb{1}</span> is the identity for <span class="math inline">(R,\cdot)</span>. Let <span class="math inline">f,g:V\to R</span>, <span class="math inline">w:V\to \mathbb{N}</span> and <span class="math inline">Z\subset \mathbb{N}</span>. It is common that we are interested in computing expressions of the following form.</p>
<p><span class="math display">\displaystyle 
\sum_{S\subset V, \sum_{x\in S} w(x) \in Z} \prod_{x\in S} f(x) \prod_{x\in V\backslash S} g(x)
</span></p>
<p>Examples:</p>
<ol type="1">
<li><p>If <span class="math inline">w(x)=1</span> for all <span class="math inline">x</span>, and <span class="math inline">f(x)</span> be the probability that event <span class="math inline">x</span> occurs, <span class="math inline">g=1-f</span>, we find the probability that the number of event occurs <span class="math inline">t</span> times, where <span class="math inline">t\in Z</span>. In probability, this is computing the Poisson distribution.</p></li>
<li><p>If <span class="math inline">(R,+,\cdot) = (\N,+,\cdot)</span>, <span class="math inline">f=g=1</span>, for all <span class="math inline">x</span> and <span class="math inline">w(x)=x</span> and <span class="math inline">V\subset \N</span> and <span class="math inline">Z=\{t\}</span>, then we find the number of subsets that have element sum <span class="math inline">t</span>.</p></li>
<li><p>If <span class="math inline">(R,+,\cdot) = (\N,\max,+)</span>, <span class="math inline">V\subset \N</span>, <span class="math inline">g=0</span> and <span class="math inline">Z=\{0,\ldots,W\}</span>, then this solves the knapsack problem with knapsack size <span class="math inline">W</span>, value <span class="math inline">f</span> and cost <span class="math inline">w</span>.</p></li>
<li><p>An actual application inspired this post: An automated test suite that runs <span class="math inline">n</span> subtests, and it is allowed to rerun a subtest if it fails the first time. A subtest passes if first run passes or the rerun passes. The test is successful if all the subtests passes and the number of total reruns is at most <span class="math inline">k</span>. Assume probability of passing is independent for each subtest. One want to estimate the probability of a successful test given the probability a run passes for a specific subtest.</p></li>
</ol>
<p>Let <span class="math inline">\max Z = k</span> and <span class="math inline">|V| = n</span>. The naive algorithm runs in <span class="math inline">O(n2^n)</span> time (assuming semiring operation takes <span class="math inline">O(1)</span> time). There is a common transformation that turns this problem that sum over all subsets to a problem that sums over <span class="math inline">Z</span>. So it runs in <span class="math inline">O(nk)</span> time.</p>
<p>Let <span class="math inline">V=\{v_1,\ldots,v_n\}</span> and <span class="math inline">V_j = \{v_1,\ldots,v_j\}</span>. Define <span class="math display">\displaystyle 
 		D(i,j) = \sum_{S\subset V_j, \sum_{x\in S} w(x) = i} \prod_{x\in S} f(x) \prod_{x\in V\backslash S} g(x)
	</span>.</p>
<p>Certainly, <span class="math display">\displaystyle 
		\sum_{S\subset V, \sum_{x\in S} w(x) \in Z} \prod_{x\in S} f(x) \prod_{x\in V\backslash S} g(x) = \sum_{i\in Z} D(i,n)
	</span></p>
<p>We only incur a <span class="math inline">O(k)</span> number of semiring operations once we compute all <span class="math inline">D(i,n)</span> for <span class="math inline">0\leq i\leq k</span>.</p>
<p>Let <span class="math inline">[P]</span> be the <a href="http://en.wikipedia.org/wiki/Iverson_bracket">Iverson bracket notation</a>, namely</p>
<p><span class="math display">\displaystyle 
[P] = \begin{cases} \mathbb{1} &amp; \text{if } P \text{ is true;}\\
      \mathbb{0} &amp; \text{otherwise.} \end{cases}
</span></p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<ol type="1">
<li><p><span class="math inline">D(i,0) = [i \neq 0]</span></p></li>
<li><p>For <span class="math inline">j\geq 1</span>, <span class="math inline">D(i,j) = [i\geq w(v_j)] f(v_j)D(i-w(v_j),j-1) + g(v_j) D(i,j-1)</span>.</p></li>
</ol>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>The base case can be verified easily, we show part of a inductive step.</p>
<p><span class="math display">\displaystyle \begin{aligned}
f(v_j)D(i-w(v_j),j-1) + g(v_j)D(i,j-1) &amp;= f(v_j) \sum_{S\subset V_{j-1}, \sum_{x\in S} w(x) = i-w(v_j)} \prod_{x\in S} f(x) \prod_{x\in V\backslash S} g(x)  +
g(v_j) \sum_{S\subset V_{j-1}, \sum_{x\in S} w(x) = i)} \prod_{x\in S} f(x) \prod_{x\in V\backslash S} g(x) \\
&amp;=   \sum_{v_j\in S\subset V_j, \sum_{x\in S} w(x) = i} \prod_{x\in S} f(x) \prod_{x\in V\backslash S} g(x) + \sum_{v_j\not\in S\subset V_j, \sum_{x\in S} w(x) = i} \prod_{x\in S} f(x) \prod_{x\in V\backslash S} g(x)\\
&amp;= \sum_{S\subset V_j, \sum_{x\in S} w(x) = i} \prod_{x\in S} f(x) \prod_{x\in V\backslash S} g(x)
\end{aligned}</span></p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-08-11. </div>
    <div class="info">Tags: algorithm.</div>

</div>]]></description>
    <pubDate>Mon, 11 Aug 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-08-11-sum-over-products-of-weighted-subset-of-certain-size.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Pattern in Labeled Ordered Rooted Trees</title>
    <link>https://chaoxuprime.com/blog/posts/2014-06-05-pattern-in-labeled-ordered-rooted-trees.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Let <span class="math inline">T</span> be a rooted ordered labeled tree. Find all the vertices where all it's subtrees are equal.</p>
</section>
<p>Let <span class="math inline">T(v)</span> to denote the subtree rooted at <span class="math inline">v</span>. The two trees are equal if they have the same shape and the same label.</p>
<h1 id="reduce-to-a-string-problem"><span class="header-section-number">1</span> Reduce to a string problem</h1>
<p>This problem is interesting because one solution can demonstrate the technique of linearize the ordered tree to a string, and apply string algorithms.</p>
<p>First, we replace every edge in the tree with two directed edges <span class="math inline">uv</span> and <span class="math inline">vu</span>, where <span class="math inline">u</span> is closer to the root than <span class="math inline">v</span>. We label <span class="math inline">uv</span> with <span class="math inline">(</span> and <span class="math inline">vu</span> with <span class="math inline">)</span>. This will be the new tree we work with.</p>
<p>Let <span class="math inline">s(T)</span> be a string defined by concatenating the labels on the path by traverse the tree with an euler tour by following the edges in a DFS like manner starting from the root of <span class="math inline">T</span>.</p>
<p>Note <span class="math inline">s(T)</span> would be a balanced set of parenthesis when <span class="math inline">l</span> maps vertices to the empty string. Indeed, there is a bijection between unlabeled ordered trees and balanced parenthesis. It's not hard to see this generalizes to the labeled setting.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>If <span class="math inline">s(T)=s(T&#39;)</span>, then <span class="math inline">T=T&#39;</span>.</p>
</section>
<p>A run in a string is a maximal string of the form <span class="math inline">a^nb</span>, where <span class="math inline">b</span> is a prefix of <span class="math inline">a</span> and <span class="math inline">n\geq 2</span>. The runs theorem states there are at most <span class="math inline">O(n)</span> runs, and all of them can be found in <span class="math inline">O(n)</span> time<span class="citation" data-cites="Crochemore_computinglongest">[<a href="#ref-Crochemore_computinglongest">1</a>]</span>. Let <span class="math inline">a^nb</span> be a run in a string, then we call the <span class="math inline">a^n</span> part the complete repetitions.</p>
<p>Define the vertices with at least <span class="math inline">2</span> child and all it's subtrees are equal as good vertices. It's easy to <span class="math inline">s(T(v))</span> for some good vertex <span class="math inline">v</span> is going to be a complete repetition!</p>
<p>Now if we found a run, it's easy to check if it actually correspond to a good vertex in <span class="math inline">O(1)</span> time once we did a <span class="math inline">O(n)</span> time preprocessing.</p>
<p>This allows us to solve the problem in <span class="math inline">O(n)</span> time.</p>
<p>Alternatively, there is a paper with a linear time algorithm to find all subtree repeats inside a tree<span class="citation" data-cites="subtreerepeat">[<a href="#ref-subtreerepeat">2</a>]</span>.</p>
<h1 id="reference" class="unnumbered">Reference</h1>
<div id="refs" class="references">
<div id="ref-Crochemore_computinglongest">
<p>[1] M. Crochemore, L. Ilie, <strong>Computing longest previous factor in linear time and applications</strong>, Information Processing Letters. 106 (2008) 75–80.</p>
</div>
<div id="ref-subtreerepeat">
<p>[2] T. Flouri, K. Kobert, S. Pissis, A. Stamatakis, An optimal algorithm for computing all subtree repeats in trees, in: T. Lecroq, L. Mouchard (Eds.), Combinatorial Algorithms, Springer Berlin Heidelberg, 2013: pp. 269–282 <a href="https://doi.org/10.1007/978-3-642-45278-9_23">10.1007/978-3-642-45278-9_23</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-06-05. </div>
    <div class="info">Tags: algorithm.</div>

</div>]]></description>
    <pubDate>Thu, 05 Jun 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-06-05-pattern-in-labeled-ordered-rooted-trees.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Lexicographic Bottleneck Shortest Path in Undirected Graphs</title>
    <link>https://chaoxuprime.com/blog/posts/2014-05-10-lexicographical-bottleneck-path.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="lexicographic-bottleneck-ordering"><span class="header-section-number">1</span> Lexicographic Bottleneck Ordering</h1>
<p>Let <span class="math inline">X</span> be a totally ordered set. Let <span class="math inline">l(S)</span> be the sorted sequence of all the elements in <span class="math inline">S</span>, where <span class="math inline">S\subset X</span>. We can induce an total ordering on the subset of <span class="math inline">X</span>.</p>
<section class="theorem-environment Definition" id="Definition-1">
<span class="theorem-header"><span class="type">Definition</span><span class="index">1</span></span>
<p><span class="math inline">S\preccurlyeq T</span> for <span class="math inline">S,T\subset X</span> if <span class="math inline">l(S)\leq l(T)</span> in lexicographic ordering. <span class="math inline">\preccurlyeq</span> is called the lexicographic bottleneck ordering.</p>
</section>
<section class="theorem-environment Lemma" id="Lemma-2">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">2</span></span>
<p>For nonempty sets <span class="math inline">A</span> and <span class="math inline">B</span>, if <span class="math inline">A\preccurlyeq B</span> , then <span class="math inline">A - min A \preccurlyeq B - min B</span>. Also if <span class="math inline">A\preccurlyeq B</span> then <span class="math inline">A \preccurlyeq A\cup B \preccurlyeq B</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p><span class="math inline">A\preccurlyeq A&#39;</span>, <span class="math inline">B\preccurlyeq B&#39;</span> then <span class="math inline">A\cup B \preccurlyeq A&#39;\cup B&#39;</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">C=A\cup B</span> and <span class="math inline">C&#39; = A&#39;\cup B&#39;</span>.</p>
<p>Since <span class="math inline">\preccurlyeq</span> is a total order, we can prove it by showing if <span class="math inline">C&#39;\preccurlyeq C</span> then <span class="math inline">C&#39; = C</span>.</p>
<p>We prove it by structural induction on <span class="math inline">C&#39;</span>. The base case when <span class="math inline">C&#39; = \emptyset</span> is trivial, since it must mean <span class="math inline">A=B=A&#39;=B&#39;=\emptyset</span>.</p>
<p>Consider <span class="math inline">c&#39; = \min C&#39;, c = \min C</span>. <span class="math inline">c&#39;\leq c</span> in order for <span class="math inline">C&#39;\preccurlyeq C</span>. But we know <span class="math inline">c\leq c&#39;</span>. This shows <span class="math inline">c=c&#39;</span>. Given that <span class="math inline">c=c&#39;</span>, <span class="math inline">A&#39;\cup B&#39; = A\cup B</span> if and only if <span class="math inline">(A&#39;-c)\cup (B&#39;-c) = (A-c) \cup (B-c)</span>.</p>
<p>First, we show that <span class="math inline">A-c \preccurlyeq A&#39;-c</span>.</p>
<ol type="1">
<li>Assume <span class="math inline">c\in A</span>, then <span class="math inline">c\in A&#39;</span>, so by previous lemma this is true.</li>
<li>If <span class="math inline">c\not\in A</span> and <span class="math inline">c\not \in A&#39;</span>, then <span class="math inline">A-c=A\preccurlyeq A&#39;=A&#39;-c</span>.</li>
<li>If <span class="math inline">c\not \in A</span> but <span class="math inline">c\in A&#39;</span>, then this implies <span class="math inline">A</span> is empty, and <span class="math inline">\emptyset \preccurlyeq A&#39;-c</span>.</li>
</ol>
<p>Similarly, <span class="math inline">B-c\preccurlyeq B&#39;-c</span>.</p>
<p>Second, we need to show that <span class="math inline">(A&#39;-c)\cup (B&#39;-c) \preccurlyeq (A-c) \cup (B-c)</span>. This is obvious because <span class="math inline">C&#39;\preccurlyeq C</span> implies <span class="math inline">C&#39;-c \preccurlyeq C-c</span>.</p>
<p>By the inductive hypothesis, <span class="math inline">(A&#39;-c)\cup (B&#39;-c) = (A-c) \cup (B-c)</span>, thus completes the proof.</p>
</section>
<p>The theorem intuitively tells us how to partition a set into smaller sets.</p>
<h1 id="lexicographic-bottleneck-path"><span class="header-section-number">2</span> Lexicographic Bottleneck Path</h1>
<p>Given a undirected graph <span class="math inline">G=(V,E)</span>, and an ordering of the edges <span class="math inline">e_1,\ldots,e_m</span>. Let <span class="math inline">w(e_i)=i</span>.</p>
<section class="theorem-environment Problem" id="Problem-4">
<span class="theorem-header"><span class="type">Problem</span><span class="index">4</span><span class="name">Bottleneck Shortest Path</span></span>
<p>Find a <span class="math inline">st</span>-path that maximizes the minimum edge weight on the path.</p>
</section>
<p>Any <span class="math inline">st</span>-path that maximizes the minimum edge weight over all <span class="math inline">st</span>-paths is a <span class="math inline">st</span>-bottleneck shortest path(BSP). We are interested in a more general version of this problem. Find a path from <span class="math inline">s</span> to <span class="math inline">t</span> that is maximum with respect to the lexicographic bottleneck ordering <span class="math inline">\preccurlyeq</span> of the path.</p>
<section class="theorem-environment Problem" id="Problem-5">
<span class="theorem-header"><span class="type">Problem</span><span class="index">5</span><span class="name">Lexicographic Bottleneck Shortest Path</span></span>
<p>Find a <span class="math inline">st</span>-path <span class="math inline">P</span> such that <span class="math inline">P&#39;\preccurlyeq P</span> for all <span class="math inline">st</span>-path <span class="math inline">P&#39;</span>.</p>
</section>
<p>The unique <span class="math inline">st</span>-path that is maximum in lexicographic bottleneck order among all <span class="math inline">st</span>-paths is called the <span class="math inline">st</span>-lexicographic bottleneck shortest path(LBSP).</p>
<p>In order to find a BSP, we can first compute the maximum spanning tree <span class="math inline">T</span> of <span class="math inline">G</span>, as show in Lemma 4.1 of <span class="citation" data-cites="vertexbottle">[<a href="#ref-vertexbottle">1</a>]</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-6">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">6</span></span>
<p>If <span class="math inline">T</span> is a maximum spanning tree of <span class="math inline">G</span>(under the weight <span class="math inline">w</span>), then the unique <span class="math inline">st</span>-path in <span class="math inline">T</span> is a <span class="math inline">st</span>-BSP in <span class="math inline">G</span>.</p>
</section>
<p>It's interesting this theorem actually extends to LBSP.</p>
<section class="theorem-environment Theorem" id="Theorem-7">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p>If <span class="math inline">T</span> is a maximum spanning tree of <span class="math inline">G</span>(under the weight <span class="math inline">w</span>), then the unique <span class="math inline">st</span>-path in <span class="math inline">T</span> is the <span class="math inline">st</span>-LBSP in <span class="math inline">G</span>.</p>
</section>
<p>Before proving the theorem, we consider a useful lemma.</p>
<section class="theorem-environment Lemma" id="Lemma-8">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">8</span></span>
<p><span class="math inline">P</span> is a <span class="math inline">st</span>-BSP with bottleneck edge <span class="math inline">xy</span>. If removing edge <span class="math inline">xy</span> result a <span class="math inline">sx</span>-LBSP and <span class="math inline">yt</span>-LBSP, then <span class="math inline">P</span> is a <span class="math inline">st</span>-LBSP.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math inline">P</span> is a bottleneck <span class="math inline">st</span>-path implies the <span class="math inline">st</span>-LBSP has to reach either <span class="math inline">x</span> or <span class="math inline">y</span> before <span class="math inline">t</span>.</p>
<p>If it reaches <span class="math inline">y</span> before <span class="math inline">x</span>, then the subpath from <span class="math inline">s</span> to <span class="math inline">y</span> then from <span class="math inline">y</span> to <span class="math inline">t</span> using the <span class="math inline">yt</span>-LBSP would imply <span class="math inline">xy</span> is not in <span class="math inline">st</span>-LBSP, a contradiction.</p>
<p>Thus, we must have the <span class="math inline">st</span>-LBSP is a concatenation of <span class="math inline">3</span> paths, a <span class="math inline">sx</span>-path <span class="math inline">P_{sx}</span>, edge <span class="math inline">xy</span> and a <span class="math inline">yt</span>-path <span class="math inline">P_{ty}</span>. Using <a href="#Theorem-3">Theorem 3</a>, we notice <span class="math inline">P</span> is a LBSP.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span><span class="name"><a href="#Theorem-7">Theorem 7</a></span></span>
<p>We prove by induction on the distance between the two vertices on the maximum spanning tree <span class="math inline">T</span>.</p>
<p><strong>Base Case:</strong> If the length of a <span class="math inline">uv</span> on <span class="math inline">T</span> is <span class="math inline">1</span>, then the edge <span class="math inline">uv</span> is a BSP, and also a LBSP.</p>
<p><strong>Inductive Step:</strong> Consider two vertices <span class="math inline">s</span> and <span class="math inline">t</span>. The tree induces a <span class="math inline">st</span>-BSP with bottleneck edge <span class="math inline">xy</span>. By the inductive hypothesis, removing <span class="math inline">xy</span> result a <span class="math inline">sx</span>-LBSP and <span class="math inline">yt</span>-LBSP in <span class="math inline">G</span>. The previous lemma demonstrates that <span class="math inline">st</span>-BSP in <span class="math inline">T</span> is a <span class="math inline">st</span>-LBSP in <span class="math inline">G</span>.</p>
</section>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-vertexbottle">
<p>[1] A. Shapira, R. Yuster, U. Zwick, <strong>All-pairs bottleneck paths in vertex weighted graphs</strong>, Algorithmica. 59 (2011) 621–633 <a href="https://doi.org/10.1007/s00453-009-9328-x">10.1007/s00453-009-9328-x</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-05-10. </div>
    <div class="info">Tags: algorithm.</div>

</div>]]></description>
    <pubDate>Sat, 10 May 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-05-10-lexicographical-bottleneck-path.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Recognize Uniquely Decodable Codes</title>
    <link>https://chaoxuprime.com/blog/posts/2014-04-27-recognize-uniquely-decodable-codes.html</link>
    <description><![CDATA[<br />
<div>
<p>A set of strings <span class="math inline">C</span> is called a uniquely decodable code, if <span class="math inline">C^*</span> has a unique factorization over <span class="math inline">C</span>. Namely, for each element <span class="math inline">s</span> in <span class="math inline">C^*</span>, there exist a unique finite sequence <span class="math inline">\{s_i\}_{i=1}^m</span> of elements in <span class="math inline">C</span>, such that <span class="math inline">s_1\ldots s_m = s</span>. We call the strings in <span class="math inline">C</span> a code string.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Uniquely Decodable Code Recognition</span></span>
<p>Let <span class="math inline">C</span> be a finite set of strings, decide if <span class="math inline">C</span> is a uniquely decodable code.</p>
</section>
<p>In general, the infinite version of the problem is undecidable. It is however decidable if <a href="http://cs.stackexchange.com/questions/6114/represent-string-as-concatenations"><span class="math inline">C</span> is a regular language</a>.</p>
<p>To solve this problem, we shall describe a formulation of <a href="http://en.wikipedia.org/wiki/Sardinas%E2%80%93Patterson_algorithm">Sardinas–Patterson algorithm</a>, which combines the description of <span class="citation" data-cites="jewelsofstringology">[<a href="#ref-jewelsofstringology">1</a>]</span> and <span class="citation" data-cites="rodeh">[<a href="#ref-rodeh">2</a>]</span>.</p>
<p>In the entire article, we assume the alphabet size is fixed.</p>
<p>For variable sized alphabet, let <span class="math inline">\sigma</span> be the number of distinct alphabet appeared in <span class="math inline">C</span>. There is an extra factor of <span class="math inline">\sigma</span> or <span class="math inline">\log \sigma</span> depending on if there exist a comparator for the alphabet.</p>
<p>Define <span class="math inline">S(C) = \{ v| xv = c, c\in C\}</span>, the set of suffixes of <span class="math inline">C</span>. <span class="math inline">I(C) = \{ v| c&#39;v = c, c&#39;\neq c, c&#39;,c\in C\}</span>, we call those initial suffix.</p>
<section class="theorem-environment Lemma" id="Lemma-2">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">2</span></span>
<p><span class="math inline">C</span> is uniquely decodable if and only if there is no <span class="math inline">v\in I(C)</span>, such that <span class="math inline">vs\in C^*</span> and <span class="math inline">s\in C^*</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>If there exist such <span class="math inline">v</span> so <span class="math inline">vs,s\in C^*</span>. <span class="math inline">c&#39;v=c</span> for some <span class="math inline">c,c&#39;\in C</span>. Consider the string <span class="math inline">cs=c&#39;(vs)</span>. It has at least two factorization, one start with <span class="math inline">c</span>, the other start with <span class="math inline">c&#39;</span>, and <span class="math inline">c&#39;\neq c</span>.</p>
<p>Let no such <span class="math inline">v</span> exists. Consider some <span class="math inline">u\in C^*</span>. It can be written as <span class="math inline">cs</span> and <span class="math inline">c&#39;s&#39;</span> for <span class="math inline">c,c&#39;\in C</span>, <span class="math inline">s,s&#39;\in C^*</span>. Assume there is more than one factorization, then <span class="math inline">c&#39;\neq c</span> and wlog <span class="math inline">c&#39;v=c</span>. We arrive <span class="math inline">vs=s&#39;\in C^*</span>, a contradiction.</p>
</section>
<p>Consider a <span class="math inline">G=(V,A)</span> a directed graph. <span class="math inline">V=S(C)</span>. There is an arc from <span class="math inline">a</span> to <span class="math inline">b</span> iff <span class="math inline">ab=c</span> or <span class="math inline">cb=a</span> for some <span class="math inline">c\in C</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p><span class="math inline">C</span> is uniquely decodable code iff there is no path from a vertex in <span class="math inline">I(C)</span> to <span class="math inline">\epsilon</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>For any arc <span class="math inline">uv</span>, if <span class="math inline">uv=c\in C</span>, then label the arc <span class="math inline">uv</span> by <span class="math inline">u</span>. Otherwise, label the arc with <span class="math inline">c</span> where <span class="math inline">cv = u</span>. It's then easy to see concatenate the labels on any walk from <span class="math inline">v</span> to <span class="math inline">\epsilon</span> spells a string of the form <span class="math inline">vs \in C^*</span> for <span class="math inline">s \in C^*</span>.</p>
<p>By induction, one can show that for a vertex <span class="math inline">v</span>, there exist string <span class="math inline">vs\in C^*</span>, where <span class="math inline">s\in C^*</span>, if and only if there is a path from <span class="math inline">v</span> to <span class="math inline">\epsilon</span>.</p>
</section>
<p>In order to compute the arcs on the graph, we need to answer two questions.</p>
<ol type="1">
<li>Is <span class="math inline">u</span> a prefix of <span class="math inline">c</span>? For all <span class="math inline">u\in S(C)</span> and <span class="math inline">c\in C</span>.</li>
<li>Is <span class="math inline">c</span> a prefix of <span class="math inline">u</span>? For all <span class="math inline">u\in S(C)</span> and <span class="math inline">c\in C</span>.</li>
</ol>
<p>Let <span class="math inline">k=|C|</span>, <span class="math inline">n=\sum_{c\in C}|c|</span>. It is known that we can build a generalized suffix tree for <span class="math inline">C</span> in linear time.</p>
<p>For the first question, &quot;Is <span class="math inline">u</span> a prefix of <span class="math inline">c</span>?&quot;, consider we constructed a suffix tree <span class="math inline">T</span> for <span class="math inline">C</span>. Transversing the suffix tree <span class="math inline">T(C)</span> with a code string <span class="math inline">c\in C</span>. Assume we have read a prefix <span class="math inline">u</span> of <span class="math inline">c</span>, we can check if <span class="math inline">u\in S(C)</span> in constant time during the transversal. If <span class="math inline">u\in S(C)</span>, then <span class="math inline">c=uv</span> where <span class="math inline">v\in S(C)</span>. It will add an arc <span class="math inline">uv</span>. We use <span class="math inline">O(|c|)</span> time to find all the arcs can be formed by answering the &quot;Is <span class="math inline">u</span> a prefix of <span class="math inline">c</span>&quot;. In total, we can answer question 1 in <span class="math inline">O(n)</span> time.</p>
<p>For the second question, we can also use the same suffix tree. Transverse the suffix tree with a code string <span class="math inline">c</span>. Find all the leaves in the subtree when the string <span class="math inline">c</span> ends. Those correspond to all strings <span class="math inline">u\in S(C)</span> such that <span class="math inline">c</span> is a prefix. Namely <span class="math inline">u=cv</span> where <span class="math inline">v\in S(C)</span>. The algorithm add an arc <span class="math inline">uv</span>. Note there might be many <span class="math inline">u</span> with this property, worst case <span class="math inline">O(n)</span>. This step might run in <span class="math inline">O(nk)</span> time.</p>
<p>It's not clear we can construct arcs between the vertices in constant time. The main difficulty lies in two suffix of two different code word might correspond to the same vertex in the graph. If we number the code words and name the suffixes by their length, then we can construct a <span class="math inline">O(n)</span> size table that maps each pair <span class="math inline">(i,j)</span>, which represents the suffix of length <span class="math inline">j</span> in the <span class="math inline">i</span>th string, to a vertex that represent the string. Simply build a trie for the reverse of the strings, and do some bookkeeping. This map allow us to add an edge in constant time.</p>
<p>The graph <span class="math inline">G</span> has at most <span class="math inline">O(nk)</span> arcs. We add a new vertex that has an arc to each initial vertices and apply a DFS from the new vertex. If it reaches the <span class="math inline">\epsilon</span> vertex, we return true, else we return false.</p>
<section class="theorem-environment Theorem" id="Theorem-4">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">4</span></span>
<p>There exist an algorithm to test if <span class="math inline">C</span> is a uniquely decodable code in <span class="math inline">O(nk)</span> time, where <span class="math inline">k=|C|</span> and <span class="math inline">n=\sum_{c\in C} |c|</span>.</p>
</section>
<p>I have an implementation in Haskell <a href="https://github.com/chaoxu/haskell-algorithm/blob/master/SardinasPatterson.hs">here</a>. Note it doesn't run in exactly <span class="math inline">O(nk)</span> time because of the <code>Map</code> takes <span class="math inline">O(\log n)</span> time. It can, however, be easily modified to run in <span class="math inline">O(nk)</span> time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-jewelsofstringology">
<p>[1] M. Crochemore, W. Rytter, <strong>Jewels of stringology</strong>, World Scientific, 2002.</p>
</div>
<div id="ref-rodeh">
<p>[2] M. Rodeh, <strong>A fast test for unique decipherability based on suffix trees (corresp.)</strong>, Information Theory, IEEE Transactions on. 28 (1982) 648–651 <a href="https://doi.org/10.1109/TIT.1982.1056535">10.1109/TIT.1982.1056535</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-04-27. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Sun, 27 Apr 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-04-27-recognize-uniquely-decodable-codes.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>The Aho–Corasick Automaton in Haskell</title>
    <link>https://chaoxuprime.com/blog/posts/2014-04-25-aho-corasick-in-haskell.html</link>
    <description><![CDATA[<br />
<div>
<p>It is common that one might want to match <span class="math inline">k</span> different strings against one single text of length <span class="math inline">m</span>. One can of course apply the <a href="/posts/2014-04-11-the-kmp-algorithm-in-haskell.html">KMP algorithm</a> individually, and result an algorithm that runs in <span class="math inline">O(km)</span> time.</p>
<p>Faster algorithms are known. The idea is to build an finite state transducer that can output which strings is the suffix of the string it read. The Aho-Corasick automaton is a compressed version of such transducer, as the size does not depend on the size of the alphabet.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Control.Arrow</span> (first)
<span class="kw">import           </span><span class="dt">Data.Function</span> (on)
<span class="kw">import           </span><span class="dt">Data.List</span>     (lookup, partition)
<span class="kw">import           </span><span class="dt">Data.Maybe</span>    (fromMaybe, <span class="dt">Maybe</span> (..))
<span class="kw">import           </span><span class="dt">Data.Monoid</span>   (<span class="dt">All</span> (..), <span class="dt">Monoid</span>, getAll, mappend, mconcat,
                                mempty)
<span class="kw">data</span> <span class="dt">Automaton</span> a b <span class="fu">=</span> <span class="dt">Node</span> {<span class="ot">delta  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a b,
<span class="ot">                           output ::</span> b
                         }

<span class="ot">equivalentClasses ::</span> (a<span class="ot">-&gt;</span>a<span class="ot">-&gt;</span><span class="dt">Bool</span>)<span class="ot">-&gt;</span>[a]<span class="ot">-&gt;</span>[[a]]
equivalentClasses eq <span class="fu">=</span> foldl parts []
  <span class="kw">where</span> parts [] a <span class="fu">=</span> [[a]]
        parts (x<span class="fu">:</span>xs) a
         <span class="fu">|</span> eq (head x) a <span class="fu">=</span> (a<span class="fu">:</span>x)<span class="fu">:</span>xs
         <span class="fu">|</span> otherwise     <span class="fu">=</span> x<span class="fu">:</span>parts xs a

<span class="ot">buildAutomaton ::</span> (<span class="dt">Monoid</span> b,<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [([a],b)] <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a b
buildAutomaton xs <span class="fu">=</span> automaton
  <span class="kw">where</span> automaton <span class="fu">=</span> build (const automaton) xs mempty

<span class="ot">build ::</span> (<span class="dt">Monoid</span> b,<span class="dt">Eq</span> a)<span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a b) <span class="ot">-&gt;</span> [([a],b)] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a b
build trans xs out <span class="fu">=</span> node
  <span class="kw">where</span> node  <span class="fu">=</span> <span class="dt">Node</span> (\x<span class="ot">-&gt;</span>fromMaybe (trans x) (lookup x table)) out
        table <span class="fu">=</span>  map transPair <span class="fu">$</span> equivalentClasses (on (<span class="fu">==</span>) (head <span class="fu">.</span> fst)) xs
        transPair xs <span class="fu">=</span> (a, build (delta (trans a)) ys out)
         <span class="kw">where</span> a  <span class="fu">=</span> head <span class="fu">$</span> fst <span class="fu">$</span> head xs
               (ys,zs) <span class="fu">=</span> partition (not <span class="fu">.</span> null <span class="fu">.</span> fst) <span class="fu">$</span> map (first tail) xs
               out <span class="fu">=</span> mappend (mconcat <span class="fu">$</span> map snd zs) (output <span class="fu">$</span> trans a)

<span class="ot">match ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Automaton</span> a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
match a xs <span class="fu">=</span> map output <span class="fu">$</span> scanl delta a xs

<span class="ot">match&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[[a]]]
match&#39; pat <span class="fu">=</span> match (buildAutomaton <span class="fu">$</span> map (\x<span class="ot">-&gt;</span> (x,[x])) pat)

<span class="ot">isInfixOf&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isInfixOf&#39; xs ys <span class="fu">=</span> getAll <span class="fu">$</span> mconcat <span class="fu">$</span> match (buildAutomaton [(xs, <span class="dt">All</span> <span class="dt">True</span>)]) ys</code></pre></div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-04-25. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Fri, 25 Apr 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-04-25-aho-corasick-in-haskell.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>The KMP algorithm in Haskell</title>
    <link>https://chaoxuprime.com/blog/posts/2014-04-11-the-kmp-algorithm-in-haskell.html</link>
    <description><![CDATA[<br />
<div>
<p>Almost all the string algorithms I read are doing index manipulations somewhere. However meddling with indices are never a smart move in pedagogical settings. For example, see the code for the <a href="http://www-igm.univ-mlv.fr/~lecroq/string/node8.html">KMP algorithm in C</a>. It's short, to the point, and elegant in it's own way. Except it's hard to see the meaning behind all the operations.</p>
<p>As an example, this article demonstrates how to write the KMP string matching algorithm without all those indices.</p>
<p>The KMP string matching algorithm solves the following problem.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a string <span class="math inline">pat</span> of length <span class="math inline">m</span>, return if it exist in <span class="math inline">text</span> of length <span class="math inline">n</span> in <span class="math inline">O(n)</span> time.</p>
</section>
<p>Half of the KMP algorithm implementations are actually <a href="http://www-igm.univ-mlv.fr/~lecroq/string/node8.html">the MP algorithm</a>. <a href="http://twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell">Twan van Laarhoven's implementation</a>, the earlier version of the <a href="http://hackage.haskell.org/package/KMP-0.1.0.2">KMP</a> package and even <a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Wikipedia's page</a>. Although both KMP and MP runs in <span class="math inline">O(n)</span> time, KMP uses at most <span class="math inline">O(\log m)</span> time to advance to match the next element in the list when MP could take <span class="math inline">O(m)</span> comparisons. More concretely, KMP could output the sequence <span class="math inline">m_0,\ldots,m_{n-1}</span> in <span class="math inline">O(n)</span> time, where <span class="math inline">m_i=1</span> iff <span class="math inline">pat</span> is a suffix of <span class="math inline">text[0..i]</span>, and the time between output is <span class="math inline">O(\log m)</span>.<br />
This added benefit comes at a cost. In the MP algorithm, the failure table has only one <span class="math inline">-1</span>. The failure table for KMP, there is no <span class="math inline">-1</span>, and everything just goes to <span class="math inline">0</span> instead. If one tries to not use any indices, and want to separates the searching and the table building, one would need a special element to treat the <span class="math inline">0</span> positions.</p>
<p>Comparing to the <a href="http://hackage.haskell.org/package/KMP-0.1.0.2">KMP package</a>, the implementation here doesn't use any array.</p>
<h1 id="the-algorithm"><span class="header-section-number">1</span> The algorithm</h1>
<p>We build the a automaton <span class="math inline">A</span> using a input string <span class="math inline">S = a_0,\ldots,a_{m-1}</span>. The automaton consist of states <span class="math inline">nil,s_0,\ldots,s_{m-1}</span>.</p>
<p>Because of laziness, it is built incrementally. The total running time is <span class="math inline">O(n)</span>, even if <span class="math inline">m</span> is much larger than <span class="math inline">n</span>.</p>
<p><span class="math inline">\delta</span> is the transition function, <span class="math inline">\delta(s_i,a_i)=s_{i+1}</span>, and <span class="math inline">\delta(s_i,x)=f_i</span> for <span class="math inline">x\neq a_i</span>, where <span class="math inline">f_i</span> is the failure state associated with state <span class="math inline">s_i</span>. We call <span class="math inline">a_i</span> the value of <span class="math inline">s_i</span>.</p>
<p>One would also want to know if an state is accepting state or not. This prompt us to use the following declaration for the automaton.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Automaton</span> a <span class="fu">=</span> <span class="dt">Node</span> {<span class="ot">value   ::</span> a,
<span class="ot">                         success ::</span> <span class="dt">Automaton</span> a,
<span class="ot">                         failure ::</span> <span class="dt">Automaton</span> a,
<span class="ot">                         accept  ::</span> <span class="dt">Bool</span>
                         } <span class="fu">|</span> 
                   <span class="dt">Null</span> {<span class="ot">success ::</span> <span class="dt">Automaton</span> a,
<span class="ot">                         accept ::</span> <span class="dt">Bool</span>}

isNull (<span class="dt">Null</span> _ _) <span class="fu">=</span> <span class="dt">True</span>
isNull _ <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>Assume we have built a automaton, then doing a matching is quite easy. Just simulate the automaton. It's important to notice the <code>next</code> and <code>stay</code> are saying if we want to read the next character or stay at the same character. The code below is a generalized version of matching. It basically does a fold while we match. <code>isInfixOf'</code> is an example of how to use <code>matchFold</code> to test if a list is a infix in another list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">matchFold ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Automaton</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ([a]<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> ([a]<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b
matchFold _ [] _ _ identity <span class="fu">=</span> identity
matchFold state text nomat mat identity <span class="fu">=</span> match&#39; state text
  <span class="kw">where</span> match&#39; _ [] <span class="fu">=</span> identity
        match&#39; a (x<span class="fu">:</span>xs)
          <span class="fu">|</span> not (isNull a) <span class="fu">&amp;&amp;</span> value a <span class="fu">/=</span> x <span class="fu">=</span> stay
          <span class="fu">|</span> not (accept a)                 <span class="fu">=</span> nomat (x<span class="fu">:</span>xs) next
          <span class="fu">|</span> otherwise                      <span class="fu">=</span> mat   (x<span class="fu">:</span>xs) next
          <span class="kw">where</span> next <span class="fu">=</span> match&#39; (success a) xs
                stay <span class="fu">=</span> match&#39; (failure a) (x<span class="fu">:</span>xs)

<span class="ot">isInfixOf&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isInfixOf&#39; pattern text
 <span class="fu">|</span> null pattern <span class="fu">=</span> <span class="dt">True</span>
 <span class="fu">|</span> otherwise    <span class="fu">=</span> or <span class="fu">$</span> matchFold (buildAutomaton pattern) text (const (<span class="dt">False</span><span class="fu">:</span>)) (const (<span class="dt">True</span><span class="fu">:</span>)) []</code></pre></div>
<p>It is obvious how we can build the entire automaton except for the failure transition.</p>
<p>Another way to reason about it. We impose an order on a set of strings <span class="math inline">S</span> by measuring the length of the string, so this order is a linear order when the set of strings have different length. Let <span class="math inline">Prefixes(s)</span> to be the set of all prefixes of <span class="math inline">s</span>, <span class="math inline">Suffixes(s)</span> to be the set of all suffixes of <span class="math inline">s</span>. <span class="math display">\displaystyle \begin{aligned}
Border(s) &amp;= Prefixes(s)\cap Suffixes(s)\\
Border&#39;(sa) &amp;= \{x|x\in Border(s),xa\not\in Border(sa)\}\\
b(s) &amp;= \max(Border(s)\backslash \{s\})\\
b&#39;(sa) &amp;= \max(Border&#39;(sa))
\end{aligned}</span></p>
<p>Assume we try to compute <span class="math inline">b(x)</span> for a string <span class="math inline">x</span>, we first build the function <span class="math inline">next</span>, such that <span class="math inline">next</span> iterates through <span class="math inline">Prefix(x)</span> by length, and <span class="math inline">last</span> is a function that returns the last element in the string. We have the following relation for <span class="math inline">sa</span> a prefix of <span class="math inline">x</span>, where <span class="math inline">s</span> is a string and <span class="math inline">a</span> is in the alphabet.</p>
<p><span class="math display">\displaystyle 
b(sa) = \begin{cases} next(b(s)) &amp; last(next(b(s))) = a\\
        next(b(b(s)a)) &amp; otherwise \end{cases}
</span></p>
<p><span class="math display">\displaystyle 
b&#39;(sa) = \begin{cases} b&#39;(next(b(s))) &amp; last(b&#39;(next(b(s)))) = a\\
        b&#39;(b&#39;(next(b(s))a)) &amp; otherwise \end{cases}
</span> In fact, one can see the failure function is precisely <span class="math inline">b&#39;</span>. What's not clear is how can one compute this function without keep track of the entire history of <span class="math inline">b</span>.</p>
<p>The essential function is <code>build ys s</code>. It builds the automaton by consume the remaining string, and <code>s</code> records essential information to compute the transition of the failure function.</p>
<ol type="1">
<li><span class="math inline">value s = value t</span>, then <span class="math inline">b(t) = b(s)</span>, and we would know <span class="math inline">b&#39;(next(t)) = next(s)</span>.</li>
<li><span class="math inline">value s \neq value t</span>, then <span class="math inline">b(t) = s</span>, and we would compute <span class="math inline">b&#39;(next(t))</span> by searching back through failure edges.</li>
</ol>
<p>Note we have also computed <span class="math inline">b&#39;(next(t))</span>, which allow us to compute the next node <span class="math inline">next(t)</span>.</p>
<p>So in <code>build ys s</code>, <code>s</code> will precisely store the state <span class="math inline">b&#39;(t)</span>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">buildAutomaton ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a
buildAutomaton (x<span class="fu">:</span>xs) <span class="fu">=</span> automaton
  <span class="kw">where</span> automaton <span class="fu">=</span> <span class="dt">Node</span> x (build xs automaton) (<span class="dt">Null</span> automaton <span class="dt">False</span>) (null xs)
        build [] s <span class="fu">=</span> s
        build (x<span class="fu">:</span>xs) s
         <span class="fu">|</span> x <span class="fu">==</span> value s <span class="fu">=</span> success s <span class="ot">`nextNode`</span> failure s
         <span class="fu">|</span> otherwise    <span class="fu">=</span> newS      <span class="ot">`nextNode`</span> s
         <span class="kw">where</span> nextNode a b <span class="fu">=</span> <span class="dt">Node</span> x (build xs a) b (null xs)
               newS         <span class="fu">=</span> success <span class="fu">$</span> until (\s<span class="ot">-&gt;</span>isNull s <span class="fu">||</span> x <span class="fu">==</span> value s) failure s</code></pre></div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-04-11. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Fri, 11 Apr 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-04-11-the-kmp-algorithm-in-haskell.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>A common <strong>3SUM-hard</strong> reduction</title>
    <link>https://chaoxuprime.com/blog/posts/2014-04-05-a-common-3sum-hard-reduction.html</link>
    <description><![CDATA[<br />
<div>
<p>I'm writing this to address a problem I often hear from friends. They usually get it from some technical interview.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Let <span class="math inline">A</span> be an array of <span class="math inline">n</span> numbers, decide if there exist index <span class="math inline">i,j,k</span>, such that <span class="math inline">A[i]+A[j]=A[k]</span>.</p>
</section>
<p>The problem is <strong>3SUM-hard</strong>. We reduce the problem <strong>3SUM</strong> to the above problem in linear time.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span><span class="name"><strong>3SUM</strong></span></span>
<p>Does there exist <span class="math inline">a,b,c\in S</span>, such that <span class="math inline">a+b+c=0</span>?</p>
</section>
<p>Consider a instance of <strong>3SUM</strong>. Let <span class="math inline">m=3 \max(S \cup -S)+1</span>. Store <span class="math inline">\{m\}+S</span> and <span class="math inline">\{2m\}-S</span> as elements in the array <span class="math inline">A</span>.</p>
<p>Claim: There exist i,j,k such that <span class="math inline">A[i]+A[j]=A[k]</span> iff there exist <span class="math inline">a,b,c\in S</span> such that <span class="math inline">a+b+c=0</span>.</p>
<p>If there exist <span class="math inline">i,j,k</span> such that <span class="math inline">A[i]+A[j]=A[k]</span>, this implies <span class="math inline">A[i]=a+m,A[j]=b+m,A[k]=2m+(-c)</span> for some <span class="math inline">a,b,c\in S</span>. The other direction is similar.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-04-05. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Sat, 05 Apr 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-04-05-a-common-3sum-hard-reduction.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Selection in a sorted matrix</title>
    <link>https://chaoxuprime.com/blog/posts/2014-04-02-selection-in-a-sorted-matrix.html</link>
    <description><![CDATA[<br />
<div>
<p>A matrix is sorted if every row and column are non-increasing.</p>
<p>A common interview problem asks for the <span class="math inline">k</span>th smallest number in a sorted matrix, and usually people give an <span class="math inline">O(k\log k)</span> algorithm. Wlog we can assume all the numbers in the matrix are distinct, as we can always break the ties by factoring in the position of the number in the matrix.</p>
<p>There is a <span class="math inline">O(k)</span> time solution. In fact, <span class="math inline">O(\min(k, m))</span> if it's a <span class="math inline">n\times m</span> matrix and <span class="math inline">n\leq m</span>.</p>
<p>I'm frustrated that there isn't a good description of such an algorithm. The most common reference people provide is <span class="citation" data-cites="Mirzaian198513">[<a href="#ref-Mirzaian198513">1</a>]</span>. However there are a few downsides of that paper. It only works when <span class="math inline">n=m</span> and it is still a bit complicated. So here I will give a short description to a modified version of the algorithm.</p>
<p>One can see the idea closely resemble what happens in fractional cascading, we basically squeeze the unknown values between known values, so we don't have to look at most of the unknown values.</p>
<p>First, we assume the matrix we care about is a <span class="math inline">n\times m</span> matrix <span class="math inline">A</span>. Both <span class="math inline">n</span> and <span class="math inline">m</span> are power of <span class="math inline">2</span> and <span class="math inline">n\leq m</span>.</p>
<p>Let <span class="math inline">A_o</span> be the matrix we get by removing all even index columns from <span class="math inline">A</span>, and add the last column.</p>
<p>In <span class="citation" data-cites="Mirzaian198513">[<a href="#ref-Mirzaian198513">1</a>]</span>, they used <span class="math inline">A_{o,o}</span>, which is defined as only retain positions with odd coordinates, but I found it nicer to consider things by only stripping one coordinate. In particular, it gave a much nicer proof for the following result.</p>
<section class="theorem-environment Definition" id="Definition-1">
<span class="theorem-header"><span class="type">Definition</span><span class="index">1</span></span>
<p><span class="math inline">r(a,A)</span> is the number of elements in matrix <span class="math inline">A</span> smaller or equal to <span class="math inline">a</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Let <span class="math inline">A</span> be a sorted <span class="math inline">n\times m</span> matrix, then <span class="math inline">2(r(a,A_o) - n) \leq r(a,A)\leq 2r(a,A_o)</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>For any fixed <span class="math inline">i</span>, let <span class="math inline">f(i)</span> be the largest <span class="math inline">j</span>, such that <span class="math inline">A_{i,j}\geq a</span>. <span class="math inline">r(a,A)=\sum_{i=1}^n f(i)</span>, <span class="math inline">r(a,A_o)=\sum_{i=1}^n \lceil f(i)/2 \rceil \leq r(a,A)/2 +n</span>. On the other hand <span class="math inline">\sum_{i=1}^n f(i)/2 \leq r(a,A_o)</span>.</p>
</section>
<p>This means if we want to find an element of rank <span class="math inline">k</span> in <span class="math inline">A</span>, we can first find element of rank <span class="math inline">k/2+n</span> and <span class="math inline">k/2</span> in <span class="math inline">A_o</span>, and we know the solution would be in between. The remaining operation takes <span class="math inline">O(m)</span> time:</p>
<ol type="1">
<li>Use a flood fill starting from the position of <span class="math inline">k/2</span>th element in <span class="math inline">A_o</span> and find at most <span class="math inline">2n</span> positions where the element of rank <span class="math inline">k</span> could reside. Namely it select elements in <span class="math inline">A</span> that is in between the <span class="math inline">k/2</span>th element and <span class="math inline">k/2+n</span>th in <span class="math inline">A_o</span>. We can do this because all these elements are connected in a component.</li>
<li>While doing the flood fill, it can also find the rank of the <span class="math inline">k/2</span>th element in <span class="math inline">A_o</span> in the matrix <span class="math inline">A</span> for no extra cost.</li>
<li>A linear time selection algorithm on all the elements resulted from the flood fill.</li>
</ol>
<p>This would give us a recursive algorithm if instead of just finding <span class="math inline">k</span>th number, it finds the <span class="math inline">k_1</span>th and <span class="math inline">k_2</span>th number at the same time. As long as <span class="math inline">|k_1-k_2|=O(m)</span>, we can find them both only with a <span class="math inline">O(m)</span> extra time. <span class="math inline">k_1</span> and <span class="math inline">k_2</span> will be the upper and lower bounds respectively. Some basic algebra shows we will <span class="math inline">|k_1-k_2|=O(m)</span> inside each recursive step if we start with <span class="math inline">k_1=k_2=k</span>.</p>
<p>Let <span class="math inline">T(n,m)</span> be the time used when the matrix is of size <span class="math inline">n\times m</span>, and <span class="math inline">n\leq m</span>. Certainly <span class="math inline">T(1,m)=1</span>, and the rest follow the recursive relation <span class="math inline">T(n,m) = cm + T(n,m/2)</span> for some constant <span class="math inline">c</span>.</p>
<p>If <span class="math inline">n&gt;m</span>, we can rotate the matrix implicitly to get the same running time.</p>
<p>Solving it gives us the desired running time <span class="math inline">O(m)</span>. This is also a <span class="math inline">O(k)</span> time algorithm because we only need to consider the <span class="math inline">k\times k</span> submatrix in the up-left position.</p>
<p>A Haskell implementation here, it requires a linear time rank selection algorithm <code>selectRank</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">RankSelection</span>

<span class="kw">type</span> <span class="dt">Matrix</span> a <span class="fu">=</span> (<span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span><span class="ot">-&gt;</span>a, <span class="dt">Int</span>, <span class="dt">Int</span>)

<span class="co">-- The input is an matrix sorted in both row and column order</span>
<span class="co">-- This selects the kth smallest element. (0th is the smallest)</span>
<span class="ot">selectMatrixRank ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> a
selectMatrixRank k (f,n,m)
 <span class="fu">|</span> k <span class="fu">&gt;=</span> n<span class="fu">*</span>m <span class="fu">||</span> k <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> error <span class="st">&quot;rank doesn&#39;t exist&quot;</span>
 <span class="fu">|</span> otherwise         <span class="fu">=</span> fst <span class="fu">$</span> fst <span class="fu">$</span> biselect k k (f&#39;, min n (k<span class="fu">+</span><span class="dv">1</span>), min m (k<span class="fu">+</span><span class="dv">1</span>))
 <span class="kw">where</span> f&#39; x y<span class="fu">=</span> (f x y, (x, y))

<span class="ot">biselect ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> (a,a)
biselect lb ub (f&#39;,n&#39;,m&#39;) <span class="fu">=</span> join (<span class="fu">***</span>) (selectRank values) (lb<span class="fu">-</span>ra, ub<span class="fu">-</span>ra)
 <span class="kw">where</span> mat<span class="fu">@</span>(f,n,m)
        <span class="fu">|</span> n&#39; <span class="fu">&gt;</span> m&#39;   <span class="fu">=</span> (flip f&#39;, m&#39;, n&#39;)
        <span class="fu">|</span> otherwise <span class="fu">=</span> (f&#39;, n&#39;, m&#39;)
       (a, b)
        <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">3</span>     <span class="fu">=</span> (f <span class="dv">0</span> <span class="dv">0</span>, f (n<span class="fu">-</span><span class="dv">1</span>) (m<span class="fu">-</span><span class="dv">1</span>))
        <span class="fu">|</span> otherwise <span class="fu">=</span> biselect lb&#39; ub&#39; halfMat
       (lb&#39;, ub&#39;)   <span class="fu">=</span> (lb <span class="ot">`div`</span> <span class="dv">2</span>, min ((ub <span class="ot">`div`</span> <span class="dv">2</span>) <span class="fu">+</span> n) (n <span class="fu">*</span> hm <span class="fu">-</span> <span class="dv">1</span>))
       (ra, values) <span class="fu">=</span> (rankInMatrix mat a, selectRange mat a b)
       halfMat
        <span class="fu">|</span> even m <span class="fu">=</span> (\x y<span class="ot">-&gt;</span>f x (<span class="kw">if</span> y <span class="fu">&lt;</span> hm <span class="fu">-</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">2</span> <span class="fu">*</span> y <span class="kw">else</span> <span class="dv">2</span> <span class="fu">*</span> y <span class="fu">-</span> <span class="dv">1</span>), n, hm)
        <span class="fu">|</span> odd  m <span class="fu">=</span> (\x y<span class="ot">-&gt;</span>f x (<span class="dv">2</span><span class="fu">*</span>y), n, hm)
       hm <span class="fu">=</span> m <span class="ot">`div`</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">1</span>

<span class="co">-- the rank of an element in the matrix</span>
<span class="ot">rankInMatrix ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
rankInMatrix mat a <span class="fu">=</span> sum (map (\(_,y)<span class="ot">-&gt;</span><span class="dv">1</span><span class="fu">+</span>y) <span class="fu">$</span> frontier mat a)<span class="fu">-</span><span class="dv">1</span>

<span class="co">-- select all elements x in the matrix such that a &lt;= x &lt;= b </span>
<span class="ot">selectRange ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
selectRange mat<span class="fu">@</span>(f,_,_) a b <span class="fu">=</span> concatMap search (frontier mat b)
 <span class="kw">where</span> search (x,y) <span class="fu">=</span> takeWhile (<span class="fu">&gt;=</span>a) <span class="fu">$</span> map (f x) [y,y<span class="fu">-</span><span class="dv">1</span><span class="fu">..</span><span class="dv">0</span>]

<span class="ot">frontier ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>)]
frontier (f,n,m) b <span class="fu">=</span> step <span class="dv">0</span> (m<span class="fu">-</span><span class="dv">1</span>)
 <span class="kw">where</span> step i j 
        <span class="fu">|</span> i <span class="fu">&gt;</span> n<span class="fu">-</span><span class="dv">1</span> <span class="fu">||</span> j <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> []
        <span class="fu">|</span> f i j <span class="fu">&lt;=</span> b       <span class="fu">=</span> (i,j)<span class="fu">:</span>step (i<span class="fu">+</span><span class="dv">1</span>) j
        <span class="fu">|</span> otherwise        <span class="fu">=</span> step i (j<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Mirzaian198513">
<p>[1] A. Mirzaian, E. Arjomandi, <strong>Selection in x + y and matrices with sorted rows and columns</strong>, Information Processing Letters. 20 (1985) 13–17.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-04-02. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Wed, 02 Apr 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-04-02-selection-in-a-sorted-matrix.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Bisect circle for a balanced set of points</title>
    <link>https://chaoxuprime.com/blog/posts/2014-03-27-bisect-circle-even-point-set.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p><span class="math inline">S</span> is a set of <span class="math inline">n</span> points on the unit circle. No two points in <span class="math inline">S</span> lies on the same diagonal. Find a line that passes through the origin that divide the unit circle into two open semicircles, such that each piece have the same number of points in <span class="math inline">S</span>.</p>
</section>
<p>A harder version of this problem is <a href="http://sarielhp.org/research/algorithms/quals/19xx/1995-a.ps">Problem 1 in UIUC's 1995 Fall Theory Qual</a>. Let <span class="math inline">C</span> be the unit circle. The angle made by the lines and the <span class="math inline">x</span>-axis uniquely defines the line. Let the line pass through the origin with an angle <span class="math inline">\theta</span> be <span class="math inline">l_\theta</span>. Let <span class="math inline">C(a,b) = \cup_{\theta \in (a,b)} l_\theta \cap C</span>, <span class="math inline">L</span> is the semicircle below the <span class="math inline">x</span>-axis, <span class="math inline">U</span> is the semicircle above the <span class="math inline">x</span>-axis. <span class="math inline">U(a,b)</span> and <span class="math inline">L(a,b)</span> are define the same way as <span class="math inline">C(a,b)</span>.</p>
<p>We can solve this problem in <span class="math inline">O(n)</span> time by reducing it to a somewhat more general problem.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given two arcs <span class="math inline">L(a,b)</span> and <span class="math inline">U(a,b)</span> and a set of points <span class="math inline">S</span> on lying on the two arcs. <span class="math inline">|S\cap L(a,b)|\geq k</span> and <span class="math inline">|S\cap U(a,b)|\leq k</span>. <span class="math inline">|l_\theta\cap S|\leq 1</span> for all <span class="math inline">\theta\in(a,b)</span>. Find a <span class="math inline">l_\theta</span>, such that <span class="math inline">\theta\in(a,b)</span> and <span class="math inline">|S\cap (L(a,\theta)\cup U(\theta,b))|=k</span> in <span class="math inline">O(|S|)</span> time.</p>
</section>
<p>Let's consider an algorithm that returns line <span class="math inline">l_\theta</span> be <span class="math inline">partition(S,a,b,k)</span>.</p>
<p>Such a line must exist. Proof left as an exercise to the reader.</p>
<p>Note if we can solve this problem. We just need to rotate the circle so the points in the upper semicircle is at most the number of points in the lower semicircle, and then compute <span class="math inline">partition(S,0,\pi,n/2)</span>.</p>
<p>Let's consider how to compute <span class="math inline">partition(S,a,b,k)</span>. First, note for any line, we can decide the number of points in the intersection of constant number of half planes in linear time. This allow us to do cardinality computations of points lying on some arc in linear time.</p>
<p>We can find the <span class="math inline">i</span>th point on an arc from the left by using a linear time selection algorithm.</p>
<p>If the lower arc contains more than <span class="math inline">2k</span> points, find the <span class="math inline">k</span>th point from the left in the lower arc. Assume it intersects <span class="math inline">l_\theta</span>. We return <span class="math inline">partition(S\cap C(a,\theta),a,\theta,k-|S\cap U(a,\theta)|)</span>.</p>
<p>So we are only dealing with the case where the lower arc contains less than <span class="math inline">2k</span> points. We find the <span class="math inline">k/2</span>th point from the left in the lower arc. Assume it intersects <span class="math inline">l_\theta&#39;</span>, and let <span class="math inline">\theta=\theta&#39;+\epsilon</span> for a small enough epsilon(which would be apparent how small it has to be, and it can be found in linear time also.). Let <span class="math inline">(u,v,y,x) = (|S\cap L(a,\theta)|,|S\cap L(\theta,b)|,|S\cap U(a,\theta)|,|S\cap U(\theta,b)|)</span>. Note <span class="math inline">u=k/2</span> and <span class="math inline">u+x = |S\cap (L(a,\theta)\cup U(\theta,b))|</span>, <span class="math inline">x+y\leq k</span>, <span class="math inline">u+v\geq k</span>.</p>
<ul>
<li>If <span class="math inline">u+x = k</span>, then we are done, return <span class="math inline">l_\theta&#39;</span>.</li>
<li>If <span class="math inline">u+x &gt; k</span>, then return <span class="math inline">partition(S\cap C(a,\theta),a,\theta,k-x)</span>.</li>
<li>If <span class="math inline">u+x &lt; k</span>, then return <span class="math inline">partition(S\cap C(\theta,b),\theta,b,k/2)</span>.</li>
</ul>
<figure>
<img src="/files/bisect_circle.png" alt="Bisect Circle Example" /><figcaption>Bisect Circle Example</figcaption>
</figure>
<p>One can verify it's valid to call the partition functions, namely the precondition for the number of points lower arc and upper arc is satisfied. There might be some off by one error somewhere. But the general idea is there.</p>
<p>When <span class="math inline">k</span> is small enough we solve the problem by brute force.</p>
<p>Every time we nest a <span class="math inline">partition</span> call, we spend linear time on the current point sets, then we call the function again but with a point set of size a constant times smaller. This give us the linear time algorithm required.</p>
<p>This is actually a special case of the ham sandwich problem in <span class="math inline">2</span>D. There are <span class="math inline">n</span> red points and <span class="math inline">m</span> blue points on the plane. Find a line such that it divides the plane into two half-planes, so the interior of each half-plane contains at most <span class="math inline">\lfloor n/2 \rfloor</span> red points and <span class="math inline">\lfloor m/2 \rfloor</span> blue points. So our problem is when the red point is purely the origin.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-03-27. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Thu, 27 Mar 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-03-27-bisect-circle-even-point-set.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Sushi sharing problem</title>
    <link>https://chaoxuprime.com/blog/posts/2014-03-26-sharing-sushi.html</link>
    <description><![CDATA[<br />
<div>
<p>The problem was first brought up by <a href="http://www.cs.sunysb.edu/~smccauley/">Sam McCauley</a> when I was still in Stony Brook.</p>
<p>Two germophobic friends are sharing sushi. There are two kind of sushi, <span class="math inline">0</span> and <span class="math inline">1</span>. The sushi are lied out on a <span class="math inline">n\times m</span> matrix. There are <span class="math inline">a</span> sushi of type <span class="math inline">0</span> and <span class="math inline">b</span> sushi of type <span class="math inline">1</span>, both are even numbers and <span class="math inline">a+b = nm</span>. One can pick up a sushi with a chopstick by picking it up horizontally, or vertically. It will touch the adjacent sushis horizontally or vertically, respectively.</p>
<p>Each person want to eat exactly <span class="math inline">a/2</span> sushi of type <span class="math inline">0</span> and <span class="math inline">b/2</span> sushi of type <span class="math inline">1</span>, and no one want to eat a sushi touched by someone else. Is this always possible? Yes it is!</p>
<p>First, it's easy to see each person can pick up a entire row or column, and collapse the remaining matrix. All the remaining sushi in the matrix are clean. We will assume each person pick up a entire row/column.</p>
<p>We prove this by induction. Let <span class="math inline">f(i)</span> be the number of <span class="math inline">1</span>'s in the <span class="math inline">i</span>th column, and <span class="math inline">f(S)=\set{f(i)|i\in S}</span>. As long as both friends pick up the same number of each sushi before collapse the matrix, we can go to a smaller case.</p>
<p>Before the case by case analysis, we note of two conditions:</p>
<dl>
<dt>Even sum condition</dt>
<dd><p><span class="math inline">\sum_{i\in [1..m]} f(i)=b</span>, it must be even.</p>
</dd>
<dt>Even side condition</dt>
<dd><p>Because <span class="math inline">nm</span> is even, either <span class="math inline">n</span> or <span class="math inline">m</span> is even.</p>
</dd>
</dl>
<ul>
<li><p><span class="math inline">n&gt;m</span>, rotate the matrix.</p></li>
<li><p><span class="math inline">n+1&lt;m</span>, by pigeonhole principle, <span class="math inline">f(i)=f(j)</span> for some <span class="math inline">i</span> and <span class="math inline">j</span>. One person pick <span class="math inline">i</span>th column and the other pick the <span class="math inline">j</span>th column.</p></li>
<li><span class="math inline">n+1\geq m</span> and <span class="math inline">m\geq \frac{1 + \sqrt{1+16n}}{2}</span>. If there is no <span class="math inline">2</span> columns with the same number of <span class="math inline">0</span>'s and <span class="math inline">1</span>'s, then let <span class="math inline">f([1..m])=S</span> to be a set of <span class="math inline">m</span> elements. Now, consider we pick 4 distinct elements <span class="math inline">a,b,c,d</span> from <span class="math inline">S</span> and if <span class="math inline">a+b=c+d</span>, then we can let one person pick columns <span class="math inline">f^{-1}(\set{a,b})</span> and the other pick columns <span class="math inline">f^{-1}(\set{c,d})</span>. Note if <span class="math inline">a+b=c+d</span>, and we know that <span class="math inline">a,b</span> and <span class="math inline">c,d</span> are distinct, and <span class="math inline">\set{a,b}\neq \set{c,d}</span>, then <span class="math inline">a,b,c,d</span> must be all distinct. <span class="math inline">a+b</span> can take <span class="math inline">2n-1</span> different values, between <span class="math inline">1</span> and <span class="math inline">2n-1</span>. There are <span class="math inline">{m \choose 2}</span> pairwise sums. This shows there must be at least <span class="math inline">2</span> pairs that both have the same difference by pigeonhole principle when <span class="math inline">{m\choose 2}\geq 2n</span>, which is true when <span class="math inline">m\geq \frac{1 + \sqrt{5+16n}}{2}</span>. To translate this,
<ul>
<li>If <span class="math inline">n+1=m</span>, then this is always true when <span class="math inline">n\geq 3</span>.</li>
<li>If <span class="math inline">n=m</span>, then this is always true when <span class="math inline">n\geq 5</span>.</li>
</ul></li>
<li><p><span class="math inline">n\leq 2</span> and <span class="math inline">n+1=m</span>. Since both <span class="math inline">0+1</span> and <span class="math inline">0+1+2</span> is odd, we must have two columns have the same value.</p></li>
<li><p><span class="math inline">n=m=2</span>. If there is no <span class="math inline">2</span> columns with the same number of <span class="math inline">0</span>'s and <span class="math inline">1</span>'s, then <span class="math inline">f([1..2])=\set{0,2}</span> in order to satisfy the even condition. But each row would have the same number of different kind of sushi. Let each friend take a row.</p></li>
<li><p><span class="math inline">n=m=3</span>. This is not possible with even side condition.</p></li>
<li><p><span class="math inline">n=m=4</span>. This is the last case. If no <span class="math inline">2</span> columns have same number of <span class="math inline">0</span>'s and <span class="math inline">1</span>'s, then <span class="math inline">f([1..4])=\set{a_1,a_2,a_3,a_4}</span> where <span class="math inline">a_1&lt;a_2&lt;a_3&lt;a_4</span> and has to equal to one of the following due to the even sum condition. In all cases, <span class="math inline">a_1+a_4=a_2+a_3</span>.</p>
<ul>
<li><span class="math inline">0,1,2,3</span></li>
<li><span class="math inline">0,1,3,4</span></li>
<li><span class="math inline">1,2,3,4</span></li>
</ul></li>
</ul>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-03-26. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Wed, 26 Mar 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-03-26-sharing-sushi.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Even cycle in a simple graph</title>
    <link>https://chaoxuprime.com/blog/posts/2014-03-08-even-cycle-in-a-simple-graph.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p><span class="math inline">G=(V,E)</span> is a simple graph, decide if there exist a cycle of even length in <span class="math inline">G</span>.</p>
</section>
<p>The problem comes from 2014 Spring UIUC Theory Qualify Exam.</p>
<h1 id="characterizations"><span class="header-section-number">1</span> Characterizations</h1>
<p>Let <span class="math inline">\lambda(u,v)</span> denote the local edge connectivity of vertices <span class="math inline">u</span> and <span class="math inline">v</span>. It's the same as the largest number of edge disjoint paths connecting <span class="math inline">u</span> and <span class="math inline">v</span>. <span class="math inline">\overline{\lambda}(G) = \max_{u,v\in V} \{\lambda(u,v)\}</span>. Similarly, <span class="math inline">\kappa(u,v)</span> is defined as local vertex connectivity, and <span class="math inline">\overline{\kappa}(G) = \max_{u,v\in V} \{\kappa(u,v)\}</span></p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>If <span class="math inline">\kappa(u,v) \geq 3</span> for some <span class="math inline">u,v\in V</span>, then there exist an even cycle.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>There are 3 vertex disjoint paths <span class="math inline">p_1,p_2,p_3</span> from <span class="math inline">u</span> to <span class="math inline">v</span>, thus it contains cycle <span class="math inline">p_1 p_2^{-1}</span>,<span class="math inline">p_1 p_3^{-1}</span> and <span class="math inline">p_2 p_3^{-1}</span>. One of them will have even length.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>If <span class="math inline">\overline{\lambda}(G)\geq 3</span>, then <span class="math inline">\overline{\kappa}(G)\geq 3</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>If <span class="math inline">\lambda(u,v)\geq 3</span>, we consider the 3 edge paths between <span class="math inline">u,v</span>. Let them be <span class="math inline">p_1,p_2,p_3</span>. Notice if none of them intersect at a vertex, <span class="math inline">\kappa(u,v)\geq 3</span>.</p>
<p>If <span class="math inline">p_1,p_2</span> intersects and has their first intersection at <span class="math inline">v&#39;</span>. Let <span class="math inline">p_1&#39;,p_1&#39;&#39;</span> and <span class="math inline">p_2&#39;</span> be the paths following <span class="math inline">p_1</span> from <span class="math inline">u</span> to <span class="math inline">v&#39;</span> and <span class="math inline">v&#39;</span> to <span class="math inline">v</span>, and the paths following <span class="math inline">p_2</span> from <span class="math inline">u</span> to <span class="math inline">v&#39;</span>. <span class="math inline">p_1&#39; p_2&#39;^{-1}</span> is a cycle that contains <span class="math inline">u</span> and <span class="math inline">v&#39;</span>. <span class="math inline">\lambda(u,v&#39;)\geq 3</span> because there is an additional edge disjoint path <span class="math inline">p_3 p_1&#39;&#39;^{-1}</span> from <span class="math inline">u</span> to <span class="math inline">v&#39;</span>.</p>
<p>So now we can consider <span class="math inline">u,v&#39;</span>, where <span class="math inline">\lambda(u,v&#39;)\geq 3</span> and <span class="math inline">u,v&#39;</span> is in some cycle <span class="math inline">C</span>. Consider another path <span class="math inline">P</span> from <span class="math inline">u</span> to <span class="math inline">v&#39;</span> that is edge disjoint from the cycle. Let <span class="math inline">t</span> be the first vertex where <span class="math inline">P</span> intersects <span class="math inline">C</span>. Clearly, <span class="math inline">\kappa(u,t)\geq 3</span>.</p>
</section>
<p>It should be easy to show that</p>
<section class="theorem-environment Theorem" id="Theorem-4">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">4</span></span>
<p>If <span class="math inline">\overline{\lambda}(G)=2</span>, then all cycles in the graph are edge disjoint.</p>
</section>
<h1 id="a-complicated-yet-obvious-algorithm"><span class="header-section-number">2</span> A complicated yet obvious algorithm</h1>
<ol type="1">
<li>Compute if <span class="math inline">\overline{\lambda}(G)&gt;2</span>, if so, return true.</li>
<li>Compute if there is an even cycle in linear time.</li>
</ol>
<p>We first sparsify the graph with Nagamochi and Ibaraki's linear time algorithm that preserves the edge connectivity up to <span class="math inline">3</span>. After spending <span class="math inline">O(n+m)</span> time, the graph has at most <span class="math inline">3n</span> edges. We want to find a global maximum min-cut in the resulting graph. Either <span class="math inline">s-t</span>-min-cut is the global maximum min-cut, or <span class="math inline">s,t</span> are in the same component of the global maximum min-cut. One can modify Stoer-Wagner algorithm to find <span class="math inline">\overline{\lambda}(G)</span> in <span class="math inline">O(nm+n^2\log n)=O(n^2\log n)</span> time. Since our graph is unweighted we can do it better in <span class="math inline">O(n^2)</span> time.</p>
<p>Another approach is to show the graph cannot contain a <a href="http://en.wikipedia.org/wiki/Diamond_graph">diamond graph</a> as a minor and use any general graph minor recognition algorithm. The fastest I know is the <span class="math inline">O(n^3)</span> one from the original Robertson–Seymour paper. There are some <a href="http://cstheory.stackexchange.com/questions/7928/the-complexity-of-determining-if-a-fixed-graph-is-a-minor-of-another">discussion on cstheory</a> on what is know about this algorithm.</p>
<p>However we can do it better, because we can easily check graphs without a diamond as a minor has treewidth two. So we can first check if the graph have a fixed treewidth in linear time<span class="citation" data-cites="fixedparametertreewidth">[<a href="#ref-fixedparametertreewidth">1</a>]</span>. Next, we can then apply a linear time minor testing algorithm on graphs with bounded branch width(which is implied by bounded treewidth)<span class="citation" data-cites="fixedsurfaceminor">[<a href="#ref-fixedsurfaceminor">2</a>]</span>.</p>
<p>The second step is computationally easy. Do a DFS, whenever we find a cycle, check if the cycle is even, delete all those edges, and keep going. The number of steps we take is at most <span class="math inline">O(n+m)</span> time. In fact, we don't really need to delete the edges once we find a cycle, as we know they will never get used by another cycle.</p>
<h1 id="a-much-simpler-algorithm"><span class="header-section-number">3</span> A much simpler algorithm</h1>
<p>Our algorithm above is pretty general and uses some heavy machinery. That's the kind of solution I would give during a qualify exam due to time constraints(well, always use the most powerful technique possible).</p>
<p>The theorems we proved implies one nice corollary</p>
<section class="theorem-environment Corollary" id="Corollary-5">
<span class="theorem-header"><span class="type">Corollary</span><span class="index">5</span></span>
<p>If a graph has no even cycles, then all cycles in the graph are edge disjoint.</p>
</section>
<p>This kind of graph has a name, a <a href="http://en.wikipedia.org/wiki/Cactus_graph">cactus graph</a>. It is so special we can recognize it in linear time. A graph is a cactus if once we build a DFS tree, every vertex has at most one back edge.</p>
<p>This implies a extremely simple algorithm</p>
<ol type="1">
<li>Run a DFS to build a DFS tree. Let <span class="math inline">d(v)</span> be the depth of a vertex <span class="math inline">v</span> in the tree.</li>
<li>Assume there is a back edge between <span class="math inline">x</span> and <span class="math inline">y</span>, check if there is any back edge end at some node in the unique path from <span class="math inline">x</span> to <span class="math inline">y</span>.</li>
<li>For every vertex <span class="math inline">v</span>, if it has a back edge to some vertex <span class="math inline">u</span>, then check if <span class="math inline">d(v)-d(u)</span> is odd. If it is, return true.</li>
<li>Return false.</li>
</ol>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-fixedparametertreewidth">
<p>[1] H. Bodlaender, <strong>A linear-time algorithm for finding tree-decompositions of small treewidth</strong>, SIAM Journal on Computing. 25 (1996) 1305–1317 <a href="https://doi.org/10.1137/S0097539793251219">10.1137/S0097539793251219</a>.</p>
</div>
<div id="ref-fixedsurfaceminor">
<p>[2] I. Adler, F. Dorn, F. Fomin, I. Sau, D. Thilikos, Faster parameterized algorithms for minor containment, in: H. Kaplan (Ed.), Algorithm Theory - Swat 2010, Springer Berlin Heidelberg, 2010: pp. 322–333 <a href="https://doi.org/10.1007/978-3-642-13731-0_31">10.1007/978-3-642-13731-0_31</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-03-08. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Sat, 08 Mar 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-03-08-even-cycle-in-a-simple-graph.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Faster Pseudo-polynomial Time Algorithm for Subset Sums</title>
    <link>https://chaoxuprime.com/blog/posts/2014-02-26-subset-target-sum.html</link>
    <description><![CDATA[<br />
<div>
<p>This post has been expanded to <a href="http://arxiv.org/abs/1507.02318">a paper</a>.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-02-26. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Wed, 26 Feb 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-02-26-subset-target-sum.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Is the gas enough?</title>
    <link>https://chaoxuprime.com/blog/posts/2014-02-25-is-the-gas-enough.html</link>
    <description><![CDATA[<br />
<div>
<p>I have been trying to use the more general frameworks when I encounter dynamic programming questions, so I can demonstrate the power of abstraction later on.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Let <span class="math inline">D=(V,A)</span> be a directed acyclic graph. <span class="math inline">w(e)</span> is the weight of an arc. A <span class="math inline">s-t</span> path <span class="math inline">e_1,\ldots,e_m</span> is called a <span class="math inline">\alpha</span>-deficient path if <span class="math inline">\sum_{i=1}^k w(e_i) + \alpha \geq 0</span> for all <span class="math inline">1 \leq k\leq m</span>. Find the smallest <span class="math inline">\alpha</span>, such that there is a <span class="math inline">\alpha</span>-deficient <span class="math inline">s-t</span> path.</p>
</section>
<p>One can view this problem as how much gas would one require to travel from <span class="math inline">s</span> to <span class="math inline">t</span>. If one knows how much gas one can gain or lose between arcs.</p>
<p>Let <span class="math inline">D(v)</span> be the value of the minimum deficiency path from <span class="math inline">v</span> to <span class="math inline">t</span>, and <span class="math inline">D(t)=0</span>.</p>
<p><span class="math display">\displaystyle 
D(v) = \min_{(v,u)\in A} \max(D(u)-w((v,u)),0)
</span></p>
<p>Because the graph is acyclic, there is a nice ordering allowing us to compute this nicely.</p>
<p>Note this is exactly the best weight problem<span class="citation" data-cites="Huang08advanceddynamic">[<a href="#ref-Huang08advanceddynamic">1</a>]</span> under the semiring <span class="math inline">(\mathbb{R}\cup \{\infty\},\min,\otimes,\infty,0)</span>, where <span class="math inline">a \otimes b = \max(a-b,0)</span>.</p>
<p>One should prove it's a semiring before using it. Everything seems obvious except the distributive property of the <span class="math inline">\otimes</span> operation. Here is a proof for one of the two distributive laws, the other is left as an exercise to the reader.</p>
<p><span class="math display">\displaystyle \begin{aligned}
(a\oplus b) \otimes c &amp;= \max(\min(a,b)-c,0)\\
&amp;= \max(\min(a-c,b-c),0)\\
&amp;= \min(\max(a-c,0),\max(b-c,0))\\
&amp;= (a \otimes c) \oplus (b \otimes c)
\end{aligned}</span></p>
<p>Can we extend the problem to directed graph with cycles? Yes. This semiring has the property that it is <span class="math inline">k</span>-closed for any graph <span class="math inline">G</span> for <span class="math inline">k</span> depending on <span class="math inline">G</span> and <span class="math inline">w</span>. It means we can't keep going though a cycle and keep producing better solutions. We can run a generic single source shortest distance algorithm<span class="citation" data-cites="Mohri:2002">[<a href="#ref-Mohri:2002">2</a>]</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Huang08advanceddynamic">
<p>[1] L. Huang, <strong>Advanced dynamic programming in semiring and hypergraph frameworks</strong>, (2008).</p>
</div>
<div id="ref-Mohri:2002">
<p>[2] M. Mohri, <strong>Semiring frameworks and algorithms for shortest-distance problems</strong>, J. Autom. Lang. Comb. 7 (2002) 321–350.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-02-25. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Tue, 25 Feb 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-02-25-is-the-gas-enough.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Partial order under contraction</title>
    <link>https://chaoxuprime.com/blog/posts/2014-02-15-partial-order-under-contraction.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="real-life-problem"><span class="header-section-number">1</span> Real Life Problem</h1>
<p>I want to make a program that allow users to maintain some information that has some inherent partial order structure. Each information can be represented by a node, and there are edges going between nodes. One of the operations is grouping multiple nodes and mark them as equivalent. Equivalent nodes can be shrink into one super node, and only expand it when the user want to inspect the inside. However, we still want a partial order in the global view. It would be nice to characterize when it is possible.</p>
<h1 id="formal-formulation"><span class="header-section-number">2</span> Formal Formulation</h1>
<p><span class="math inline">(P,\leq)</span> be a partial order. Define <span class="math inline">U(X) = \{ p| x\leq p, x\in X, p\in P\}\backslash X</span>, <span class="math inline">D(X) = \{ p| p\leq x, x\in X, p\in P\}\backslash X</span>.</p>
<p>Let <span class="math inline">Z\subset P</span> and <span class="math inline">Q=P\backslash Z \cup \{q\}</span> where <span class="math inline">q\not\in P</span>. We define an contraction operation <span class="math inline">C(P,Z)=(Q,\preccurlyeq)</span>, such that</p>
<p><span class="math display">\displaystyle 
a\preccurlyeq b \Longleftrightarrow a\leq b \text{ or } (a\in D(Z)\cup \{q\} \text{ and } b\in U(Z)\cup \{q\})
</span></p>
<p>If we interpret <span class="math inline">(P,\leq)</span> as a directed graph, then this operation is contracting the vertices in <span class="math inline">Z</span> into one vertex <span class="math inline">q</span>, and then take the transitive closure.</p>
<p>There is a cute characterization of when <span class="math inline">(Q,\preccurlyeq)</span> is also a partial order.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p><span class="math inline">C(P,Z)=(Q,\preccurlyeq)</span> is a partial order if and only if <span class="math inline">D(Z)\cap U(Z) = \emptyset</span>. In particular, the map <span class="math display">\displaystyle  f(x) = \begin{cases} x  &amp; x\in P\backslash Z \\ q &amp; x \in Z\end{cases} </span> is order-preserving.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>If <span class="math inline">x\leq y</span>, then <span class="math inline">f(x)\preccurlyeq f(y)</span> by definition. We just have to prove <span class="math inline">(Q,\preccurlyeq)</span> is a partial order.</p>
<p>If <span class="math inline">D(Z)\cap U(Z) \neq \emptyset</span>, let <span class="math inline">x\in D(Z)\cap U(Z)</span>. There is <span class="math inline">z,z&#39;\in Z</span> such that <span class="math inline">z\leq x\leq z&#39;</span>. <span class="math inline">x \preccurlyeq q</span> and <span class="math inline">q \preccurlyeq x</span> but <span class="math inline">x\neq q</span>. <span class="math inline">(Q,\preccurlyeq)</span> is not a partial order.</p>
<p>If <span class="math inline">D(Z)\cap U(Z)=\emptyset</span>,</p>
<ol type="1">
<li><p>For all <span class="math inline">x\in Q</span>, <span class="math inline">x\preccurlyeq x</span>.</p></li>
<li><p>If <span class="math inline">x\preccurlyeq y</span> and <span class="math inline">y\preccurlyeq z</span> then <span class="math inline">x\preccurlyeq z</span>. This can be shown by a few case work from the definition.</p></li>
<li><p><span class="math inline">x\preccurlyeq y</span>, <span class="math inline">y\preccurlyeq x</span>, then <span class="math inline">x=y</span>.</p>
<ul>
<li><p><span class="math inline">x\leq y</span>, then <span class="math inline">y\leq x</span>. Assume not, then <span class="math inline">y\in D(Z)\cup \{q\}</span> and <span class="math inline">x\in U(Z)\cup \{q\}</span>. <span class="math inline">x\in D(z)</span> because <span class="math inline">x\leq y</span>. This implies <span class="math inline">x\in D(Z)\cap U(Z)</span>, a contradiction. Thus <span class="math inline">x\leq y</span> implies <span class="math inline">x=y</span>.</p></li>
<li><p>If <span class="math inline">x\in D(Z)\cup \{q\}</span> and <span class="math inline">y\in U(Z)\cup \{q\}</span>, and we also have <span class="math inline">x\in U(Z)\cup \{q\}</span> and <span class="math inline">y\in U(Z)\cup \{q\}</span>. This shows <span class="math inline">x=q=y</span>.</p></li>
<li><p>By symmetry, it take care of the remaining cases.</p></li>
</ul></li>
</ol>
</section>
<p>Again, if we interpret this in a graph theoretical sense, a contraction of a set of vertices <span class="math inline">X</span> doesn't introduce directed cycles if and only if the set of vertices reachable from <span class="math inline">X</span> and can reach <span class="math inline">X</span> are a subset of <span class="math inline">X</span>.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-02-15. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Sat, 15 Feb 2014 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2014-02-15-partial-order-under-contraction.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Generate Polyominoes in APL</title>
    <link>https://chaoxuprime.com/blog/posts/2013-09-19-generate-polyominoes-in-apl.html</link>
    <description><![CDATA[<br />
<div>
<p>I have won the 3rd Place on <a href="http://www.dyalog.com/news/83/420/2013-APL-Programming-Contest-winners.htm">2013 APL Problem Solving Competition</a> by solving one problem, the mathematical one. The judges decided that:</p>
<pre><code>Chao used Dfns to produce clean, compact, and efficient code.  His solution for PolyGen was more than twice as fast as the next closest entry.</code></pre>
<p>The other two problems are too messy for me to handle. Ahh, I'm not the engineering type.</p>
<p>Here is my submission with comments, and the problem itself can be seen <a href="http://studentcompetitions-general.s3.amazonaws.com/dyalog-apl/phase_2/2013%20APL%20Problem%20Solving%20Competition%20Phase%20II%20Problems.pdf">here</a>.</p>
<script src="https://gist.github.com/chaoxu/6478677.js"></script>
<p>50 lines (include comments) for $750, not so bad.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-09-19. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Thu, 19 Sep 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-09-19-generate-polyominoes-in-apl.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Find the minimum of a bitonic sequence</title>
    <link>https://chaoxuprime.com/blog/posts/2013-08-18-find-the-minimum-of-a-bitonic-sequence.html</link>
    <description><![CDATA[<br />
<div>
<p>A sequence is <span class="math inline">a_0,\ldots,a_{n-1}</span> is <em>bitonic</em> if it is a circular shift of a first non-increasing then non-decreasing sequence.</p>
<p>Find an algorithm that can find the minimum value in the sequence in <span class="math inline">O(m+\log n)</span> time, where <span class="math inline">m</span> is the maximum number of repeats for a single element. This problem is a generalization of <a href="/posts/2013-07-27-find-the-minimum-of-an-array.html">a previous problem</a>.</p>
<p>A trick about circular shift of an sequence is to consider the sequence as a periodic sequence. Create sequence <span class="math inline">b</span> such that <span class="math inline">b_i = a_i</span> for <span class="math inline">i &lt; n</span> and <span class="math inline">b_{i+n} = b_i</span> for all <span class="math inline">i\geq n</span>. We only have to find one local minima in any consecutive subsequence of length <span class="math inline">n</span>. This time we partition a interval into 4 pieces.</p>
<p>We define a valley to be 3 points <span class="math inline">x &lt; y &lt; z</span> such that <span class="math inline">b_x \geq b_y</span>, <span class="math inline">b_y \leq b_z</span>, but not <span class="math inline">b_x=b_y=b_z</span>. The valley can't be too large (<span class="math inline">|z-x|\leq n</span>). If we have such an valley and this valley contains a local minima, then it is easy to create a smaller (3/4 of the original size) valley that also contain the local minima.</p>
<p>If <span class="math inline">|y-x|\geq |z-y|</span>, pick the midpoint <span class="math inline">w</span> between <span class="math inline">x</span> and <span class="math inline">y</span>, and consider the relations. <span class="math inline">w &lt; y</span>, then we have an valley <span class="math inline">(x,w,y)</span>. <span class="math inline">w&gt;y</span>, then we have an valley <span class="math inline">(w,y,z)</span>, if <span class="math inline">b_w=b_y</span>, consider the midpoint of <span class="math inline">w</span> and <span class="math inline">y</span> to be <span class="math inline">u</span>. If <span class="math inline">b_w=b_u=b_y</span>, we know at least <span class="math inline">1/8</span> of the values are the same, and do a linear search between <span class="math inline">x</span> and <span class="math inline">z</span>. Otherwise, we must have <span class="math inline">b_w &gt; b_u &lt; b_y</span>(draw it and see why) and this is a new valley!</p>
<p>If we have <span class="math inline">|y-x|&lt;|z-y|</span>, something similar to above can be done.</p>
<p>It's easy to see the recursion gets us <span class="math inline">O(m+\log (\frac{n}{m}))=O(m+\log n)</span>. So the only problem comes from how do we find the first valley that contains the local minima. Let <span class="math inline">0 &lt; k &lt; n</span> If <span class="math inline">b_0 &gt; b_k</span>, then <span class="math inline">b_0,b_k,b_n</span> is a valley. If <span class="math inline">b_0 &lt; b_k</span>, then <span class="math inline">b_k,b_n,b_{k+n}</span> is a valley. So we pick 3 possible <span class="math inline">k</span> that is <span class="math inline">n/4</span> apart, and either one of them allow us to construct a valley, or at least <span class="math inline">n/4</span> of the points have the same value, and we use linear search.</p>
<script src="https://gist.github.com/chaoxu/6263718.js"></script>
<p>This algorithm is basically the simplified version of the algorithm in <a href="http://www.sciencedirect.com/science/article/pii/0885064X8990006X">Boris Veroy's paper</a> that can handles repeats.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-08-18. </div>
    <div class="info">Tags: Algorithm.</div>

</div>]]></description>
    <pubDate>Sun, 18 Aug 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-08-18-find-the-minimum-of-a-bitonic-sequence.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>More algorithms on perfectly balanced photo gallery</title>
    <link>https://chaoxuprime.com/blog/posts/2013-08-16-more-algorithms-on-perfectly-balanced-photo-gallery.html</link>
    <description><![CDATA[<br />
<div>
<p>Recently there was <a href="http://www.crispymtn.com/stories/the-algorithm-for-a-perfectly-balanced-photo-gallery">an article</a> by <a href="https://twitter.com/jtreitz">Johannes Treitz</a> <a href="https://news.ycombinator.com/item?id=6198400">submitted to Hacker News</a> about how to display a set of pictures as nicely as possible. The article doesn't have a formal description of the problem, so here is my take on what it mean by perfectly balanced.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a sequence of <span class="math inline">n</span> rectangles where the <span class="math inline">i</span>th rectangle has width <span class="math inline">W_i</span> and height <span class="math inline">H_i</span>. Also given are width <span class="math inline">W</span> and target height <span class="math inline">H</span>. Partition the sequence to <span class="math inline">k</span> consecutive subsequences, such that we scale the rectangles keeping the aspect ratio, and each subsequence of rectangles fills the entire width <span class="math inline">W</span>, and is close to the target height <span class="math inline">H</span>.</p>
</section>
<p>The problem is not so well defined. To make sure the heights are close, do we minimize the sum of all differences? Minimize the maximum difference? Or maybe, we just want to minimize the difference between consecutive rows, such that the first row has height close to <span class="math inline">h</span>.</p>
<p>Nevertheless, in real applications, the exact definition doesn't matter that much. Treitz reduce the problem to the linear partition problem.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Let <span class="math inline">a_1,\ldots,a_n</span> be a sequence of positive reals. We want to partition it into <span class="math inline">k</span> consecutive subsequences, such that the maximum sum over each subsequence is minimized. Formally, find <span class="math inline">k+1</span> positions <span class="math inline">b_1=1,b_2,\ldots,b_{k},b_{k+1}=n</span>, such that <span class="math inline">\max_{i=1}^{k} \sum_{j=b_i}^{b_{i+1}} a_j</span> is minimized.</p>
</section>
<p><span class="math inline">a_i = W_i/H_i</span> is the aspect ratio. This article will explore the techniques to solve the problem in <span class="math inline">O(kn)</span> time. It is only a high level overview, and leaves the details unfilled.</p>
<h1 id="minimize-total-difference"><span class="header-section-number">1</span> Minimize total difference</h1>
<p>Let's first consider a simpler problem for demonstration.</p>
<section class="theorem-environment Problem" id="Problem-3">
<span class="theorem-header"><span class="type">Problem</span><span class="index">3</span></span>
<p>Let <span class="math inline">a_1,\ldots,a_n</span> be a sequence of positive reals. We want to partition it into <span class="math inline">k</span> consecutive subsequences, such that the total difference between the sum of each consecutive sequence and the average sum of the whole sequence is minimized. Formally, let <span class="math inline">\mu = \frac{1}{k}\sum_{i=1}^n a_i</span>. Find <span class="math inline">k+1</span> positions <span class="math inline">b_1=1,b_2,\ldots,b_k,b_{k+1}=n</span>, such that <span class="math inline">\sum_{i=1}^{k} |\sum_{j=b_i}^{b_{i+1}} a_j - \mu|</span> is minimized.</p>
</section>
<p>We will solve this problem with a reduction to a problem on a DAG, and then apply dynamic programming. Since we can always turn a problem that ask us to find the <em>cost</em> to a problem that ask us to find a <em>construction</em> that achieve the cost(with the same time/space bound). We will only concern with the cost version of the problem as it's much clearer. (One can implement some arrows in Haskell to make DP for construction as easy as DP for cost, sounds like a nice project. )</p>
<p>Build a directed graph <span class="math inline">D(V,A)</span>, where <span class="math inline">V=\{v_1,\ldots,v_n\}</span>, <span class="math inline">(v_i,v_j)\in A</span> if and only if <span class="math inline">i\leq j</span>. (We can make it <span class="math inline">i &lt; j</span> instead, depend on if we consider a empty sequence a valid sequence.)</p>
<p>We have a weight function <span class="math inline">w(i,j)</span> that assign weights to arc <span class="math inline">(v_i,v_j)</span>. Define <span class="math inline">w(i,j) = |\sum_{k=i}^{j-1} a_i - \mu|</span>.</p>
<p>If we find a <span class="math inline">k</span>-edge path of minimum weight from <span class="math inline">v_1</span> to <span class="math inline">v_n</span>, then this implies a solution to <a href="#Problem-3">Problem 3</a>.</p>
<h1 id="solve-the-minimum-weight-k-edge-path-problem"><span class="header-section-number">2</span> Solve the minimum weight <span class="math inline">k</span>-edge path problem</h1>
<p>Define <span class="math inline">C(d,i)</span> to be the <span class="math inline">d</span>-edge path from <span class="math inline">v_1</span> to <span class="math inline">v_i</span> with minimum weight. We want to find <span class="math inline">C(k,n)</span>.</p>
<p><span class="math display">\displaystyle 
C(d,i) = \min_{1\leq j\leq i} {C(d-1,j) + w(j,i)}
</span></p>
<p>If we set <span class="math inline">w(j,i)=\infty</span> if <span class="math inline">j&gt;i</span>, then we have a better representation.</p>
<p><span class="math display">\displaystyle 
C(d,i) = \min_{1\leq j\leq n} {C(d-1,j) + w(j,i)}
</span></p>
<p>There are <span class="math inline">kn</span> entries in the DP table for <span class="math inline">C</span>, and <span class="math inline">C(d,i)</span> requires <span class="math inline">O(n)</span> time to compute. This means the algorithm will take <span class="math inline">O(kn^2)</span> time.</p>
<h1 id="improve-the-time-complexity"><span class="header-section-number">3</span> Improve the time complexity</h1>
<p>There is a standard technique on totally monotone matrices that can reduce the complexity of the problem to <span class="math inline">O(kn)</span>.</p>
<section class="theorem-environment Definition" id="Definition-4">
<span class="theorem-header"><span class="type">Definition</span><span class="index">4</span></span>
<p>A weight function <span class="math inline">w</span> is Monge if for every <span class="math inline">1&lt;i+1&lt;j\leq n</span>, we have <span class="math display">\displaystyle 
w(i,j) + w(i+1,j+1)\leq w(i,j+1) + w(i+1,j)
</span> .</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-5">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">5</span></span>
<p><span class="math inline">w</span> is Monge.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">\sum_{k=i+1}^{j-1} a_i - \mu = m</span> <span class="math display">\displaystyle \begin{aligned}
w(i,j)+w(i+1,j+1) &amp;=  |\sum_{k=i}^{j-1} a_i - \mu|
                    + |\sum_{k=i+1}^{j} a_i - \mu|\\
                  &amp;= |a_i + m| + |a_j + m|\\
                  &amp;\leq |a_i+a_j+m| + |m|\\
                  &amp;= w(i,j+1)+w(i+1,j)
\end{aligned}</span> To prove the <span class="math inline">\leq</span>, see that <span class="math inline">a_i,a_j</span> are positive, one can consider either <span class="math inline">m</span> is negative or positive, and notice either way the inequality holds true.</p>
</section>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>We can replace <span class="math inline">|\cdot|</span> with <span class="math inline">|\cdot|^p</span> for <span class="math inline">p\geq 1</span>. When <span class="math inline">p=2</span>, we minimizes the variance(and standard deviation).</p>
</section>
<section class="theorem-environment Definition" id="Definition-6">
<span class="theorem-header"><span class="type">Definition</span><span class="index">6</span></span>
<p>A matrix is totally monotone if for every <span class="math inline">i&lt;i&#39;</span> and <span class="math inline">j&lt;j&#39;</span>, <span class="math inline">a_{i,j} &gt; a_{i&#39;,j} \implies a_{i,j&#39;} &gt; a_{i&#39;,j&#39;}</span>.</p>
</section>
<p><img src="/files/totallymonotone.jpg" alt="totally monotone" /> <br /><sup>Image Credit: <a href="http://vanessa.li">Vanessa Li</a>.</sup></p>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>There are isomorphic definition of Monge and totally monotone, depend on if the person want to find row or column minima.</p>
</section>
<p>Define a matrix <span class="math inline">M^d</span>, such that <span class="math inline">M_{j,i}^d = C(d-1,j) + w(j,i)</span>, the original recurrence become <span class="math display">\displaystyle 
C(d,i) = \min_{1\leq j\leq n} {M^d_{j,i}}
</span> In other words, <span class="math inline">C(d,i)</span> is the <span class="math inline">i</span>th column's minima of <span class="math inline">M^d</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-7">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p>If <span class="math inline">w</span> is Monge, then <span class="math inline">M^d</span> is a <span class="math inline">n\times n</span> totally monotone matrix.</p>
</section>
<p>Using the <a href="http://en.wikipedia.org/wiki/SMAWK_algorithm">SMAWK algorithm</a>, all column minimas can be found in <span class="math inline">O(n)</span>. Finding <span class="math inline">C(d,i)</span> takes only <span class="math inline">O(1)</span> time on average!</p>
<p>Here is the very simple code to show how this can be done easily if we have a <a href="http://dailyhaskellexercise.tumblr.com/post/57781874558/column-minima-in-a-totally-monotone-matrix">Haskell implementation of the SMAWK algorithm</a>. The indexing is a bit different from the description in the article.</p>
<pre><code>import Data.Array
import SMAWK

minCostkEdgePath k n w = d!(k-1,n)
  where
    d = array ((0,0),(k-1,n)) [ ((i,j), f i j) | i&lt;-[0..k-1],j&lt;-[0..n]]
    f 0 i = w 0 i
    f k i = m k (p!(k,i)) i
    p = array ((1,0),(k,n)) [((z,i),t) |z&lt;-[1..k],(i,t)&lt;-zip [0..n] (columnMinima (m z) (n+1) (n+1))]
    m k j i = (+) (d!(k-1,j)) (w j i)

minCostMuPartition k xs = minCostkEdgePath k n w
    where 
        w i j 
         | i &lt;= j    = abs $! s!j - s!i - avg
         | otherwise = 2*m
        s   = listArray (0, n-1) $ scanl (+) 0 xs
        n   = length xs
        m   = sum xs
        avg = m/fromIntegral k</code></pre>
<h1 id="solve-the-linear-partition-problem"><span class="header-section-number">4</span> Solve the linear partition problem</h1>
<p>Now, returning to the original problem. Again, we can reduce the problem to a problem on a directed graph. This time, <span class="math inline">w(i,j) = \sum_{k=i}^{j-1} a_i</span>. The weight of a path is the maximum weight of the edges in the path. A <span class="math inline">k</span>-edge path with minimum weight implies the solution to the original problem.</p>
<p><span class="math display">\displaystyle 
C(d,i) = \min_{1\leq j\leq n} M^d_{j,i}
</span></p>
<p>where <span class="math inline">M^d_{j,i} = \max (C(d-1,j),w(j,i))</span>.</p>
<p>Just like <a href="#Problem-3">Problem 3</a>, this describes a <span class="math inline">O(kn^2)</span> time algorithm. Compare <span class="math inline">w,C</span> and <span class="math inline">M^d</span> with the previous problem to see there isn't much difference.</p>
<h1 id="improve-the-time-complexity-again"><span class="header-section-number">5</span> Improve the time complexity, again</h1>
<p>Can we define an alternative to the Monge property? Yes, we can extend this to <em>algebraic Monge property</em>. Just replace <span class="math inline">+</span> with some associative operation <span class="math inline">\oplus</span>, <span class="math inline">\leq</span> with a total order that is ordered with respect to <span class="math inline">\oplus</span>, i.e. <span class="math inline">a \leq a\oplus b</span>.</p>
<p>So it seems, using the algorithm above with little modification, we can solve the problem in <span class="math inline">O(kn)</span> time because we can just replace <span class="math inline">+</span> by <span class="math inline">\min</span>.</p>
<p>However, algebraic Monge property in general doesn't imply totally monotone matrix.</p>
<p>Consider the simple matrix, and our operation is <span class="math inline">\max</span>.</p>
<span class="math">\begin{bmatrix}
1& 2\\
0& 2
\end{bmatrix}</span>
<p><span class="math inline">\max(1,2)=\max(0,2)</span>, but the matrix is not totally monotone. <span class="math inline">1&gt;0</span> but <span class="math inline">2\not &gt; 2</span>.</p>
<p>If instead the operation is strictly compatible, i.e. <span class="math inline">a \oplus b&lt; a \oplus c</span> if <span class="math inline">b &lt; c</span>, then we can always produce a totally monotone matrix. This is not the case with <span class="math inline">\max</span>.</p>
<p>Some readers who are familiar with <a href="http://en.wikipedia.org/wiki/Lp_space"><span class="math inline">L^p</span> space</a> might point out for any sequence of reals <span class="math inline">a_1,\ldots,a_n</span> and <span class="math inline">\epsilon&gt;0</span>, there exist a <span class="math inline">p\geq 1</span>, such that <span class="math inline">(\sum_{i=1}^n |a_i|^p)^{1/p} - \max_{i=1}^n |a_i|&lt; \epsilon</span>. So if we don't need to be exact, pick a large enough <span class="math inline">p</span> as an exponential is good enough. This opens up a can of numerical analysis, and that's undesirable...</p>
<p>Good news, a more restrictive but good enough variant of the Monge property hold.</p>
<section class="theorem-environment Definition" id="Definition-8">
<span class="theorem-header"><span class="type">Definition</span><span class="index">8</span></span>
<p><span class="math inline">w</span> has the <em>strict bottleneck Monge property</em> if either of the following is true for <span class="math inline">1&lt;i+1&lt;j</span>:</p>
<ol type="1">
<li><span class="math inline">\max(w(i,j), w(i+1,j+1)) &lt; \max(w(i+1,j),w(i,j+1))</span>.</li>
<li><span class="math inline">\max(w(i,j), w(i+1,j+1)) = \max(w(i+1,j),w(i,j+1))</span> and <span class="math inline">\min(w(i,j), w(i+1,j+1)) \leq \min(w(i+1,j),w(i,j+1))</span>.</li>
</ol>
</section>
<p>Our <span class="math inline">w</span> in consideration has strict bottleneck Monge property. Because all the numbers are positive, <span class="math inline">w(i,j+1)&gt;w(i+1,j+1)&gt;w(i+1,j)</span>, <span class="math inline">w(i,j+1)&gt;w(i,j)&gt;w(i+1,j)</span>. A simple case check on the relation between <span class="math inline">w(i,j)</span> and <span class="math inline">w(i+1,j+1)</span> will give the desired proof. Why this property? You can check by a case by case proof that this property implies total monotonicity.</p>
<section class="theorem-environment Theorem" id="Theorem-9">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">9</span></span>
<p>If <span class="math inline">w</span> has the strict bottleneck Monge property, then <span class="math inline">M^d</span> is a <span class="math inline">n\times n</span> totally monotone matrix.</p>
</section>
<p>There seems to be a direct proof by analyze 12 different cases, but I got too bored after the second case. One can read <span class="citation" data-cites="Bein2005455">[<a href="#ref-Bein2005455">1</a>]</span> for the proof. It doesn't contain the exact theorem, but a result that implies this one. The proof is quite involved. Their idea is to construct a new matrix with a new operation over sorted sequences of numbers instead of just numbers. Prove this matrix is strictly compatible and has the algebraic Monge property, and show this can always be done if the original matrix has the strict bottleneck Monge property.</p>
<p>The final punchline.</p>
<section class="theorem-environment Theorem" id="Theorem-10">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">10</span></span>
<p>Change the last <code>(+)</code> in <code>minCostkEdgePath</code> to <code>max</code>, and change how <code>w</code> is computed in <code>minCostMuPartition</code> solves <a href="#Problem-2">Problem 2</a>.</p>
</section>
<h1 id="rethink-the-original-problem"><span class="header-section-number">6</span> Rethink the original problem</h1>
<p>We have developed a <span class="math inline">O(kn)</span> algorithm for <a href="#Problem-2">Problem 2</a>. As we can see from the practical application, this is a <span class="math inline">O(n^2)</span> algorithm because the <span class="math inline">k</span> is of the order <span class="math inline">n</span>.</p>
<p>For a few hundred photos, we can afford to run it in real time. This will reach a limit once there are thousand of photos.</p>
<p>Can we do better? Yes, by considering a different kind of reduction(thank god we didn't formally define what <em>close</em> means). Instead of compute <span class="math inline">k</span> and try to fit <span class="math inline">k</span> rows, why not just make sure each row's width is almost the width we want and scale accordingly? We want each rows to approximately have width <span class="math inline">W</span>, we don't really care how many rows there are.</p>
<section class="theorem-environment Problem" id="Problem-11">
<span class="theorem-header"><span class="type">Problem</span><span class="index">11</span></span>
<p>Let <span class="math inline">a_1,\ldots,a_n</span> be a sequence of positive reals, and a number <span class="math inline">\mu = W/H</span>. We want to partition it into consecutive subsequences, such that the maximum difference between the sum of each consecutive sequence and the <span class="math inline">\mu</span> is minimized. Formally, find a <span class="math inline">k</span> and a sequence of <span class="math inline">k+1</span> numbers <span class="math inline">b_1=1,b_2,\ldots,b_{k},b_{k+1}=n</span>, such that <span class="math inline">\max_{i=1}^{k} |\sum_{j=b_i}^{b_{i+1}} a_j - \mu|</span> is minimized.</p>
</section>
<p>This is the exact same problem described on section 5 of <span class="citation" data-cites="Bein2005455">[<a href="#ref-Bein2005455">1</a>]</span>. It can be solve in <span class="math inline">O(n)</span> time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Bein2005455">
<p>[1] W. Bein, P. Brucker, L.L. Larmore, J.K. Park, <strong>The algebraic monge property and path problems</strong>, Discrete Applied Mathematics. 145 (2005) 455–464 <a href="https://doi.org/10.1016/j.dam.2004.06.001">10.1016/j.dam.2004.06.001</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-08-16. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Fri, 16 Aug 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-08-16-more-algorithms-on-perfectly-balanced-photo-gallery.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Why I left Google</title>
    <link>https://chaoxuprime.com/blog/posts/2013-08-02-why-i-left-google.html</link>
    <description><![CDATA[<br />
<div>
<p>Google is an amazing place, it's the first &quot;real&quot; job I had.</p>
<p>My traits suit companies like Google and Facebook well because they look for a generalist. They focus on problem solving and coding skills for new grad positions. The training in ACM-ICPC helped me a lot with those. The interviews are considerably easier than <a href="http://janestreet.com/">Jane Street</a> or <a href="https://imo.im/">IMO</a>. I probably can't get into companies that are more traditional. For example, I didn't get into IBM, because I have no idea about lots of technical things known to CS majors.</p>
<p>The environment at Google is amazing. The life is flexible, one can decide to be hard working, or just hard working enough to not feel guilty about it. There is freedom to take up on things you want to work on.</p>
<p>The only problem is that I find little enjoyment in software engineering for real life products. The problems are technically easy, but complex. The code changes are easy, but one have to dive into the entire system to understand how one line change could affect someone else's design.</p>
<p>The programming language choice is also a pain. It's so hard to switch to C++ when I know how powerful it is to pass around functions or currying as a first nature.</p>
<p>It's not the fault of Google. There are rarely companies are going around tackling well defined theoretical problems. I'm a mathematician, not an engineer.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-08-02. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Fri, 02 Aug 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-08-02-why-i-left-google.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Find the minimum of an array with a non-increasing and a non-decreasing part</title>
    <link>https://chaoxuprime.com/blog/posts/2013-07-27-find-the-minimum-of-an-array.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="problem"><span class="header-section-number">1</span> Problem</h1>
<p>Consider an array <span class="math inline">a</span> of <span class="math inline">n</span> entries from a totally ordered set. There exist a index <span class="math inline">j</span>, such that <span class="math inline">a[i]\geq a[i+1]</span> for all <span class="math inline">i &lt; j</span>, and <span class="math inline">a[i]\leq a[i+1]</span> for all <span class="math inline">i\geq j</span>.</p>
<p>How fast can we find such <span class="math inline">j</span>? The worst time is <span class="math inline">O(n)</span>. When all the elements are equal, you must transverse the entire array to figure that out.</p>
<p>If <span class="math inline">m</span> is the maximum time an element occurs in the array, then we can find an algorithm that solves this problem in <span class="math inline">O(m+\log n)</span> time.</p>
<h1 id="algorithm"><span class="header-section-number">2</span> Algorithm</h1>
<p>The idea is to use ternary search, which works well when all values are distinct, and go for linear search once we figure there are a lot of repeated elements.</p>
<p>First, we present a lemma.</p>
<section class="theorem-environment Lemma" id="Lemma-1">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">1</span></span>
<p>If there exist a index <span class="math inline">i &lt; j &lt; k</span>, such that <span class="math inline">a[i]=a[j]=a[k]</span>, then at least <span class="math inline">\min(j-i,k-j)</span> positions in the array has the same value as <span class="math inline">a[i]</span>.</p>
</section>
<p><img src="/files/decinc.png" alt="The specified positions" /> <br /><sup>Image Credit: <a href="http://vanessa.li">Vanessa Li</a>.</sup></p>
<p>Consider we want to find the minima from index <span class="math inline">l</span> to <span class="math inline">r</span> (not including <span class="math inline">r</span>), and <span class="math inline">r-l&gt;3</span>. Let <span class="math inline">m_1=l+\lfloor \frac{r-l}{3} \rfloor</span> and <span class="math inline">m_2=r-\lfloor \frac{r-l}{3} \rfloor</span> such that <span class="math inline">l &lt; m_1 &lt; m_2 &lt; r</span>.</p>
<ul>
<li>If <span class="math inline">a[m_1] &lt; a[m_2]</span>, then we know the minima is in <span class="math inline">a[l..m_2]</span>. Recurse.</li>
<li>If <span class="math inline">a[m_1] &gt; a[m_2]</span>, then we know the minima is in <span class="math inline">a[m_1..r]</span>. Recurse.</li>
<li>Otherwise <span class="math inline">a[m_1]=a[m_2]</span>. If <span class="math inline">a[l]=a[m_1]</span> or <span class="math inline">a[r]=a[m_1]</span>, then by the lemma, at least <span class="math inline">1/3</span> of the values between position <span class="math inline">l</span> and <span class="math inline">r</span> is <span class="math inline">a[m_1]</span>. We can also test if <span class="math inline">a[\lfloor \frac{m_1+m_2}{2} \rfloor]=a[m_1]</span>, if it is, then <span class="math inline">1/6</span> of the values between position <span class="math inline">l</span> and <span class="math inline">r</span> is <span class="math inline">a[m_1]</span>. Since there are so many repeated values, we just do a linear search for the minima.</li>
<li>Finally, if all above fails, we must have some value between position <span class="math inline">m_1</span> and <span class="math inline">m_2</span> take a different value from them. It must be a smaller value, and no value smaller than <span class="math inline">a[m_1]</span> can exist outside <span class="math inline">a[m_1..m_2]</span>. Recurse on <span class="math inline">a[m_1..m_2]</span>.</li>
</ul>
<p>Here is the code in Go:</p>
<script src="https://gist.github.com/chaoxu/6094392.js"></script>
<h1 id="complexity"><span class="header-section-number">3</span> Complexity</h1>
<p><span class="math inline">T(m,n)</span> is the time to run the algorithm on an array of length <span class="math inline">n</span> with <span class="math inline">m</span> repeats.</p>
<p><span class="math display">\displaystyle 
T(m,n)  = \begin{cases} 
         \frac{2}{3}T(m,n) + O(1) &amp;\text{if strict inequality} \\ 
         O(n) &amp; \text{if } n \leq \frac{m}{6} \\
         \frac{1}{3}T(m,n) + O(1) &amp; \text{otherwise}
         \end{cases}       
</span> For <span class="math inline">n</span> larger than <span class="math inline">\frac{m}{6}</span>, the algorithm will have <span class="math inline">O(\log \frac{n}{m})</span> recursive calls, each one cost <span class="math inline">O(1)</span> time. Once it reaches small <span class="math inline">n</span>, it will spend <span class="math inline">O(n)=O(m)</span> time on a linear search. The algorithm spends a total of <span class="math inline">O(m+ \log \frac{n}{m}) = O(m+\log n)</span> time.</p>
<h1 id="notes"><span class="header-section-number">4</span> Notes</h1>
Brosef Stalin offered an alternative logic that offers cleaner code.
<script src="https://pastebin.com/embed_js.php?i=107WhrsU"></script>
<p>Can we generalize this to first increase then decrease then increase arrays? One can show <span class="math inline">O(n)</span> is best possible by considering an array with <span class="math inline">a[i]=i</span> for all <span class="math inline">i\neq j</span>, and <span class="math inline">a[j]=-1</span>. There is no way to find <span class="math inline">j</span> with out looking over every position.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-07-27. </div>
    <div class="info">Tags: Algorithm.</div>

</div>]]></description>
    <pubDate>Sat, 27 Jul 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-07-27-find-the-minimum-of-an-array.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Formal Definition of Sequence Alignment</title>
    <link>https://chaoxuprime.com/blog/posts/2013-07-10-formal-definition-of-sequence-alignment.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider an alphabet <span class="math inline">\Sigma</span> and two sequences <span class="math inline">s</span> and <span class="math inline">t</span> on <span class="math inline">\Sigma</span>. Let <span class="math inline">\bar{\Sigma} = \Sigma\cup \{\diamond\}</span> where <span class="math inline">\diamond</span> is some symbol not in <span class="math inline">\Sigma</span>, it's called the gap symbol. <span class="math inline">M:\bar{\Sigma}\times \bar{\Sigma}\to \Z</span>. We have a gap penalties functions <span class="math inline">g_s,g_t:\N\to \Z</span>. The functions are monotonic and are <span class="math inline">0</span> at <span class="math inline">0</span>. The four boundary gap penalty coefficient <span class="math inline">b_s,b_t,e_s,e_t\in \{0,1\}</span>. We want to find the alignment score between the two sequences.</p>
<p>A gap is the maximal substring consist of only <span class="math inline">\diamond</span>'s. The gap sequence of a string is a sequence of lengths of each gap. Define <span class="math inline">s_\diamond</span> be the gap sequence of string <span class="math inline">s</span>.</p>
<p><span class="math inline">G(x,g,y,a) = xg(a_1) + \sum_{i=2}^{n-1} g(a_i) + yg(a_n)</span>, where <span class="math inline">a</span> is a sequence of length <span class="math inline">n</span>.</p>
<p><span class="math display">\displaystyle 
A(u,v) = \sum_{i=1}^{|u|} M(u_i,v_i) + G(b_s,g_s,e_s,u_\diamond) + G(b_t,g_t,e_t,v_\diamond)
</span></p>
<p>Define <span class="math inline">S</span> and <span class="math inline">T</span> be the set of all strings that can be formed by inserting <span class="math inline">\diamond</span> into <span class="math inline">s</span> and <span class="math inline">t</span> respectively.</p>
<p>The alignment score is defined as <span class="math display">\displaystyle 
\max \{A(u,v) : |u|=|v|, u\in S, v\in T\}
</span></p>
<p>Now, once one write an algorithm for this problem, it can be used for many sequence alignment problems on <a href="http://rosalind.info/">Rosalind</a>.</p>
<ul>
<li><a href="http://rosalind.info/problems/hamm/">Hamming Distance</a>: <span class="math inline">M(a,a)=-1</span>, and <span class="math inline">0</span> otherwise. All other function are <span class="math inline">-\infty</span>.</li>
<li><a href="http://rosalind.info/problems/lcsq/">Finding a Shared Spliced Motif</a>, longest common subsequence. <span class="math inline">M(a,a)=1</span> for <span class="math inline">a\in \Sigma</span>, <span class="math inline">0</span> otherwise. Everything else are <span class="math inline">0</span>.</li>
<li><a href="http://rosalind.info/problems/edit/">Edit distance</a>: Levenshtein distance, <span class="math inline">M(a,a)=-1</span> for <span class="math inline">a\in \bar{\Sigma}</span>, <span class="math inline">0</span> otherwise. All other are <span class="math inline">-\infty</span>.</li>
<li><a href="http://rosalind.info/problems/glob/">Global alignment</a>: <span class="math inline">b_s=e_s=g_s</span>, <span class="math inline">b_t=e_t=g_t</span>.</li>
<li><a href="http://rosalind.info/problems/oap/">Overlap alignment</a>: <span class="math inline">b_s=e_t=0</span>, <span class="math inline">b_t=g_t</span>, <span class="math inline">e_s=g_s</span>.</li>
<li><a href="http://rosalind.info/problems/sims/">Fitting alignment</a>: <span class="math inline">b_s=e_s=0</span>, <span class="math inline">b_t=e_t=g_t</span>.</li>
<li><a href="http://rosalind.info/problems/smgb/">Semiglobal alignment</a>: <span class="math inline">b_s=e_s=b_t=e_t=0</span>.</li>
<li>Substring Matching: <span class="math inline">b_s=e_s=0</span>, <span class="math inline">g_s,g_t,b_t,e_t=-\infty</span>.</li>
</ul>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-07-10. </div>
    <div class="info">Tags: .</div>

</div>]]></description>
    <pubDate>Wed, 10 Jul 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-07-10-formal-definition-of-sequence-alignment.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Algebraic framework for algorithms</title>
    <link>https://chaoxuprime.com/blog/posts/2013-06-08-algebraic-framework-for-algorithms.html</link>
    <description><![CDATA[<br />
<div>
<p>A common algorithmic problem is to find if there is a way to do arbitrage. If we create a directed graph, such that each vertex is a currency, and each edge is weighted by the exchange rate of the currency, we want to find a paths from a vertex to itself, such that the product of the edges is greater than 1.</p>
<p>To solve the problem, take the <span class="math inline">-\log</span> of the edge weights, and the problem become find any negative cycle. Bellman-Ford does well for this problem. One might question what other kind of optimization problem we can use this kind of tricks so the original algorithm still works? Once we notice that <span class="math inline">-\log</span> is a order preserving homomorphism from <span class="math inline">(\R^+,\cdot)</span> to <span class="math inline">(\R,+)</span>, then everything becomes clear.</p>
<p>A group <span class="math inline">(G,+)</span> is a linearly ordered abelian group if it's abelian and for all <span class="math inline">a,b,c\in G</span>, if <span class="math inline">a\leq b</span>, then <span class="math inline">ac\leq bc</span>. Find any proof of Bellman-Ford algorithm, and replace the use of reals with such a group, it would still work. Many weighted graph algorithms that only uses the addition property of the reals, all of them would work well with the underlaying set replaced by a linearly ordered abelian group.</p>
<p>In fact, if there is no negative edges, we don't even need to require it to be a group, a monoid structure is enough.</p>
<p>I found it interesting and like to know what is some algorithms in it's full generality. There is also a semiring framework for dynamic programming algorithms on graphs. Monoid, lattices have their use in parallel and distributed algorithms. It be great if there is a nice survey on the use of algebraic framework for describing algorithms.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-06-08. </div>
    <div class="info">Tags: algorithm, algebra.</div>

</div>]]></description>
    <pubDate>Sat, 08 Jun 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-06-08-algebraic-framework-for-algorithms.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Totally Unimodular Matrices</title>
    <link>https://chaoxuprime.com/blog/posts/2013-05-29-totally-unimodular-matrices.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Definition" id="Definition-1">
<span class="theorem-header"><span class="type">Definition</span><span class="index">1</span><span class="name">Totally Unimodular Matrices</span></span>
<p>A matrix <span class="math inline">A</span> is <em>totally unimodular</em> if for all square submatrix <span class="math inline">A&#39;</span> of <span class="math inline">A</span>, <span class="math inline">\det(A&#39;) \in \{-1,0,1\}</span>.</p>
</section>
<p>We will use <span class="math inline">TU</span> to be the set of all totally unimodular matrices.</p>
<p>By this definition, all the entries in a totally unimodular matrix must be <span class="math inline">-1,0,1</span> by consider square submatrix of size <span class="math inline">1</span>.</p>
<section class="theorem-environment Proposition" id="Proposition-2">
<span class="theorem-header"><span class="type">Proposition</span><span class="index">2</span></span>
<p>If <span class="math inline">A \in TU</span>, <span class="math inline">A_j</span> be the <span class="math inline">j</span>th row of <span class="math inline">A</span>, then</p>
<ol type="1">
<li><span class="math inline">A^T \in TU</span>,</li>
<li><span class="math inline">A&#39;</span> is a submatrix of <span class="math inline">A</span>, then <span class="math inline">A&#39;\in TU</span>,</li>
<li><span class="math display">\displaystyle 
 \begin{bmatrix}
   0\\
   A_1\\
   A_2\\
   A_3\\
   \vdots\\
   A_{m}
   \end{bmatrix} \in TU
   </span>.</li>
<li>If <span class="math inline">A</span> is a square matrix, then <span class="math inline">A^{-1} \in TU</span>,</li>
<li>If <span class="math inline">A&#39;</span> is formed by row swapping of <span class="math inline">A</span>, then <span class="math inline">A&#39;\in TU</span>.</li>
<li>Multiply by <span class="math inline">{-1,0,1}</span> to a row.</li>
</ol>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<ol type="1">
<li><span class="math inline">det(M) = det(M^T)</span>.</li>
<li>square submatrix of <span class="math inline">A&#39;</span> is also square submatrix of <span class="math inline">A</span>.</li>
<li>The submatrices that doesn't contain the first row has corresponding submatrix in <span class="math inline">A</span>, ones that does contain the first row has determinant 0.<br />
</li>
<li>see <a href="http://mathoverflow.net/questions/128113/inverse-of-a-totally-unimodular-matrix">inverse of a totally unimodular matrix</a>.</li>
<li>row switching. Consider we switched row <span class="math inline">i</span> and <span class="math inline">j</span>. Consider any submatrix, if it doesn't contain row <span class="math inline">i</span> or <span class="math inline">j</span>, then it still has determinant <span class="math inline">-1,0,1</span>. If it contain both row <span class="math inline">i</span> and <span class="math inline">j</span>, then the determinant is just the negation when the rows are switched back. If it only contain one of row <span class="math inline">i</span> and <span class="math inline">j</span>, wlog let it be <span class="math inline">i</span>, then it has the rows in order <span class="math inline">a_1,\ldots,a_k,i,a_{k+1},\ldots,a_l</span>, then there is a submatrix in <span class="math inline">A</span> using the rows in sequence <span class="math inline">a_1,\ldots,a_j,i,a_{j+1},\ldots,a_l</span>, and the absolute value of their determinants are equal.</li>
<li>multiply by a constant to preserve the <span class="math inline">-1,0,1</span> properties, then use the argument similar as above, note the determinant of the submatrix can change only by sign.</li>
</ol>
</section>
<p>The above properties can be useful to prove many simple statements, for example, operations like duplicate a row, column are closed in <span class="math inline">TU</span>.</p>
<p><span class="math inline">TU</span> is not closed under matrix multiplication, consider <span class="math inline">\begin{bmatrix} 1 &amp; 1 \\ 0 &amp; 1\end{bmatrix}^2 = \begin{bmatrix} 1 &amp; 2 \\ 0 &amp; 1\end{bmatrix}</span>.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-05-29. </div>
    <div class="info">Tags: matrix.</div>

</div>]]></description>
    <pubDate>Wed, 29 May 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-05-29-totally-unimodular-matrices.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Represent an element in a free monoid with minimum weight</title>
    <link>https://chaoxuprime.com/blog/posts/2013-03-26-represent-an-element-in-a-free-monoid-with-minimum-weight.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider a rank <span class="math inline">k</span> free monoid <span class="math inline">(M,\cdot)</span> with free generators <span class="math inline">G</span>. Sometimes there are ways to express them by writing a little less than write the whole string of generators. We can group some generators by powers. For example, <span class="math inline">aababababaaaa = a(ab)^4a^4</span>.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Find the shortest way to write down an element in a free monoid.</p>
</section>
<p>There are problems on how long are the parentheses, exponents etc. Therefore we generalize it to allow weight to those operations.</p>
<p>Formally. For any free monoid <span class="math inline">M</span> with free generators <span class="math inline">G</span>, we can construct another free monoid <span class="math inline">(M^*,\cdot)</span>,</p>
<ol type="1">
<li><span class="math inline">a\in G \implies Atom(a)\in M^*</span>.</li>
<li><span class="math inline">a\in M^*</span>, <span class="math inline">n\in\N</span>, then <span class="math inline">Power(a,n) \in M^*</span>.</li>
</ol>
<section class="theorem-environment Definition" id="Definition-2">
<span class="theorem-header"><span class="type">Definition</span><span class="index">2</span></span>
<p>Consider a homomorphism <span class="math inline">w:M^*\to \N</span>. Such that for all <span class="math inline">n</span>, it satisfy the following criteria:</p>
<ol type="1">
<li><span class="math inline">w(a)\leq w(b) \implies w(Power(a,n))\leq w(Power(b,n))</span>,</li>
<li><span class="math inline">w(a)\leq w(Power(a,1))</span>.</li>
</ol>
<p><span class="math inline">w</span> is a weight function.</p>
</section>
<p>Let <span class="math inline">f:M^*\to M</span>, such that</p>
<ul>
<li><span class="math inline">f(ab) = f(a)f(b)</span>,</li>
<li><span class="math inline">f(Atom(a)) = a</span>,</li>
<li><span class="math inline">f(Power(a,n)) = a^n</span>.</li>
</ul>
<section class="theorem-environment Problem" id="Problem-3">
<span class="theorem-header"><span class="type">Problem</span><span class="index">3</span></span>
<p>Given <span class="math inline">a\in M</span>, we want to find <span class="math inline">a&#39;\in M^*</span>, such that <span class="math inline">f(a&#39;) = a</span> and <span class="math inline">w(a&#39;)</span> is minimized.</p>
</section>
<p>The input is <span class="math inline">a_1\ldots a_n</span>.</p>
<p>Let <span class="math inline">D(i,j)</span> represent the minimum weight representation for <span class="math inline">a_i\ldots a_j</span>. Let <span class="math inline">P(i,j)</span> represent the set of all possible <span class="math inline">Power(x,k)</span>, such that <span class="math inline">f(Power(x,k)) = a_i\ldots a_j</span> for some <span class="math inline">k\neq 1</span>.</p>
<p><span class="math display">\displaystyle \begin{aligned}
D(i,i) &amp;= a_i\\
D(i,j) &amp;= \min(P(i,j)\cup \{ D(i,k)+D(k+1,j)| i\leq k\leq j-1\})
\end{aligned}</span></p>
<p>Here <span class="math inline">\min</span> return any of the expressions that achieves the minimum weight. This allows a <span class="math inline">O(n^3)</span> algorithm if one uses suffix tree for finding <span class="math inline">P(i,j)</span>. One can naively try all possible <span class="math inline">Power(x,k)</span> instead, where <span class="math inline">k|n</span>.</p>
<p>Here is an Haskell code for it. It is designed to show the algorithm instead of been efficient. This has real life usage to <a href="/posts/2013-03-21-regular-expression-for-a-interval-of-non-negative-integers.html">compress regular expressions</a>.</p>
<script src="https://gist.github.com/chaoxu/72a82300b9750f9c0374.js"></script>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-03-26. </div>
    <div class="info">Tags: Haskell, monoid.</div>

</div>]]></description>
    <pubDate>Tue, 26 Mar 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-03-26-represent-an-element-in-a-free-monoid-with-minimum-weight.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Regular expression for a interval of non-negative integers</title>
    <link>https://chaoxuprime.com/blog/posts/2013-03-21-regular-expression-for-a-interval-of-non-negative-integers.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">m,n \in \N</span> and <span class="math inline">m\leq n</span>. I wrote <a href="https://gist.github.com/chaoxu/5210853">a program in Haskell that generate a regular expression that matches all decimal representation of some number in between <span class="math inline">a</span> and <span class="math inline">b</span> inclusive</a>. The regular expression would have length <span class="math inline">O(\log n \log \log n)</span>. I also included a simple version, which shows how the algorithm is done.</p>
<p>The code was made for the decimal system, but of course it can be generalized to any base.</p>
<p>Example:</p>
<p><code>matchIntRange 123 4321</code></p>
<p><code>1(2[3-9]|[3-9]\d)|[2-9]\d\d|[123]\d{3}|4([012]\d\d|3([01]\d|2[01]))</code></p>
<p>The main idea is to consider a set of tries. Each one contain strings with the same length. The regular expression has a structure closely related to this trie. It be nice if there is a polytime algorithm to generate the shortest regular expression for this problem if all we can use is (), |.</p>
<p>It is important to also handle cases where we will have repeated elements</p>
<p><code>matchIntRange 12121212 12121212</code></p>
<p><code>(12){4}</code></p>
<p>This is done by recursively try to compress a free monoid element with the <a href="/posts/2013-03-26-represent-an-element-in-a-free-monoid-with-minimum-weight.html">FreeMonoidCompress</a> module.</p>
<script src="https://gist.github.com/chaoxu/5210853.js"></script>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-03-21. </div>
    <div class="info">Tags: Haskell, regular expression.</div>

</div>]]></description>
    <pubDate>Thu, 21 Mar 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-03-21-regular-expression-for-a-interval-of-non-negative-integers.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>There exist a path of length <span class="math inline">\lceil d(G)\rceil</span> for every graph <span class="math inline">G</span></title>
    <link>https://chaoxuprime.com/blog/posts/2013-01-30-there-exist-a-path-of-length-d-g-for-every-graph-g.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="unweighted-graph"><span class="header-section-number">1</span> Unweighted Graph</h1>
<p><span class="math inline">G</span> is a simple graph, then <span class="math inline">d(G) = \frac{2e(G)}{|G|}</span> be the average degree of a simple graph.</p>
<section class="theorem-environment Lemma" id="Lemma-1">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">1</span></span>
<p>If <span class="math inline">G</span> is a connected graph, then it contain a path of length <span class="math inline">\min(2\delta(G), |G|-1)</span>, where <span class="math inline">\delta(G)</span> is the minimum degree of <span class="math inline">G</span>. (exercise 1.7. in Graph Theory by Diestel)</p>
</section>
<section class="theorem-environment Lemma" id="Lemma-2">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">2</span></span>
<p>Every graph <span class="math inline">G</span> has a component <span class="math inline">H</span>, such that <span class="math inline">d(H)\geq d(G)</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Fact: If <span class="math inline">x_i,y_i&gt;0</span> and <span class="math inline">\frac{x_i}{y_i} &lt; t</span> for all <span class="math inline">1\leq i\leq k</span>, then <span class="math inline">\frac{\sum_{i=1}^k x_i}{\sum_{i=1}^k y_i} &lt; t</span>. Assume the lemma is false, then consider all it's components <span class="math inline">H_1,\ldots,H_k</span>, <span class="math inline">d(H_i) = \frac{2e(H_i)}{|H_i|} &lt; d(G)</span>, then <span class="math inline">d(G) = \frac{\sum_{i=1}^k 2e(H_i)}{\sum_{i=1}^k |H_i|} &lt; d(G)</span>, a contradiction.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>A simple graph <span class="math inline">G</span> must contain a path of length at least <span class="math inline">d(G)</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Proof by induction. It is true for graph with 1 vertex. Assume it is true for all graphs with <span class="math inline">k</span> vertices, <span class="math inline">k &lt; n</span>. Consider graph <span class="math inline">G</span> of <span class="math inline">n</span> vertices. If the graph has more than 1 component, then we use <a href="#Lemma-2">Lemma 2</a> and show there exist a subgraph <span class="math inline">H</span> with strictly smaller number of vertices, such that <span class="math inline">d(H)\geq d(G)</span>, and just apply the induction hypothesis.</p>
<p>Otherwise, the graph is connected. If there exist a vertex <span class="math inline">v</span> with degree at most <span class="math inline">\frac{1}{2}d(G)</span>, we can remove it, and <span class="math inline">d(G-v) \geq d(G)</span>, then by inductive hypothesis, in <span class="math inline">d(G-v)</span> there will be a path of length at least <span class="math inline">d(G)</span>. If there is no such vertex. then we must have <span class="math inline">\delta(G) &gt; \frac{1}{2} d(G)</span>. By <a href="#Lemma-1">Lemma 1</a>, we have it has a path of length <span class="math inline">\min(2 \delta(G) ,|G|-1)</span>. <span class="math inline">2\delta(G) \geq d(G)</span> and <span class="math inline">d(G)\leq |G|-1</span>, thus it contain a path of length at least <span class="math inline">d(G)</span>.</p>
</section>
<h1 id="weighted-graph"><span class="header-section-number">2</span> Weighted Graph</h1>
<p>Can we generalize this problem to weighted graphs? <span class="math inline">G=(V,E)</span>, <span class="math inline">(G,w)</span> is a weighted graph, where <span class="math inline">w: E\to \mathbb{R}</span>. Define the average weighted degree of graph <span class="math inline">G</span> to be <span class="math display">\displaystyle 
d_w(G) = \frac{2\sum_{e\in E} w(e)}{|G|},
</span> and the minimum weighted degree <span class="math display">\displaystyle 
\delta_w(G) = \min_{e\in E} \{w(e)\}.
</span> If <span class="math inline">P</span> is a path, then the weight of the path is <span class="math inline">W(P) = \sum_{e\in P} w(e)</span>. What can we say about the path with maximum weight? It is easy to prove that there is a path of weight at least <span class="math inline">\delta_w(G)</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-4">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">4</span></span>
<p>For a weighted graph <span class="math inline">(G,w)</span>, there exist a path of weight at least <span class="math inline">\delta_w(G)</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Consider the longest path <span class="math inline">v_1,\ldots,v_n</span>. Claim: <span class="math inline">w(\{v_i,v_n\})\leq w(\{v_i,v_{i+1}\})</span> for all <span class="math inline">i</span>. Assume not, then the path <span class="math inline">v_1,\ldots,v_{i-1},v_i,v_n,v_{n-1}\ldots,v_{i+1}</span> would be heavier, a contradiction. Therefore we have <span class="math display">\displaystyle 
\delta_w(G) \leq \sum_{\{v_i,v_n\}\in E} w(\{v_i,v_n\}) \leq \sum_{i=1}^{n-1} w(\{v_i,v_{i+1}\})  = W(v_1\ldots v_{n})
</span></p>
</section>
<p>However, we want something stronger, say instead of <span class="math inline">\delta_w(G)</span>, can it be <span class="math inline">d_w(G)</span>? I have a proof but it uses a difficult lemma.</p>
<section class="theorem-environment Definition" id="Definition-5">
<span class="theorem-header"><span class="type">Definition</span><span class="index">5</span></span>
<p>A <em>perfect path double cover</em> (PPDC) for graph <span class="math inline">G</span> is a set of paths, such that every edge is covered exactly two times, and every vertex is the end point of exactly two of the paths.</p>
</section>
<p>Note a PPDC for a graph with <span class="math inline">n</span> vertices is a set of <span class="math inline">n</span> paths.</p>
<section class="theorem-environment Lemma" id="Lemma-6">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">6</span></span>
<p>Every simple graph has a perfect path double cover.</p>
</section>
<p>The lemma is proven by <a href="http://onlinelibrary.wiley.com/doi/10.1002/jgt.3190140604/abstract">Hao Li in 1990</a>.</p>
<p>Now we conclude with the theorem that eats up all the above special cases.</p>
<section class="theorem-environment Theorem" id="Theorem-7">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p>For a weighted graph <span class="math inline">(G,w)</span>, there exist a path of length at least <span class="math inline">d_w(G)</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Consider a PPDC of <span class="math inline">G</span> with <span class="math inline">n</span> paths <span class="math inline">p_1,\ldots,p_n</span>. <span class="math inline">\sum_{i=1}^n l(p_i) = nd_w(G)</span>, by pigeonhole principle, at least one of the path has length at least <span class="math inline">d_w(G)</span>.</p>
</section>
<p>I wonder if there is a simpler proof of the fact, so no high machinery like PPDC are involved.</p>
<p>All these results are of course, already known. Frieze, McDiarmid and Reed have solved it in 1992. It is a 10 page proof, and thanks to Charalampos who provided it in the comment. The proof for PPDC only used 2 pages, so this would be an easier proof.</p>
<p>How do we find such a path? PPDC can be computed in <span class="math inline">O(m\Delta(G))</span> time, so we actually have a polynomial time algorithm for this.</p>
<p>This give us a fun problem.</p>
<section class="theorem-environment Problem" id="Problem-8">
<span class="theorem-header"><span class="type">Problem</span><span class="index">8</span></span>
<p>Prove that for every weighted multigraph with no self loop, if it has <span class="math inline">M</span> edges and the largest set pairwise non-parallel edges has <span class="math inline">m</span> edges, then there exist a path of weight at least <span class="math inline">\frac{d_w(G)}{M-m+1}</span>.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2013-01-30. </div>
    <div class="info">Tags: graph theory.</div>

</div>]]></description>
    <pubDate>Wed, 30 Jan 2013 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2013-01-30-there-exist-a-path-of-length-d-g-for-every-graph-g.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Number of ways to make change</title>
    <link>https://chaoxuprime.com/blog/posts/2012-08-31-number-of-ways-to-make-change.html</link>
    <description><![CDATA[<br />
<div>
<p>A famous dynamic programming problem ask one to find how many ways to make change of a certain value. Formally, a program that take input <span class="math inline">d_1,\ldots,d_m</span> and <span class="math inline">n</span>, and output <span class="math display">\displaystyle 
 \left|\{ (c_1,\ldots,c_m) | c_i\in \N , \sum_{i=1}^m c_i d_i = n\} \right|.
</span></p>
<p>The dynamic programming solution can solve this problem in <span class="math inline">O(nm)</span> time and <span class="math inline">O(\min(n,\max(d_1,\ldots,d_m))</span> space.</p>
<p>Is it efficient? It's a very efficient pseudo-polynomial time algorithm.</p>
<p>However if we fixed the denominations, this runs in <span class="math inline">O(n)</span> time, and it is no longer the fastest algorithm. Since if denominations are fixed, we can find the solution in <span class="math inline">O(1)</span> time (assuming addition and multiplication of integers can be done in constant time.)</p>
<p>So we want to come up with a closed formula by generating functions.</p>
<p><span class="math display">\displaystyle 
C(x) = \prod_{i=1}^m \sum_{j=0}^\infty x^{j d_i}
</span></p>
<p>The coefficient for <span class="math inline">x^n</span> is our solution. Let <span class="math inline">l = \lcm(d_1,\ldots,d_m)</span>.</p>
<p><span class="math display">\displaystyle \begin{aligned}
C(x) &amp;= \prod_{i=1}^m \sum_{j=0}^\infty x^{j d_i}\\
&amp;= \prod_{i=1}^m (1-x^{d_i})^{-1}\\
&amp;= \left( \prod_{i=1}^m \sum_{j=0}^{l/d_i - 1} x^{j d_i} \right)(1-x^l)^{-m}\\
&amp;= \left( \prod_{i=1}^m \sum_{j=0}^{l/d_i - 1} x^{j d_i} \right)
\sum_{k=0}^\infty { k+m-1 \choose m-1  } x^{lk}\\
\end{aligned}</span></p>
<p>Now, notice the first part can be precomputed as some polynomial with finite degree. Let it be <span class="math inline">P(x)</span>, then we get that we need to find the coefficient of <span class="math inline">x^n</span> in the following expression. <span class="math display">\displaystyle 
\sum_{k=0}^\infty P(x) { k+m-1 \choose m-1  } x^{lk}
</span></p>
<p>This is of course easy as we only need to test <span class="math inline">k</span>'s where <span class="math inline">n-lk \leq \deg(P)</span>. There are only constant number of them.</p>
<p>Also notice those binomial coefficient need at most <span class="math inline">m-1</span> multiplications. Thus we can find the solution in <span class="math inline">O(1)</span> time.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2012-08-31. </div>
    <div class="info">Tags: enumerative combinatorics, math.</div>

</div>]]></description>
    <pubDate>Fri, 31 Aug 2012 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2012-08-31-number-of-ways-to-make-change.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Basis of the module <span class="math inline">\Z^n</span></title>
    <link>https://chaoxuprime.com/blog/posts/2012-08-30-basis-of-the-module-z-n.html</link>
    <description><![CDATA[<br />
<div>
<p>A student who is taking linear algebra asked me the following problem.</p>
<p>If we consider the field <span class="math inline">\R</span> restricted to <span class="math inline">\Z</span>, and create a &quot;vector space&quot; on <span class="math inline">\Z</span>. How do we know if <span class="math inline">v,u\in \Z^2</span> &quot;spans&quot; <span class="math inline">\Z^2</span>?</p>
<p>Formally, what can we say about <span class="math inline">v</span> and <span class="math inline">u</span> if for every <span class="math inline">w\in \Z^2</span>, there exist <span class="math inline">n,m\in \Z</span>, such that <span class="math inline">nv + mu = w</span>.</p>
<p>We can generalize it and put it in terms of modules, as <span class="math inline">\Z</span> is only a ring but not a field.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p><span class="math inline">v_1,\ldots,v_n</span> is a basis for the module <span class="math inline">\Z^n</span> iff the matrix <span class="math inline">M</span> formed by the vectors is a unimodular matrix.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math inline">\Rightarrow</span> If <span class="math inline">\det(M)=0</span>, then <span class="math inline">v_1,\ldots,v_n</span> are not linearly independent. If <span class="math inline">|\det(M)|\geq 2</span>, then the parallelepiped formed by <span class="math inline">v_1,\ldots,v_n</span> has volume <span class="math inline">\geq 2</span>. If there is any integer point not on the corners of the parallelepiped, then that point can't be written as linear combination of <span class="math inline">v_1,\ldots,v_n</span>. Notice that it must contain some lattice points not on the corners of the parallelepiped. One can see why by consider a large box that contain volume of <span class="math inline">m</span> such parallelepiped, but contain at least <span class="math inline">2m</span> lattice points.</p>
<p>This shows if <span class="math inline">M</span> is not unimodular, then <span class="math inline">v_1,\ldots,v_n</span> can't be a basis.</p>
<p>Alternative proof: <span class="math inline">M</span> is not unimodular then <span class="math inline">M^{-1}</span> contain a non-integer entry. This shows there exist a <span class="math inline">b</span>, such that the solution <span class="math inline">x</span> to <span class="math inline">Mx=b</span> contain a non-integer entry. (proposed by Thao Do)</p>
<p><span class="math inline">\Leftarrow</span> <span class="math inline">|\det(M)|=1</span> implies it has a inverse over <span class="math inline">\Z</span>, thus <span class="math inline">Mx = b</span> for any <span class="math inline">b\in \Z^n</span> always has a solution.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2012-08-30. </div>
    <div class="info">Tags: math.</div>

</div>]]></description>
    <pubDate>Thu, 30 Aug 2012 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2012-08-30-basis-of-the-module-z-n.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>A relation between <span class="math inline">L_\infty</span> metric and <span class="math inline">L_1</span> metric in <span class="math inline">\R^2</span></title>
    <link>https://chaoxuprime.com/blog/posts/2012-08-23-a-relation-between-l-infty-metric-and-l-1-metric-in-r-2.html</link>
    <description><![CDATA[<br />
<div>
<p>While solving the <a href="https://www.hackerrank.com/challenges/meeting-point">Meeting Point</a> problem from interviewstreet, I have stumbled upon a relation between <span class="math inline">L_\infty</span> metric and <span class="math inline">L_1</span> metric in <span class="math inline">\R^2</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>Let <span class="math inline">x=(x_1,x_2)</span>, consider the map <span class="math inline">f:\R^2\to \R^2</span>, <span class="math display">\displaystyle 
f(x) = (x_1-x_2,x_1+x_2)
</span> then <span class="math display">\displaystyle 
d_\infty(x,y) = \frac{d_1(f(x),f(y))}{2}
</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<ol type="1">
<li>Notice we only need to prove <span class="math inline">\|x\|_\infty = \frac{ \|f(x)\|_1}{2}</span> as the metric is the standard metric generated by the norm.</li>
<li>Note the following relation <span class="math inline">\max(|a|,|b|) = \frac{ |a+b| + |a-b|}{2}</span>.</li>
<li>Combine the two above and we get the result.</li>
</ol>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2012-08-23. </div>
    <div class="info">Tags: math.</div>

</div>]]></description>
    <pubDate>Thu, 23 Aug 2012 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2012-08-23-a-relation-between-l-infty-metric-and-l-1-metric-in-r-2.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Maximize the area of a radar chart</title>
    <link>https://chaoxuprime.com/blog/posts/2012-08-08-maximize-the-area-of-a-radar-chart.html</link>
    <description><![CDATA[<br />
<div>
<p>People use <a href="http://en.wikipedia.org/wiki/Radar_chart">radar charts</a> to present their ability in different skills.</p>
<p>Like all self presentations, it need to make the person &quot;look good&quot;. A chart with larger area looks better than the ones with less area. The remaining of the article take about how to find a radar chart with maximum area.</p>
<figure>
<img src="/files/radarchart.png" alt="Two Radar Charts" /><figcaption>Two Radar Charts</figcaption>
</figure>
<p>In the image above, the left side has less area than the right.</p>
<p>Given the sequence of data <span class="math inline">(a_1,c_1),\ldots,(a_n,c_n)</span>, where <span class="math inline">a_i</span> is the value, a positive number, <span class="math inline">c_i</span> is a coordinate(in the image, the coordinates would be &quot;combinatorics&quot;, &quot;algorithms&quot;, etc.). How can we permute them, such that the data plotted on the radio chart is maximized?</p>
<p>The area of of any single section of the radio chart is <span class="math inline">ab \frac{\cos \theta}{2}</span>, where <span class="math inline">\theta = \frac{2\pi}{n}</span>, and <span class="math inline">a,b</span> are the value for two adjacent coordinates. The area of the entire shape is the sum.</p>
<p>Once we can maximize <span class="math inline">\sum_{i=1}^n a_{\pi(i)} a_{\pi(i+1)}</span>, we are done.</p>
<section class="theorem-environment Lemma" id="Lemma-1">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">1</span></span>
<p>If <span class="math inline">x\geq a\geq b \geq c \geq d\geq 0</span>, then <span class="math inline">ax+bx - ab \geq cx+dx-cd</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let's consider what is required to make sure the property works. <span class="math display">\displaystyle \begin{aligned}
(a+b)x-ab &amp;\geq  (c+d)x-cd\\
x&amp;\geq \frac{ab-cd}{a-c+b-d}\\
x&amp;\geq \frac{ab-bc+bc-cd}{a-c+b-d}\\
x&amp;\geq \frac{b(a-c)+c(b-d)}{a-c+b-d}\\
x&amp;\geq \frac{b(a-c+b-d)}{a-c+b-d}\\
x&amp;\geq b
\end{aligned}</span> The lemma is true, as <span class="math inline">x\geq b</span> is part of the hypothesis for <span class="math inline">x</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Let <span class="math inline">a_1,\ldots,a_n</span> be a sequence of positive numbers, such that <span class="math inline">a_1 \leq \ldots \leq a_n</span>.</p>
<p>Let <span class="math inline">\pi</span> be the following:</p>
<ol type="1">
<li><span class="math inline">\pi(n+1) = 1</span>.</li>
<li><span class="math inline">\pi(1),\ldots,\pi(n) = 1, 3, \ldots, n-1, n, n-2, \ldots, 4, 2</span> if <span class="math inline">n</span> is even</li>
<li><span class="math inline">\pi(1),\ldots,\pi(n) = 1, 3, \ldots, n-2, n, n-1, \ldots, 4, 2</span> if <span class="math inline">n</span> is odd.</li>
</ol>
<p><span class="math inline">\pi</span> maximizes <span class="math display">\displaystyle 
\sum_{i=1}^n a_{\pi(i)}a_{\pi(i+1)}
</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Proof by induction.</p>
<p><em>Base case:</em> Base case for <span class="math inline">n=1,2</span> are trivial.</p>
<p><em>Inductive Step:</em> Consider it is true for <span class="math inline">n-1</span>, we want to show it is true for <span class="math inline">n</span>.</p>
<p>Consider we already obtained a sequence from <span class="math inline">a_1</span> to <span class="math inline">a_{n-1}</span>, and we want to insert <span class="math inline">a_n</span> somewhere. Clearly <span class="math inline">a_n</span> need to be placed in a position that maximizes its contribution. If we can insert it between <span class="math inline">a_{n-1}</span> and <span class="math inline">a_{n-2}</span>, then we get a contribution of <span class="math inline">a_{n-1}a_n+a_{n-2}a_n-a_{n-1}a_{n-2}</span>. By the lemma, it will give us the maximum contribution.</p>
<p>If we can get the maximum contribution (over all possible configurations) to a maximum configuration for <span class="math inline">a_1</span> to <span class="math inline">a_{n-1}</span>, then we are done. The inductive hypothesis show the maximum configuration have adjacent <span class="math inline">a_{n-1}</span> and <span class="math inline">a_{n-2}</span>, therefore this shows the maximum configuration is where we insert <span class="math inline">a_n</span> in between <span class="math inline">a_{n-1}</span> and <span class="math inline">a_{n-2}</span> in the previous maximum configuration.</p>
</section>
<p>This implies a simple <span class="math inline">O(n \log n)</span> algorithm. Find the permutation that sort the input sequence by value, then composes it with permutation <span class="math inline">\pi</span>.</p>
<p>Actually this problem is a special case of the TSP problem on a product matrix. A matrix is called a product matrix if <span class="math inline">M_{i,j} = a_ib_j</span> for vectors <span class="math inline">(a_1,\ldots,a_n)</span> and <span class="math inline">(b_1,\ldots,b_n)</span>. It is solvable in polynomial time if <span class="math inline">M</span> is a symmetric matrix <span class="citation" data-cites="burkard1998">[<a href="#ref-burkard1998">1</a>]</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-burkard1998">
<p>[1] R.E. Burkard, V.G. Deῐneko, R. van Dal, J.A.A. van der Veen, G.J. Woeginger, <strong>Well-solvable special cases of the traveling salesman problem: A survey</strong>, SIAM Review. 40 (1998) pp. 496–546.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2012-08-08. </div>
    <div class="info">Tags: math.</div>

</div>]]></description>
    <pubDate>Wed, 08 Aug 2012 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2012-08-08-maximize-the-area-of-a-radar-chart.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>A cute theorem involving xor</title>
    <link>https://chaoxuprime.com/blog/posts/2012-06-19-a-cute-theorem-involving-xor.html</link>
    <description><![CDATA[<br />
<div>
<p>Define <span class="math inline">[a..b] = \set{x|a\leq x\leq b, x\in \mathbb{N} }</span>, and <span class="math inline">k\oplus [a..b] = \set{k\oplus x| x\in [a..b]}</span>, where <span class="math inline">\oplus</span> is the bitwise xor function. We want to know something about <span class="math inline">k\oplus [a..b]</span>.</p>
<section class="theorem-environment Lemma" id="Lemma-1">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">1</span></span>
<p><span class="math inline">x-y \leq x\oplus y \leq x+y</span></p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math inline">x\oplus y \leq x+y</span> is easy to see as <span class="math inline">\oplus</span> is binary addition without carries. Assume <span class="math inline">x\oplus y &lt; x-y</span> for some <span class="math inline">x</span> and <span class="math inline">y</span>, then <span class="math display">\displaystyle 
x = x\oplus(y\oplus y)
= (x\oplus y) \oplus y &lt;
(x-y)\oplus y\leq (x-y)+y = x
</span> A contradiction. Therefore <span class="math inline">x-y \leq x\oplus y</span>.</p>
</section>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p><span class="math inline">\oplus</span>, binary addition without carries, and binary subtraction without borrows are the same operation. The lemma is trivial by notice that equivalence.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>If <span class="math inline">f:\mathbb{N}\to \mathbb{N}</span> a surjection such that <span class="math inline">x-n\leq f(x)\leq x+m</span>, then</p>
<ol type="1">
<li><span class="math inline">[a+m..b-n] \subseteq f([a..b])</span></li>
<li><span class="math inline">[0..b-n] \subseteq f([b])</span></li>
</ol>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math inline">f</span> is a surjection implies all values in any integer interval gets taken. <span class="math inline">f^{-1}(y)=\min(\{x|f(x)=y\})</span> <span class="math display">\displaystyle 
x-n\leq f(x)\leq x+m \implies y+m\leq f^{-1}(y)\leq y-n.
</span></p>
<ol type="1">
<li>If <span class="math inline">y\in [a+m..b-n]</span>, <span class="math inline">f^{-1}(y) \in [(a+m)-m.. (b-n)+n] = [a..b]</span>.</li>
<li>If <span class="math inline">y\in [0..b-n]</span>, <span class="math inline">f^{-1}(y) \in [\max(0-m,0).. (b-n)+n] = [0..b]</span>.</li>
</ol>
</section>
<p>Let <span class="math inline">f_k(x) = k\oplus x</span>, noting that <span class="math inline">f_k</span> is a bijection, we derive the result we want for xor.</p>
<section class="theorem-environment Corollary" id="Corollary-3">
<span class="theorem-header"><span class="type">Corollary</span><span class="index">3</span></span>
<ol type="1">
<li><span class="math inline">[a+k..b-k] \subseteq k\oplus [a..b]</span>.</li>
<li><span class="math inline">[0..b-k] \subseteq k\oplus [0..b]</span>.</li>
</ol>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2012-06-19. </div>
    <div class="info">Tags: math.</div>

</div>]]></description>
    <pubDate>Tue, 19 Jun 2012 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2012-06-19-a-cute-theorem-involving-xor.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Proof that binomial coefficients are integers</title>
    <link>https://chaoxuprime.com/blog/posts/2012-04-23-proof-that-binomial-coefficient-are-integers.html</link>
    <description><![CDATA[<br />
<div>
<p><a href="http://www.eaglefantasy.com/">Eagle Fantasy</a> asked how to prove that binomial coefficients are integers without induction or counting. He seek a purely number theoretical proof.</p>
<p>One common way to prove a number is a integer is to show it has a integer factorization. Thus one try to demonstrate that <span class="math inline">{n \choose k}</span> has such factorization.</p>
<p>Let's start by figure out what is the factorization of <span class="math inline">n!</span>. Consider any prime <span class="math inline">p</span>. Certainly all numbers from <span class="math inline">1</span> to <span class="math inline">n</span> that is divisible by <span class="math inline">p</span> contribute to the exponent by <span class="math inline">1</span>, numbers that divisible by <span class="math inline">p^2</span> contribute to the exponent by <span class="math inline">1</span>, as we already counted one of the <span class="math inline">p</span> factor already. Similarly, one apply this for all <span class="math inline">p^i</span> and result <span class="math inline">p^{\sum_{i=1}^\infty \floor{\frac{n}{p^i}}} | n!</span>, and by unique factorization theorem, we get that <span class="math display">\displaystyle 
n! =\prod_{k=1}^\infty p_k^{\sum_{i=1}^\infty \floor{\frac{n}{p_k^i}}} 
</span> where <span class="math inline">p_k</span> is the <span class="math inline">k</span>-th prime.</p>
<p>Of course, since we are going to manipulate the sum and the product, it is better to replace <span class="math inline">\infty</span> to some large <span class="math inline">N</span> so we don't need to define what we mean by infinite product or why we can switch the order of summation, etc.</p>
<p>Now consider the following inequality, left as an exercise to the reader <span class="math inline">\floor{a+b}\geq \floor{a} + \floor{b}</span>. Then everything follows by easy algebraic manipulation. <span class="math display">\displaystyle \begin{aligned}
{n\choose k} &amp;= \frac{n!}{(n-k)!k!}\\
&amp;= \frac{\prod_{k=1}^N p_k^{\sum_{i=1}^N \floor{\frac{n}{p_k^i}}}}{\prod_{k=1}^N p_k^{\sum_{i=1}^N \floor{ \frac{n-k}{p_k^i} }} \prod_{k=1}^N p_k^{\sum_{i=1}^N \floor{ \frac{k}{p_k^i} }} }\\
&amp;= \prod_{k=1}^N p_k^{\sum_{i=1}^N \floor{ \frac{n}{p_k^i} } - \floor{ \frac{n-k}{p_k^i} } - \floor{ \frac{k}{p_k^i} }}
\end{aligned}</span> Using the previous inequality, we see every exponent is a integer greater or equal to <span class="math inline">0</span>. This shows <span class="math inline">{n\choose k}</span> is a integer.</p>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>This also derive the following result: <span class="math inline">k!|(m+1)\ldots (m+k)</span> for all <span class="math inline">m\geq 0</span>. One can use this result to prove that multinomial coefficients are integers.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2012-04-23. </div>
    <div class="info">Tags: math.</div>

</div>]]></description>
    <pubDate>Mon, 23 Apr 2012 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2012-04-23-proof-that-binomial-coefficient-are-integers.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Minimum area rectangle that enclose a set of rectangles</title>
    <link>https://chaoxuprime.com/blog/posts/2012-04-13-minimum-area-rectangle-that-enclose-a-set-of-rectangles.html</link>
    <description><![CDATA[<br />
<div>
<p>I was asked the following question by a friend who seeks an algorithm to the problem. I'm sure it is well studied but I can't find any relevant information:</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a set of axis-aligned rectangles, one want to arrange them on the plane by translations, such that the smallest rectangle covering them is minimized. What is the minimum area of such a covering rectangle?</p>
</section>
<p>The problem have this NP-Hard feel to it. Indeed I am able to reduce it to set partition.</p>
<p>Consider the set of blocks are of the size <span class="math inline">1\times a_1,\ldots,1\times a_n</span>, <span class="math inline">1\times (\frac{1}{2}\sum_{i=1}^n a_i)</span>. It is easy to show there is a set partition of <span class="math inline">\{a_1,\ldots,a_n\}</span> iff the minimum area of the covering rectangle is <span class="math inline">3(\frac{1}{2}\sum_{i=1}^n a_i)</span>. (As long as the sum is larger than 3.)</p>
<p>I particularly liked this reduction so I posted it here.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2012-04-13. </div>
    <div class="info">Tags: computational complexity, NP.</div>

</div>]]></description>
    <pubDate>Fri, 13 Apr 2012 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2012-04-13-minimum-area-rectangle-that-enclose-a-set-of-rectangles.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title><span class="math inline">\lcm</span> of more than two numbers as a formula of <span class="math inline">\gcd</span>s</title>
    <link>https://chaoxuprime.com/blog/posts/2012-03-06-lcm-of-more-than-two-numbers-as-a-formula-of-gcds.html</link>
    <description><![CDATA[<br />
<div>
<p>It is a common elementary number theory exercise to prove that <span class="math inline">\lcm(a,b) = \frac{ab}{\gcd(a,b)}</span>.</p>
<p>A student might ask what is the <span class="math inline">\lcm</span> of three numbers. Some might think that <span class="math display">\displaystyle 
\lcm(a,b,c) = \frac{abc}{\gcd(a,b,c)}
</span> It isn't.</p>
<p>Still, one might want a formula for the <span class="math inline">\lcm</span> of three numbers. Of course one can say <span class="math inline">\lcm(a,\lcm(b,c))</span>. In fact this is the common algorithm for computation. Are they ways to relate <span class="math inline">\lcm</span> and <span class="math inline">\gcd</span> without nesting those functions together?</p>
<p>Yes, but the formula is not so pretty. <span class="math display">\displaystyle 
\lcm(a,b,c) = \frac{abc \gcd(a,b,c)}{\gcd(a,b)\gcd(b,c)\gcd(a,c)}
</span></p>
<p>This article shows how we can prove this result, and easily infer a more general theorem. First, we see there is a group isomorphism from the naturals to it's prime factors <span class="math inline">f:\mathbb{N} \to \mathbb{N}^\infty</span>, <span class="math inline">f(p_1^{e_1} \ldots p_n^{e^n}) = (e_1,\ldots,e_n,0,0,\ldots)</span>, where <span class="math inline">p_n</span> is the <span class="math inline">n</span>th prime.</p>
<p>It's easy to show <span class="math display">\displaystyle \begin{aligned}
\lcm(a_1,a_2,\ldots,a_n) &amp;= f^{-1} (\max(f(a_1),\ldots,f(a_n)))\\
\gcd(a_1,a_2,\ldots,a_n) &amp;= f^{-1} (\min(f(a_1),\ldots,f(a_n)))
\end{aligned}</span> where <span class="math inline">\max</span> and <span class="math inline">\min</span> are defined coordinate-wise. In fact we only need to concern with one single coordinate. So the problem become proving <span class="math display">\displaystyle 
\max(a,b,c) = a+b+c+\min(a,b,c)-(\min(a,b)+\min(b,c)+\min(a,c))
</span>, then the formula for <span class="math inline">\lcm</span> of 3 numbers holds.</p>
<p>This look familiar to the inclusion-exclusion principle, and certainly we can use it to prove it and generalize! Let <span class="math inline">\mu</span> be the Lebesgue measure, then for a finite sequence of non-negative reals <span class="math inline">\set{a_i}</span>, <span class="math display">\displaystyle \max(a_1,\ldots,a_n) = \mu(\bigcup_{i=1}^n [0,a_i]).</span> It's just some standard arguments to show <span class="math inline">\max</span> does have the inclusion-exclusion structure. It generalize to allow negative reals by simply add a large enough constant to make them positive, and subtract the constant from the result. Formulas for <span class="math inline">\min,\gcd,\lcm</span> follows similarly.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2012-03-06. </div>
    <div class="info">Tags: number theory.</div>

</div>]]></description>
    <pubDate>Tue, 06 Mar 2012 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2012-03-06-lcm-of-more-than-two-numbers-as-a-formula-of-gcds.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Continued Fraction Arithmetic in Haskell</title>
    <link>https://chaoxuprime.com/blog/posts/2011-12-27-continued-fraction-arithmetic-in-haskell.html</link>
    <description><![CDATA[<br />
<div>
<p>I learned the algorithm to do arithmetic on continued fractions from the <a href="http://perl.plover.com/yak/cftalk/">talk by Mark Jason Dominus</a>. This algorithm can be generalized to handle many other kind of functions.</p>
<p>I wrote an module ContinuedFraction in Haskell. It is an instance of the type class RealFrac. So you can use the four arithmetic operations like it's any other kind of real numbers.</p>
<p>A continued fraction is implemented as a list of <code>Integral</code>. Infinite continued fraction is possible! Although lazy evaluation make it easy to get only the first <span class="math inline">k</span> terms, some operation will not terminate. Currently, the only one I know of is comparing two equal infinite continued fractions. So make sure only compare a truncated version of two infinite continued fractions.</p>
<p>It is possible to create formal continued fractions that doesn't correspond to any real number. No one know what will the arithmetic outcomes be.</p>
<p>A continued fraction is canonical if the sign of all the numbers are the same. One can create non-canonical continued fractions that does converge to a real number. For example, <code>ContinuedFraction [1,1,-2]</code> is actually <code>ContinuedFraction [3]</code>. Conversion to canonical version is easy, add it by <code>ContinuedFraction [0]</code>.</p>
<p>Order operations does not work with non-canonical representations.</p>
<p>The code will stay in <a href="https://github.com/chaoxu/mgccl-haskell/blob/master/random/ContinuedFraction.hs">this page</a> until one day I have the patience and motivation to make this into a package. This is why I need a internship in a company that actually use Haskell.</p>
<p>I hope people can catch possible bugs. I'm open to suggestions!</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-12-27. </div>
    <div class="info">Tags: Haskell.</div>

</div>]]></description>
    <pubDate>Tue, 27 Dec 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-12-27-continued-fraction-arithmetic-in-haskell.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Given sequence of angles, find a polygon</title>
    <link>https://chaoxuprime.com/blog/posts/2011-12-23-given-sequence-of-angles-find-a-polygon.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Find a polygon <span class="math inline">p_1\ldots p_n</span>, such that the angle at vertex <span class="math inline">p_i</span> is <span class="math inline">\alpha_i</span>.</p>
</section>
<p>Define <span class="math inline">p_{n+1} = p_1</span> for a polygon <span class="math inline">p_1\ldots p_n</span>. If one consider a polygon's sides are vectors, then a polygon is set of vectors that equals to 1, such that the magnitude of the vectors are greater than 0.</p>
<p>Angles at each vertex determines the direction of the vector. Let <span class="math inline">u_i</span> be the unit vector with direction of <span class="math inline">p_ip_{i+1}</span>, we have</p>
<p><span class="math display">\displaystyle 
\sum_{i=1}^n c_iu_i = 0
</span></p>
<p><span class="math inline">c_i&gt;0</span> for all <span class="math inline">i</span>. <span class="math inline">u_i</span> can be computed from <span class="math inline">\alpha_i</span> trivially. We assume we have normalized the polygon by rotate it, so <span class="math inline">u_1=(0,1)</span>. Once we find a set of <span class="math inline">c_i</span>, then we determine a solution to the problem. <span class="math inline">(c_1,\ldots,c_n)</span> is in the intersection of the solutions of two set of linear systems. One might first calculate the solution to the linear systems individually, then take the intersection, and pick a point where all coordinates are positive.</p>
<p>This is not easy to code, and it take <span class="math inline">O(n^3)</span> time to just solve the linear system. A better and faster solution exploits the fact we are operating in a small dimension.</p>
<p>Observe that a polygon lies on a plane, a 2D space, we might think we can arbitrarily put down the length of <span class="math inline">n-1</span> vectors, and calculate the last one from it. It is not true, the <span class="math inline">c_i&gt;0</span> condition shows <span class="math inline">\set{c_1u_1+c_2u_2|c_1,c_2&gt;0}</span> does not contain the origin unless <span class="math inline">u_1=-u_2</span>.</p>
<p>If we can find <span class="math inline">u_1,u_2,u_3</span>, such that the convex hull of them contains the origin (here the convex hull means the open polygon contained inside), then clearly we can use <span class="math inline">u_1,u_2,u_3</span> to span the entire plane. The span here is defined as all the values can be obtained from conical combination. This inspires the following algorithm:</p>
<p>Find <span class="math inline">u_x,u_y,u_z</span> that spans the entire plane by checking if the convex hull contains <span class="math inline">(0,0)</span>. Arbitrarily assign <span class="math inline">c_i</span>, such that <span class="math inline">i\neq y,z</span>. Calculate <span class="math inline">c_y</span> and <span class="math inline">c_z</span> from the assignment.</p>
<p>Once <span class="math inline">u_x,u_y,u_z</span> are found, only <span class="math inline">O(n)</span> time is required to find the polygon. Find the three spanning vectors is linear time. Pick any two adjacent vectors as <span class="math inline">u_x,u_y</span>, and do a search for <span class="math inline">u_z</span> that satisfy the condition. One can find a solution in <span class="math inline">O(n)</span> time.</p>
<p>If the algorithm fails, there are two possibilities:</p>
<ol type="1">
<li>There is no such polygon.</li>
<li>There are only four directions, and they are exactly <span class="math inline">(1,0),(0,1),(-1,0),(0,-1)</span>. We can solve this special case by arbitrarily assign <span class="math inline">c_i</span> except the 2 of the directions. Calculate the length for those two from the other ones. This special case can be solved in <span class="math inline">O(n)</span> time too.</li>
</ol>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-12-23. </div>
    <div class="info">Tags: computational geometry.</div>

</div>]]></description>
    <pubDate>Fri, 23 Dec 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-12-23-given-sequence-of-angles-find-a-polygon.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Fill a checkerboard</title>
    <link>https://chaoxuprime.com/blog/posts/2011-12-21-fill-a-checkerboard.html</link>
    <description><![CDATA[<br />
<div>
<p>This was a homework problem for CSE 548. It's also a very common puzzle.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a <span class="math inline">n\times n</span> checkerboard, one can put a few checkers on it. A rule transform a checkerboard to the next. The rule states one can put a new checker if and only if at least two of it's adjacent positions (up, down, left, right) has a checker. Apply the rule until no more checker can be added. Show that if originally the checkerboard has only <span class="math inline">n-1</span> checkers, then when the process terminates, there exist cells not filled by a checker.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Consider any <span class="math inline">n-1</span> pieces that are already placed on the board. Consider the following process:</p>
<ol type="1">
<li>Pick any piece that was never considered, so we have a filled rectangle(square) of <span class="math inline">1\times 1</span>.</li>
<li>Find another piece that can form a larger filled rectangle from the previous rectangle.(so Manhattan distance of at most <span class="math inline">2</span> from the rectangle). This means one only regard the checkers in the rectangle and the new piece, and do the transformation until nothing more can be done. It must be form a new rectangle. If the previous rectangle is a <span class="math inline">a\times b</span> rectangle, the new rectangle is among one of the following sizes: <span class="math inline">a\times b</span>(the new piece is inside the rectangle), <span class="math inline">a\times (b+1), a\times (b+2), (a+1)\times (b+1)</span> or <span class="math inline">(a+2)\times b</span>. Note if the new rectangle is a <span class="math inline">c\times d</span> rectangle, <span class="math inline">c+d\leq a+b+2</span>. Let the new rectangle be the one we are considering.</li>
<li>If there is no other piece fit the description in step 2. Go to step 1.</li>
</ol>
<p>The process will in the end form <span class="math inline">k</span> rectangles, such that the sum of the perimeter is at most <span class="math inline">4(n-1)</span>, because each time step <span class="math inline">2</span> is run, we increase the perimeter of one of the rectangle by at most 4, each time step <span class="math inline">1</span> is run, we create a rectangle of perimeter 4. We can run those step at most <span class="math inline">n-1</span> times because there are only <span class="math inline">n-1</span> checkers.</p>
<p>If any two of the rectangles can form a larger one, then the perimeter of the new rectangle is at most the sum of the two smaller one. To show this, one can consider two cases: If they overlap, then it's clearly true. If they do not overlap, there are only 2 distinct positions. Either their diagonal touch, or their diagonals doesn't touch. Try both and you will see this is true. (It's hard to draw things and post on a blog).</p>
<p>This shows the largest filled rectangle can be produced from <span class="math inline">n-1</span> checkers have perimeter <span class="math inline">4(n-1)</span>, but to fill the <span class="math inline">n\times n</span> board, one need <span class="math inline">4n</span> as a perimeter. Therefore no configuration of <span class="math inline">n-1</span> checkers can result a filled board.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-12-21. </div>
    <div class="info">Tags: puzzle.</div>

</div>]]></description>
    <pubDate>Wed, 21 Dec 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-12-21-fill-a-checkerboard.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Implement a special kind of recurrence relation as a infinite list</title>
    <link>https://chaoxuprime.com/blog/posts/2011-12-06-implement-a-special-kind-of-recurrence-relation-as-a-infinite-list.html</link>
    <description><![CDATA[<br />
<div>
<p>A common recurrence has the form <span class="math display">\displaystyle 
a_n = \begin{cases}
   \sum_{i=0}^\infty b_ia_{n-m_i} &amp;\text{if }n&gt;k\\
   c_n &amp; \text{if }n\leq k
       \end{cases}
</span> , where <span class="math inline">m_i</span> and <span class="math inline">b_i</span> are both <em>infinite</em> sequences, and <span class="math inline">c_i</span> is a finite sequence. <span class="math inline">m_i\in \mathbb{N}</span>. <span class="math inline">a_{-i}=0</span> for all positive <span class="math inline">i</span>. This is well defined as long as <span class="math inline">b_i, a_i, c_i</span> are in the same ring.</p>
<p>One can use a balanced binary tree to store the entire infinite list, and the time to generate the <span class="math inline">n</span>th element is <span class="math inline">O(d(n)\log n)</span>, where <span class="math inline">d</span> is the density function of <span class="math inline">\set{m_i}</span>.</p>
<p>Using an array would make it <span class="math inline">O(d(n))</span>, but it is too imperative for our taste, how about we only use list and achieve <span class="math inline">O(d(n))</span> time, elegantly?</p>
<p>The idea is that we are summing the first item of infinite many stacks. However we don't have to really sum the infinite stacks, we only sum the stack we require. <a href="https://gist.github.com/1438136">The code</a>:</p>
<script src="https://gist.github.com/1438136.js?file=rec.hs"></script>
<p>What's a practical usage of this? Produce a infinite list of partition numbers, such that finding the first <span class="math inline">n</span> elements can be done in <span class="math inline">O(n^{\frac{3}{2}})</span> time and 3 lines of code. <a href="https://gist.github.com/1438142">The code</a></p>
<script src="https://gist.github.com/1438142.js?file=PartitionNumbers.hs"></script>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-12-06. </div>
    <div class="info">Tags: Haskell.</div>

</div>]]></description>
    <pubDate>Tue, 06 Dec 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-12-06-implement-a-special-kind-of-recurrence-relation-as-a-infinite-list.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>A solution to Instagram Engineering Challenge, The Unshredder in Haskell</title>
    <link>https://chaoxuprime.com/blog/posts/2011-11-13-a-solution-to-Instagram-engineering-challenge-the-unshredder-in-haskell.html</link>
    <description><![CDATA[<br />
<div>
<p>I have done many Haskell exercises, however, I have never done anything that have a engineering flavor, i.e. useful in real life.</p>
<p>I saw this challenge and believe it's the perfect chance to practice my real life Haskell skills AND get a t-shirt. <a href="https://github.com/chaoxu/mgccl-haskell/blob/master/random/unshredder.hs">The code on github</a>.</p>
<p>The problem is not well defined. Therefore I gave the following abstraction:</p>
<p>Each image is of a vertex. One construct a weighted directed graph and want to find a certain kind of path that visit all vertices.</p>
<p>What do we want to find?</p>
<p>The shortest path that visit every vertex? That would be TSP and NP-Hard.</p>
<p>However I would believe the better idea is:</p>
<p>Find a path that go though every vertex and minimize the maximal weight in the path.</p>
<p>I'm pretty sure this is also NP-complete too. Thus I will just use a greedy algorithm and assume real life data are easy.</p>
<p>I used a simple scheme to calculate the closeness between two strips: compare the last column of a strip with the first column of another strip. This decision come from my familiarity with lists instead of arrays. However, smarter move would be taking the average of a larger set of surrounding and see how each side deviates from it.</p>
<p>The function I used to calculate the difference is</p>
<p><span class="math display">\displaystyle 
\sum_{i=1}^n (\sum_{j=0}^3 |a_{i,j}-b_{i,j}|)^{1/4}
</span></p>
<p>Where <span class="math inline">a_{i,j}</span> is the value of the <span class="math inline">j</span>th channel of <span class="math inline">i</span>th pixel in the first strip's last column.</p>
<p>Which strip is the left most strip? Try all of them!</p>
<p>Running time of my algorithm is <span class="math inline">O(n^3)</span>, as it cost <span class="math inline">O(n^2)</span> time to find a path with minimum weight starting from a specific vertex. Of course it can be improved to <span class="math inline">O(n^2)</span> if I pick any vertex and expand it both ways instead of just connecting things to the right.</p>
<p>To find the optimal strip width, it is easy if one have the following assumption:</p>
<p>If the strip width is <span class="math inline">k</span>, the average difference between strips will be larger than strip width of <span class="math inline">m</span>, where <span class="math inline">m\neq kn</span> for some <span class="math inline">n</span>. Note it is possible that for strip width of <span class="math inline">2k</span> to have a higher average than <span class="math inline">k</span>.</p>
<p>One can implement an algorithm on a DAG to figure this out. I was too tired so I just pick the top <span class="math inline">i=5</span> strip widths and computed the <span class="math inline">\gcd</span> instead.</p>
<p>The code is slow, I have no idea why because I'm not experienced in how to reason about efficiency in Haskell.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-11-13. </div>
    <div class="info">Tags: Haskell.</div>

</div>]]></description>
    <pubDate>Sun, 13 Nov 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-11-13-a-solution-to-Instagram-engineering-challenge-the-unshredder-in-haskell.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Accepted to Budapest Semesters in Mathematics</title>
    <link>https://chaoxuprime.com/blog/posts/2011-10-12-accepted-to-budapest-semesters-in-mathematics.html</link>
    <description><![CDATA[<br />
<div>
<p>Yes! I am excited about all the combinatorial goodness! Certainly I want to learn about combinatorics of set systems, extremal combinatorics, combinatorial optimization, set theory and mathematical logic.</p>
<p>I will also take complex analysis and measure theory so I can get over with my math major requirements. Those are the only course I will transfer.</p>
<p>People who apply there are people who actually interested in math, not people who want to get over with the degree to be a high school teacher. I expect to meet a lot of new math friends.</p>
<p>If I'm in a private college, I would be happy with the tuition. However, I'm in a state college. Oh well.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-10-12. </div>
    <div class="info">Tags: BSM, math.</div>

</div>]]></description>
    <pubDate>Wed, 12 Oct 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-10-12-accepted-to-budapest-semesters-in-mathematics.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>What did the set of points get for its birthday?</title>
    <link>https://chaoxuprime.com/blog/posts/2011-07-22-what-did-the-set-of-points-get-for-its-birthday.html</link>
    <description><![CDATA[<br />
<div>
<p>Q: What did the set of points get for its birthday?</p>
<p>A: A convex 헐!</p>
<p>I come up with the joke with the help of <a href="http://homepages.math.uic.edu/~elee211/">Eun Hye Lee</a>. Hopefully computational geometers who also know Korean can appreciate that.</p>
<p>(헐 sounds like &quot;hull&quot;. People say &quot;헐&quot; when they a mildly surprised. A common algorithm for computing convex hulls is the <a href="http://en.wikipedia.org/wiki/Gift_wrapping_algorithm">gift wrapping algorithm</a>.)</p>
<p>Bonus:</p>
<p>Q: What is French computational geometers' favorite food?</p>
<p>A: An ε-filet.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-07-22. </div>
    <div class="info">Tags: computational geometry, korean, joke.</div>

</div>]]></description>
    <pubDate>Fri, 22 Jul 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-07-22-what-did-the-set-of-points-get-for-its-birthday.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title><span class="math inline">B_3</span> is automatic, a simple proof</title>
    <link>https://chaoxuprime.com/blog/posts/2011-07-11-b-3-is-automatic-a-simple-proof.html</link>
    <description><![CDATA[<br />
<div>
<p><span class="math inline">B_3</span> is particularly nice to analyze due to the uniqueness of the Garside normal form.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>The Garside normal form is unique in <span class="math inline">B_3</span>, and is in the form <span class="math inline">\Delta^m\sigma_{a_1}^{e_1}\ldots\sigma_{a_k}^{e_k}</span>, such that <span class="math inline">a_i \neq a_{i+1}</span>, <span class="math inline">e_1,e_k\geq 1</span> and <span class="math inline">e_2,\ldots,e_{k-1} \geq 2</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>For any word <span class="math inline">w\in B_n</span>, the Garside normal form <span class="math inline">\Delta^m p</span> is unique up to elements <span class="math inline">p</span> in <span class="math inline">B_n^+</span> and <span class="math inline">p</span> does not have a factor of <span class="math inline">\Delta</span>. Now we show that there is only one way to write <span class="math inline">p</span>.</p>
<p>Every <span class="math inline">p</span> must be in this form. If for some <span class="math inline">k&gt;i&gt;1</span>, <span class="math inline">e_i=1</span>, then <span class="math inline">a_{i-1}^{e_{i-1}}a_i^{e_i}a_{i+1}^{e_{i+1}} = a_{i-1}^{e_{i-1} -1}\Delta a_{i+1}^{e_{i+1}-1}</span>, which is a contradiction because <span class="math inline">p</span> doesn't have a factor of <span class="math inline">\Delta</span>.</p>
<p>Every word in that form is also in <span class="math inline">B_n^+</span>, and without <span class="math inline">\Delta</span> factor.</p>
<p>It's impossible to rewrite any word in this form with the relations <span class="math inline">\sigma_1\sigma_2\sigma_1 = \sigma_2\sigma_1\sigma_2</span>. Therefore this form is unique.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>The Garside normal form of <span class="math inline">B_3</span> is regular.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">A=\{\Delta,\Delta^{-1},\sigma_1,\sigma_2\}</span>, then <span class="math inline">A</span> generates <span class="math inline">G</span>. The Garside normal form is a regular language over <span class="math inline">A</span> because they exist an explicit regular expression <span class="math inline">R</span> that matches it.</p>
<p><span class="math inline">R = (\Delta^*\cup(\Delta^{-1*}))(X\cup X&#39;)</span> where <span class="math inline">X = \sigma_1^*(\sigma_2\sigma_2\sigma_2^*\sigma_1\sigma_1\sigma_1^*)^* ((\sigma_2\sigma_2\sigma_2^*\sigma_1^*)\cup \sigma_2^*))</span> and <span class="math inline">X&#39;</span> is the same except the <span class="math inline">\sigma_2</span> and <span class="math inline">\sigma_1</span> are switched.</p>
</section>
<p>Let <span class="math inline">W</span> be a FSA generated by the regular expression <span class="math inline">R</span>.</p>
<p><span class="math inline">M_\epsilon</span> exists, because the Garside normal form is unique, then <span class="math inline">M_\epsilon</span> accepts all language of the form <span class="math inline">\{(w,w)|w\in L(W)\}</span>. It have the complete same structure as <span class="math inline">W</span>, but replacing every edge <span class="math inline">x</span> with <span class="math inline">(x,x)</span>.</p>
<p>Instead of construct <span class="math inline">M_x</span> directly, we only need to prove the fellow traveler property is true. This can be done by checking it is true for every <span class="math inline">M_x</span> independently.</p>
<p>Define <span class="math inline">R(\sigma_{a_1}\ldots\sigma_{a_k}) = \sigma_{3-a_1}\ldots\sigma_{3-a_k}</span>.</p>
<p>Note that every generator has a constant distance from another generator.</p>
<p>Consider <span class="math inline">x</span> case by case:</p>
<ul>
<li><span class="math inline">\Delta</span>: The words differ in 1 <span class="math inline">\Delta</span> are <span class="math inline">\Delta^mp</span> and <span class="math inline">\Delta^{m+1}R(p)</span>.Assume <span class="math inline">m</span> is non-negative. At time <span class="math inline">|m|+1</span>, one encounters <span class="math inline">\Delta^m\sigma_{a_1}</span> and <span class="math inline">\Delta^{m+1}</span>, which has a distance of <span class="math inline">2</span>. At time <span class="math inline">|m|+2</span>, <span class="math inline">\Delta^m\sigma_{a_1}\sigma_{a_2}</span> and <span class="math inline">\Delta^{m+1}\sigma_{3-a_1} = \Delta^m\sigma_{a_1}\Delta</span>, which also has distance 2. By induction, the distance is 2 till the end, where one has <span class="math inline">\Delta^m\sigma_{a_1}\ldots\sigma_{a_k}</span> and <span class="math inline">\Delta^m\sigma_{a_1}\ldots\sigma_{a_{k-1}}\Delta</span>. With one more step, it decrease the distance to <span class="math inline">1</span>. When <span class="math inline">m</span> is negative, it's similar.</li>
<li><span class="math inline">\Delta^{-1}</span>: Similar to <span class="math inline">\Delta</span> case.</li>
<li><span class="math inline">\sigma_1</span>: There are two cases. If the word end with <span class="math inline">\sigma_1</span>, or end with <span class="math inline">\sigma_2^b</span>, where <span class="math inline">b\geq 2</span>, then the two words are exactly the same until the end. Thus implies the fellow traveler property. If the word end with a single <span class="math inline">\sigma_2</span>, then the words are <span class="math inline">\Delta^mp\sigma_1^k\sigma_2</span> and <span class="math inline">\Delta^mp\sigma_1^k\sigma_2\sigma_1</span>. The second word in normal form is <span class="math inline">\Delta^{m+1}R(p\sigma_1^{k-1})</span>. Note the first word is <span class="math inline">\Delta^mp\sigma_1^{k-1} \cdot \sigma_1\sigma_2</span> We can use the fact that adding the <span class="math inline">\Delta</span> have fellow traveler property to prove this also have that property.</li>
<li><span class="math inline">\sigma_2</span>: Similar to <span class="math inline">\sigma_2</span> case.</li>
</ul>
<p>The fellow traveler property is true for each generator.</p>
<p>We now have the theorem</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p><span class="math inline">B_3</span> is automatic.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-07-11. </div>
    <div class="info">Tags: automatic group, braid group, BSU REU.</div>

</div>]]></description>
    <pubDate>Mon, 11 Jul 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-07-11-b-3-is-automatic-a-simple-proof.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Linear time algorithm for the word problem on <span class="math inline">B_3</span></title>
    <link>https://chaoxuprime.com/blog/posts/2011-07-05-linear-time-algorithm-for-the-word-problem-on-b-3.html</link>
    <description><![CDATA[<br />
<div>
<p>The word problem is solved if one can put <span class="math inline">w</span> in Garside normal form. The process is trivial in <span class="math inline">B_3</span> and can be done in linear time on a Turing machine. Remember <span class="math inline">\Delta = \sigma_1\sigma_2\sigma_1</span>.</p>
<ol type="1">
<li>Rewrite all generator with negative exponents into ones with positive exponents and a <span class="math inline">\Delta^{-1}</span>.</li>
<li>Move every <span class="math inline">\Delta^{-1}</span> to the beginning of the word. First locate the last <span class="math inline">\Delta^{-1}</span>, and move it forward using the relations <span class="math inline">\Delta^{2n+1}\sigma_i = \sigma_{3-i} \Delta^{2n+1}</span> and <span class="math inline">\Delta^{2n}\sigma_i = \sigma_i\Delta^{2n}</span>. Pick up other <span class="math inline">\Delta^{-1}</span>'s in between.</li>
<li>Move every <span class="math inline">\Delta</span> factor in the word to the beginning of the word. Read from the end of the word, move it forward using <span class="math inline">\Delta</span> relations, pick up other <span class="math inline">\Delta</span> on the way. Check if moving <span class="math inline">\Delta</span> generates another <span class="math inline">\Delta</span>. <span class="math inline">B_3</span> don't have <span class="math inline">\sigma_i\sigma_j = \sigma_j\sigma_i</span> relation, therefore if a new <span class="math inline">\Delta</span> is created from moving <span class="math inline">\Delta</span>'s around, it is a local event. To be precise, during this process, <span class="math inline">x\Delta^m y = x\Delta^{m+1} y&#39;</span> if and only if the first 3 letter in the current presentation of <span class="math inline">y</span> is <span class="math inline">\Delta</span>.</li>
</ol>
<p>A demonstration on a positive word. <span class="math display">\displaystyle \begin{aligned}
\sigma_2\sigma_1\sigma_1\sigma_2\sigma_1\sigma_1\sigma_1\sigma_1 &amp;= \sigma_2\sigma_1\sigma_1\sigma_2\sigma_1(\sigma_1\sigma_1\sigma_1)\\
&amp;= \sigma_2\sigma_1\sigma_1\sigma_2(\sigma_1\sigma_1\sigma_1)\sigma_1\\
&amp;= \sigma_2\sigma_1\sigma_1(\sigma_2\sigma_1\sigma_1)\sigma_1\sigma_1\\
&amp;= \sigma_2\sigma_1(\sigma_1\sigma_2\sigma_1)\sigma_1\sigma_1\sigma_1\\
&amp;= \sigma_2\sigma_1\Delta\sigma_1\sigma_1\sigma_1\\
&amp;= \sigma_2\sigma_1\Delta(\sigma_1\sigma_1\sigma_1)\\
&amp;= \sigma_2\Delta(\sigma_2\sigma_1\sigma_1)\sigma_1\\
&amp;= \Delta(\sigma_1\sigma_2\sigma_1)\sigma_1\sigma_1\\
&amp;= \Delta^2\sigma_1\sigma_1\\
&amp;= \Delta^2(\sigma_1\sigma_1\cdot 1)\\
&amp;= \Delta^2\sigma_1^2\\
\end{aligned}</span></p>
I wrote a <a href="https://gist.github.com/1066286">Haskell implementation of the algorithm</a>.
<script src="https://gist.github.com/1066286.js?file=word_problem_b3.hs"></script>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-07-05. </div>
    <div class="info">Tags: braid group, BSU REU, computational complexity.</div>

</div>]]></description>
    <pubDate>Tue, 05 Jul 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-07-05-linear-time-algorithm-for-the-word-problem-on-b-3.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Garside Normal Form and Summit Sets</title>
    <link>https://chaoxuprime.com/blog/posts/2011-07-05-garside-normal-form-and-summit-sets.html</link>
    <description><![CDATA[<br />
<div>
<p>Note: This is just some notes I organized after reading the survey on <a href="http://campillos.ucmerced.edu/~jboiser/boiserMSThesis.pdf">computational problems in the braid group by Jonathan Boiser</a>.</p>
<h1 id="the-garside-normal-form"><span class="header-section-number">1</span> The Garside Normal Form</h1>
<section class="theorem-environment Definition" id="Definition-1">
<span class="theorem-header"><span class="type">Definition</span><span class="index">1</span><span class="name">The Positive Braid Monoid</span></span>
<p>The positive braid monoid of <span class="math inline">n</span> strands is denoted as <span class="math inline">B_n^+</span>. Such that <span class="math inline">B_n^+\in B_n</span> and <span class="math inline">B_n^+</span> contain only word in the form <span class="math inline">\sigma_{a_1}\ldots\sigma_{a_l}</span>.</p>
</section>
<section class="theorem-environment Definition" id="Definition-2">
<span class="theorem-header"><span class="type">Definition</span><span class="index">2</span><span class="name">The order relation</span></span>
<ul>
<li><span class="math inline">a\leq b</span> if <span class="math inline">ac = b</span>, where <span class="math inline">a,b,c \in B_n^+</span>. <span class="math inline">a</span> is called the left divisor of <span class="math inline">b</span>.</li>
<li><span class="math inline">\gcd(a,b) = c</span>, if <span class="math inline">cw = a</span> and <span class="math inline">cv = b</span>, such that <span class="math inline">|c|</span> is maximized, where <span class="math inline">a,b,c,w,v\in B_n^+</span>. <span class="math inline">c</span> is called the greatest common divisor of <span class="math inline">a</span> and <span class="math inline">b</span>.</li>
</ul>
</section>
<section class="theorem-environment Definition" id="Definition-3">
<span class="theorem-header"><span class="type">Definition</span><span class="index">3</span><span class="name">The Fundamental Braid</span></span>
<p>The fundamental braid, or half-twist, on <span class="math inline">n</span> strands <span class="math display">\displaystyle 
\Delta_n = (\sigma_1\ldots \sigma_{n-1})(\sigma_1\ldots\sigma_{n-2})\ldots(\sigma_1\sigma_2)\sigma_1
</span>.</p>
<p><span class="math inline">\Delta</span> is used for <span class="math inline">\Delta_n</span> if <span class="math inline">n</span> is obvious from the context.</p>
</section>
<p><span class="math inline">\sigma_i\Delta = \Delta\sigma_{n-i}</span> and <span class="math inline">\sigma_i^{-1} = x_i\Delta^{-1}</span> for some positive word <span class="math inline">x_i</span> are two important theorems the reader should check. Define a function <span class="math inline">R</span>, such that <span class="math inline">w\Delta = \Delta R(w)</span> is true for all <span class="math inline">w\in B_n</span>.</p>
<section class="theorem-environment Definition" id="Definition-4">
<span class="theorem-header"><span class="type">Definition</span><span class="index">4</span><span class="name">The Garside Normal Form</span></span>
<p>The Garside normal form of a word <span class="math inline">w\in B_n</span> is <span class="math inline">w = \Delta_n^m p</span>. <span class="math inline">p\in B^+_n</span>, and <span class="math inline">\Delta</span> is not a factor of <span class="math inline">p</span>. We define <span class="math inline">\inf(w)=m</span>.</p>
</section>
<p>If <span class="math inline">w\in B^+_n</span>, find the largest <span class="math inline">k</span>, such that <span class="math inline">\Delta^k \leq w</span>, then <span class="math inline">w = \Delta^k p&#39;</span>, and it's a unique form.</p>
<p>If <span class="math inline">w\in B_n</span>, first rewrite every <span class="math inline">\sigma_i^{-k}</span> in <span class="math inline">w</span> by <span class="math inline">(x_i)^k\Delta^{-k}</span>, move all the <span class="math inline">\Delta</span> to the front, and we will have <span class="math inline">w = \Delta^{-n} p</span>, where <span class="math inline">p</span> is a positive word. Then <span class="math inline">p</span> must have a normal form, let it be <span class="math inline">\Delta^{m}q</span>. <span class="math inline">w = \Delta^{m-n}q</span>, and it is uniquely determined.</p>
<p>Note the length of the positive word <span class="math inline">p</span> in the garside normal form is a constant, because all equivalent elements in <span class="math inline">B^+_n</span> have the same length.</p>
<section class="theorem-environment Definition" id="Definition-5">
<span class="theorem-header"><span class="type">Definition</span><span class="index">5</span><span class="name">Simple elements</span></span>
<p>A positive braid <span class="math inline">p</span> is simple if <span class="math inline">p\in\mathcal{D} = \{x | x \leq \Delta\}</span>.</p>
</section>
<p>Note <span class="math inline">\mathcal{D}</span> generates the braid group.</p>
<section class="theorem-environment Definition" id="Definition-6">
<span class="theorem-header"><span class="type">Definition</span><span class="index">6</span></span>
<p><span class="math inline">w</span> has the Garside normal form <span class="math inline">\Delta^m p</span>, then we define the following functions. - The infimum, or the delta exponent, of <span class="math inline">w</span>, <span class="math inline">\inf(w) = m</span> - The index of <span class="math inline">w</span>, <span class="math inline">\lambda(w) = |p| + m|\Delta|</span>.</p>
</section>
<p>The index of <span class="math inline">w</span> is also <span class="math inline">h-g</span>, where <span class="math inline">h,g</span> are the number of positive and negative generators respectively. No matter how <span class="math inline">w</span> is presented, the index is a constant. This is obvious because all braid relations doesn't change the index.</p>
<h1 id="the-summit-set"><span class="header-section-number">2</span> The Summit Set</h1>
<p>Let <span class="math inline">[w]</span> be the conjugacy class of <span class="math inline">w</span>, in other words, <span class="math inline">w&#39;\in[w]</span> if and only if <span class="math inline">w = c^{-1}w&#39;c</span> for some <span class="math inline">c\in B_n</span>. One write <span class="math inline">w\sim w&#39;</span> if <span class="math inline">w&#39;\in[w]</span></p>
<p>How can one check if <span class="math inline">w\sim w&#39;</span>? This is the conjugacy problem. Note <span class="math inline">[w]</span> is not finite unless <span class="math inline">w=1</span>. Search through the entire set is impossible. The solution is similar to the word problem, it's also about finding a ``normal form'' for <span class="math inline">[w]</span>. There are special subsets of <span class="math inline">[w]</span>, such that there exist an algorithm with input <span class="math inline">w&#39;</span>. The algorithm output the subset if and only if <span class="math inline">w&#39;\in [w]</span>.</p>
<p>One of the first set with this property is the summit set.</p>
<p>Define <span class="math inline">\inf[w] = \sup \{\inf(x) | x \in [w]\}</span>.</p>
<section class="theorem-environment Definition" id="Definition-7">
<span class="theorem-header"><span class="type">Definition</span><span class="index">7</span><span class="name">The Summit Set</span></span>
<p>The summit set of <span class="math inline">w</span> is written as <span class="math inline">SS(w)</span>. <span class="math display">\displaystyle 
SS(w) = \{x | \inf(x) = \inf[w], x\in [w] \}
</span></p>
</section>
<p>The summit set exists if there is an upper bound on <span class="math inline">m</span>. Manipulate the index formula, we have <span class="math inline">m = \frac{\lambda(w) - |p|}{|\Delta|}</span>. <span class="math inline">m \leq \frac{\lambda(w)}{|\Delta|}</span>, therefore <span class="math inline">m</span> is bounded above.</p>
<p>The summit set of <span class="math inline">w</span> is finite, and the size is bounded by <span class="math inline">n^{\lambda(w) - |\Delta|\inf[w]}</span>. <span class="math inline">\inf[w] = \frac{\lambda(w) - |p|}{|\Delta|}</span>, or <span class="math inline">|p| = \lambda(w) - |\Delta|\inf[w]</span>. There are only finite many positive words with length <span class="math inline">|p|</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-8">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">8</span></span>
<p><span class="math inline">w\sim w&#39;</span>, <span class="math inline">w,w&#39;\in B_n</span>, then there exist a <span class="math inline">c\in B_n^+</span>, such that <span class="math inline">w=c^{-1}w&#39;c</span>.</p>
</section>
<p><span class="math inline">w=(\Delta^m p)^{-1} w&#39; (\Delta^m p)</span>, which means <span class="math inline">w=q^{-1} w&#39; q</span>, where <span class="math inline">q = \Delta R(p)</span> or <span class="math inline">p</span>, both are positive.</p>
<section class="theorem-environment Theorem" id="Theorem-9">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">9</span></span>
<p><span class="math inline">w\in B_n</span> and <span class="math inline">x\in B_n^+</span>. For <span class="math inline">a \in SS(w)</span>, if <span class="math inline">x^{-1}ax\in SS(w)</span>, then <span class="math inline">c^{-1}ac \in SS(w)</span>, where <span class="math inline">c=\gcd(x,\Delta)</span>.</p>
</section>
<p>The theorem implies that every word in the conjugacy class can be reached by repeat conjugation of simple elements.</p>
<section class="theorem-environment Theorem" id="Theorem-10">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">10</span></span>
<p>For <span class="math inline">w,w&#39;\in B_n</span>, <span class="math inline">w\sim w&#39;</span> if and only if <span class="math inline">SS(w) = SS(w&#39;)</span></p>
</section>
<h1 id="complexity"><span class="header-section-number">3</span> Complexity</h1>
<h2 id="complexity-of-the-word-problem"><span class="header-section-number">3.1</span> Complexity of the word problem</h2>
<p>To solve the word problem with Garside normal form, one can always put it in the <span class="math inline">\Delta^{-k}p</span> form in linear time. Then factor out the <span class="math inline">\Delta</span> divisors in <span class="math inline">p</span>, and test if the resulting word is 1.</p>
<p>Factoring out the divisors can be done in quadratic time with respect to the word length by using a refined version of the Garside normal form, Thurston's left greedy normal form.</p>
<h2 id="complexity-of-the-conjugacy-problem"><span class="header-section-number">3.2</span> Complexity of the conjugacy problem</h2>
<p>Given the theorems, one can devise the following algorithm to solve the conjugacy problem:</p>
<ol type="1">
<li>Input <span class="math inline">w</span> and <span class="math inline">w&#39;</span>, present them in Garside normal form.</li>
<li>Find <span class="math inline">SS(w)</span> and <span class="math inline">SS(w&#39;)</span>.</li>
<li>Test if <span class="math inline">SS(w) = SS(w&#39;)</span></li>
</ol>
<p>The algorithm to find <span class="math inline">SS(w)</span></p>
<ol type="1">
<li>conjugate the input <span class="math inline">w</span> with every simple element.</li>
<li>Pick the set of produced elements, such that the <span class="math inline">\Delta</span> exponent is the largest.</li>
<li>For each one of those elements, go though 1 again.</li>
<li>If the process doesn't produce more elements with larger <span class="math inline">\Delta</span> exponent, the summit set has been found.</li>
</ol>
<p>The main complexity depend on the size of <span class="math inline">SS(w)</span>. It is known <span class="math inline">SS(w)</span> could be exponential in <span class="math inline">l</span> and <span class="math inline">n</span>.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-07-05. </div>
    <div class="info">Tags: braid group, BSU REU.</div>

</div>]]></description>
    <pubDate>Tue, 05 Jul 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-07-05-garside-normal-form-and-summit-sets.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Word problem for braid group using a representation</title>
    <link>https://chaoxuprime.com/blog/posts/2011-06-23-word-problem-for-braid-group-using-a-representation.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">The word problem for braid groups</span></span>
<p><strong>Input:</strong> <span class="math inline">w</span> is a word of length <span class="math inline">l</span> from the presentation <span class="math inline">\langle \sigma_1,\sigma_2,\ldots,\sigma_{n-1} \mid \sigma_{i+1}\sigma_i\sigma_{i+1} = \sigma_i\sigma_{i+1}\sigma_i, \sigma_i\sigma_j = \sigma_j\sigma_i \rangle</span> where <span class="math inline">|i-j|\neq 1</span>.</p>
<p><strong>Output:</strong> Return <code>true</code> if <span class="math inline">w</span> is the identity, else return <code>false</code>.</p>
</section>
<p>The word problem for braid group was solved a long time ago with Artin combing. It requires one to express pure braid group <span class="math inline">P_n</span> as a semidirect product of free groups <span class="math inline">F_1,\ldots,F_{n-1}</span>. It is slow and quite difficult, at least I wasn't able to come up with an explicit algorithm for it.</p>
<p>Another way was to create a faithful homomorphism <span class="math inline">^*: B_n \to \mathop{\mathrm{Aut}}(F_n)</span>. This is what I implemented in Haskell.</p>
<p>If <span class="math inline">B_n \to \mathop{\mathrm{Aut}}(F_n)</span> is faithful and it sends <span class="math inline">w</span> to <span class="math inline">w^*</span>, then <span class="math inline">w</span> is <span class="math inline">I</span> iff <span class="math inline">w^*(a) = a</span> for every generator <span class="math inline">a</span> of <span class="math inline">F_n</span>.</p>
<p>In the <a href="http://campillos.ucmerced.edu/~jboiser/boiserMSThesis.pdf">a survey by Jonathan Boiser</a>, there is one explicate map. Defined as <span class="math display">\displaystyle 
\sigma_i^*(t_j) =
\begin{cases}
 t_j &amp; \text{if } j\neq i, i+1 \\
 t_{i+1} &amp; \text{if } j=i \\
 t_{i+1}t_it^{-1}_{i+1} &amp; \text{if } j=i+1\\
\end{cases}
</span></p>
<p>Where <span class="math inline">t_i</span> are generators of <span class="math inline">F_n</span>, and <span class="math inline">\sigma_i</span> are the generators of the braid group. The inverse can easily be found.</p>
<p>Using a recursive definition. Let any word of the form <span class="math inline">(\sigma_i w)^*</span> be <span class="math inline">\sigma_i^* \circ w^*</span>. The algorithm is obvious. Test if <span class="math inline">w^*(t_i) = t_i</span> for every generator in <span class="math inline">F_n</span> is applying a list of <span class="math inline">\sigma_i</span> to elements in <span class="math inline">F_n</span>.</p>
I wrote the program in Haskell, and <a href="https://gist.github.com/1041985">posted it on github</a>.
<script src="https://gist.github.com/1041985.js?file=word_problem_braid_group.hs"></script>
<p>The analysis: Given a word with length <span class="math inline">l</span> in <span class="math inline">B_n</span>, how long does it take to solve the problem with this algorithm? Each application of <span class="math inline">\sigma_i^*(u)</span> to some word <span class="math inline">u</span> takes <span class="math inline">O(|u|)</span> time. One then free reduce. <span class="math inline">\sigma_i</span> is applied <span class="math inline">l</span> times.</p>
<p>An application of <span class="math inline">\sigma_i^*</span> can potentially triple the length of the word. If one shows that it can only increase the length of the word by a constant term(given one started from a generator), then we have a <span class="math inline">O(l^2 n)</span> algorithm.</p>
<p>Braid groups are automatic. If this natural algorithm solves the problem in <span class="math inline">O(l^2 n)</span> time, it is not a surprise. However, it is likely not true. The running time is more likely to be <span class="math inline">O(c^l n)</span> for some constant <span class="math inline">c</span>. Although I can prove neither <span class="math inline">\sigma_i^*</span> and increase the length by a constant factor or by a constant. The best known algorithm in 2000 was provided by <a href="http://www.sciencedirect.com/science/article/pii/S0166864199000632">a paper of Hessam Hamidi-Tehrani</a>. It runs in <span class="math inline">O(l^2 n + l n \log n)</span> time, and was proved with advanced techniques.</p>
<p><strong>Update 06/24/2011</strong>: Siegel provided a example in <span class="math inline">B_3</span> where the algorithm run in exponential time. <span class="math inline">((\sigma_2\sigma_1^{-1})^n)^*(t_1)</span>.</p>
<p>If we define <span class="math inline">a_n,b_n,c_n</span> to be the amount of <span class="math inline">t_1,t_2,t_3</span> (include it's inverses) at step <span class="math inline">n</span>, ignoring the possibility of cancellation. We have the following recurrence relation.</p>
<p><span class="math display">\displaystyle \begin{aligned}
a_{n+1} &amp;= 2a_n + b_n\\
b_{n+1} &amp;= c_n\\
c_{n+1} &amp;= a_n+2c_n\\
\end{aligned}</span></p>
<p>One can show <span class="math inline">a_n+b_n+c_n = 2F_{2n+1}-1</span>. It is also true that cancellations are not possible.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-06-23. </div>
    <div class="info">Tags: braid group, BSU REU, group theory, Haskell.</div>

</div>]]></description>
    <pubDate>Thu, 23 Jun 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-06-23-word-problem-for-braid-group-using-a-representation.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Word problem for symmetric group is linear on RAM</title>
    <link>https://chaoxuprime.com/blog/posts/2011-06-21-word-problem-for-symmetric-group-is-linear-on-ram.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="linear-time-algorithm-for-symmetric-group"><span class="header-section-number">1</span> Linear time algorithm for symmetric group</h1>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">The word problem for symmetric groups</span></span>
<p><strong>Input:</strong> <span class="math inline">w</span> is a word of length <span class="math inline">l</span> from the presentation <span class="math inline">S_n = \langle x_1,x_2,\ldots,x_n \mid x_i^2 = 1, x_{i+1}x_ix_{i+1} = x_ix_{i+1}x_i, x_ix_j = x_jx_i \rangle</span> where <span class="math inline">|i-j|\neq 1</span>.</p>
<p><strong>Output:</strong> Return <code>true</code> if <span class="math inline">w</span> is the identity, else return <code>false</code>.</p>
</section>
<p>The representation was crucial for coming up with a linear time algorithm respect to <span class="math inline">n</span> and <span class="math inline">l</span>. This is not a word problem on one group, but on a set of group.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>The following is a <span class="math inline">O(n+l)</span> algorithm for the word problem for symmetric groups on RAM.</p>
<ol type="1">
<li>Produce an array <code>a</code> of size <span class="math inline">n</span>, Such that <code>a[i] = i</code>. (Array start with index 1)</li>
<li>Reading the word letter by letter. If one encounters <span class="math inline">x_i</span>, <code>swap(a[i],a[i+1])</code>.</li>
<li>Test if the <code>a[i] == i</code> for all <span class="math inline">i</span>. If true, return <code>true</code>, else return <code>false</code>.</li>
</ol>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>The algorithm takes <span class="math inline">O(n+l)</span> time is obvious. The correctness needs to be justified.</p>
<p><span class="math inline">x_i</span> can be represented as the transposition <span class="math inline">(i~i+1)</span>. Define <span class="math inline">(n~n+1) = (n~1)</span>.</p>
<p>Represent a element of the group as a permutation <span class="math inline">\pi</span> in the 2 line notation. wlog, assume <span class="math inline">\pi(j) = i</span> and <span class="math inline">\pi(k) = i+1</span>.</p>
<p><span class="math display">\displaystyle 
\begin{pmatrix} 1 &amp;  \cdots &amp;j &amp; \cdots &amp; k&amp; \cdots &amp; n \\ \pi(1) &amp;  \cdots &amp; i &amp; \cdots &amp; i+1 &amp; \cdots &amp; \pi(n)\end{pmatrix}(i~i+1) = 
\begin{pmatrix} 1 &amp; \cdots &amp;j &amp; \cdots &amp; k&amp; \cdots &amp; n \\ \pi(1) &amp; \cdots &amp; i+1 &amp; \cdots &amp; i &amp; \cdots &amp; \pi(n)\end{pmatrix}
</span></p>
<p>If we call <span class="math inline">j</span> the index of <span class="math inline">i</span> if <span class="math inline">\pi(j) = i</span>. Then each transposition is a swap of indices.</p>
<p>The value of <code>a[i]</code> in the algorithm stores the index of <span class="math inline">i</span>. Array <code>a</code> represent the identity iff <code>a[i] = i</code> for all <span class="math inline">i</span>.</p>
<p>This proves the the correctness of the algorithm.</p>
</section>
<p>The algorithm can be modified so it runs in <span class="math inline">O(l n!)</span> time for a Turing machine. For each fixed <span class="math inline">n</span>, a Turing machine <span class="math inline">M</span> can construct another Turing machine <span class="math inline">M_n</span>, such that it store the state of the array as the state of the Turing machine.</p>
<p>This proves every symmetric group is automatic. For any fixed <span class="math inline">S_n</span>, the Turing machine <span class="math inline">M_n</span> can solve the problem in <span class="math inline">O(l)</span> time without writing anything to the tape and can only move to the right, which is equivalent to a finite state automata.</p>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>Automatic is a property of a group, not a set of groups. That's why <span class="math inline">n</span> is ignored in the <span class="math inline">O(ln!)</span>, because it's fixed for each <span class="math inline">S_n</span>. I was confused for a while before I read a concrete definition.</p>
</section>
<h1 id="algorithms-on-reduce-the-word-to-normal-form"><span class="header-section-number">2</span> Algorithms on reduce the word to normal form</h1>
<p>The normal form of a word <span class="math inline">w\in S_n</span> is <span class="math inline">w = u_1u_2\ldots u_n</span>, such that <span class="math inline">u_i\in U_i</span>, and <span class="math inline">U_i = \{1, x_n, x_nx_{n-1}, \ldots, x_n\ldots x_1\}</span>.</p>
<p>One can construct a purely symbolic algorithm that apply only the group relations. We measure the time by the amount of group relations used.</p>
<p>Siegel proposed an <span class="math inline">O(l^2)</span> algorithm to solve this problem.</p>
<p>If there exist an algorithm <span class="math inline">A(w)</span> that write the word <span class="math inline">w</span> of length <span class="math inline">l</span> in normal form in <span class="math inline">O(f(l,n))</span> time., then one can always make it into an algorithm taking <span class="math inline">O(l f(n^2,n))</span> time.</p>
<p>Observe that <span class="math inline">w = w&#39;yz</span> where <span class="math inline">y</span> and <span class="math inline">z</span> are words in normal form, and the length of <span class="math inline">|z|</span> is maximized. <span class="math inline">A(w) =A(w&#39;A(yz))</span>. Here <span class="math inline">y</span> can be worst case, one single letter, it doesn't change the complexity. Let's introduce two algorithms. A' and A''.</p>
<p><span class="math inline">A&#39;(w)</span> first find the <span class="math inline">z</span> in the description, then returns the value of <span class="math inline">A&#39;&#39;(w&#39;,A(x_iz))</span>, where <span class="math inline">w = w&#39;x_iz</span>.</p>
<p>Recursively calculate <span class="math inline">A&#39;&#39;(w,z)</span> with the following definition. <span class="math inline">A&#39;&#39;(1,z) = z</span>. <span class="math inline">A&#39;&#39;(w,z) = A&#39;&#39;(w&#39;, A(x_iz))</span>, where <span class="math inline">w = w&#39;x_i</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p><span class="math inline">A(w) = A&#39;(w)</span> and runs in <span class="math inline">O(l f(n^2,n))</span> time.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><span class="math inline">A&#39;&#39;(w,z)</span> can ran at most <span class="math inline">l</span> times, each time it makes a call to <span class="math inline">A(w)</span>, contribute the factor <span class="math inline">O(f(n^2,n))</span>.</p>
</section>
<p>In particular, Siegel's algorithm can be modified to run in <span class="math inline">O(l n^4)</span> time.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-06-21. </div>
    <div class="info">Tags: BSU REU, computational complexity, group theory.</div>

</div>]]></description>
    <pubDate>Tue, 21 Jun 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-06-21-word-problem-for-symmetric-group-is-linear-on-ram.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>How long do you expect to live?</title>
    <link>https://chaoxuprime.com/blog/posts/2011-06-15-how-long-do-you-expect-to-live.html</link>
    <description><![CDATA[<br />
<div>
<p>While discussing conditional probability, someone said the following:</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>The expected life expectancy of some country is 70, and there exist people who die at every age before 70. What is the expected life expectancy for a 60 year old?</p>
</section>
<p>Most people would answer 10. However, he continuous:</p>
<blockquote>
<p>It could be 10, but for many distributions, it's likely more than that. You can convince yourself by thinking about the expected life expectancy for a 80 year old.</p>
</blockquote>
<p>The quote above would follow directly from the proof of the following theorem:</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>For any real random variable <span class="math inline">X</span>, if <span class="math inline">\Pr(X\geq a)&gt;0</span>, <span class="math inline">E[X|X\geq a] \geq E[X]</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">c = \Pr(X\leq a)</span> <span class="math display">\displaystyle \begin{aligned}
E[X] &amp;= \int_{-\infty}^\infty x \Pr(X=x) dx\\
 &amp;=\int_{-\infty}^a x \Pr(X=x) dx + \int_a^\infty x \Pr(X=x) dx\\
 &amp;=\int_{-\infty}^\infty x \Pr(X=x|X\leq a)\Pr(X\leq a) dx + \int_{-\infty}^\infty x \Pr(X=x|X\geq a)\Pr(X\geq a) dx\\
 &amp;=c\int_{-\infty}^\infty x \Pr(X=x|X\leq a) dx + (1-c)\int_{-\infty}^\infty x \Pr(X=x|X\geq a) dx \\
 &amp;=cE[X|X\leq a] + (1-c)E[X|X\geq a] \\
\end{aligned}</span></p>
<p>If <span class="math inline">a = \lambda b + (1-\lambda) c</span>, where <span class="math inline">\lambda \in [0,1]</span>, then <span class="math inline">a \leq \max(b,c)</span>. Because <span class="math inline">E[X|X\leq a]\leq a \leq E[X|X\geq a]</span>, <span class="math inline">E[X] \leq E[X|X\geq a]</span>.</p>
</section>
<p>In fact, one can easily modify the above proof and prove the next theorem:</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>For any real random variable <span class="math inline">X</span>, if <span class="math inline">x\geq y</span> and <span class="math inline">\Pr(X\geq x)&gt;0</span>, then <span class="math inline">E[X|X\geq x] \geq E[X|X\geq y]</span>.</p>
</section>
<p>A heuristics conclusion: The longer you lived, you expect to live longer.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-06-15. </div>
    <div class="info">Tags: probability.</div>

</div>]]></description>
    <pubDate>Wed, 15 Jun 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-06-15-how-long-do-you-expect-to-live.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Countably infinite groups such that every element has order 2 are isomorphic</title>
    <link>https://chaoxuprime.com/blog/posts/2011-06-11-countably-infinite-group-such-that-every-element-has-order-2-are-isomorphic.html</link>
    <description><![CDATA[<br />
<div>
<p>I once saw the following puzzle:</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a list of <span class="math inline">2n-1</span> non-negative integers. Every number except one appeared twice. The memory that contain the integers are read only. Can you use <span class="math inline">O(1)</span> additional space to find the integer that only appeared once?</p>
</section>
<p>The solution was the xor function.</p>
<p>If <span class="math inline">a_j</span> is the number that didn't appear twice, <span class="math display">\displaystyle 
\bigoplus_{i=1}^{2n-1} a_i = a_j
</span></p>
<p>The reason was because xor have the following property. <span class="math inline">a \oplus b = b \oplus a</span>, <span class="math inline">a \oplus a = 0</span> and <span class="math inline">0 \oplus a = a</span> for all <span class="math inline">a,b\geq 0</span>. One can see <span class="math inline">(\mathbb{N}, \oplus)</span> is a abelian group.</p>
<p>Is this the unique function to solve this problem?</p>
<p>In some way, yes. Here is a theorem.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>The countably infinite group <span class="math inline">G</span> such that <span class="math inline">g^2 = 1</span> for all <span class="math inline">g\in G</span> is <span class="math inline">(\mathbb{N}, \oplus)</span> up to isomorphism.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p><a href="http://math.stackexchange.com/a/17057/96">See the answer by Pete Clark</a>.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-06-11. </div>
    <div class="info">Tags: group theory, puzzle.</div>

</div>]]></description>
    <pubDate>Sat, 11 Jun 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-06-11-countably-infinite-group-such-that-every-element-has-order-2-are-isomorphic.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>A generalization of the art gallery theorem with reflection and a cool problem</title>
    <link>https://chaoxuprime.com/blog/posts/2011-06-06-a-generalization-of-the-art-gallery-theorem-with-reflection-and-a-cool-problem.html</link>
    <description><![CDATA[<br />
<div>
<p>When I was the TA for AMS 345(Computational Geometry) last year, I have encountered problems where I don't know if there exist a answer. Therefore I used those problem as a toy example of what a &quot;research&quot; could be like.</p>
<p>First I will demonstrate a theorem that generalize art gallery theorem. It's the first interesting theorem I discovered. :) I'm sure someone else have found it before.</p>
<p>The definition of guard, visibility, etc. are defined in the wiki for the <a href="http://en.wikipedia.org/wiki/Art_gallery_problem">art gallery problem</a>.</p>
<p>One want to generalize the notion of guarding a polygon. Instead of walls, the edges become mirrors. The light loses intensity every time it get reflected on the mirror. Therefore after <span class="math inline">k</span> reflections, it become indistinguishable to a guard.</p>
<section class="theorem-environment Definition" id="Definition-1">
<span class="theorem-header"><span class="type">Definition</span><span class="index">1</span><span class="name"><span class="math inline">k</span>-reflection visible</span></span>
<p>Given polygon <span class="math inline">P</span>. <span class="math inline">p,q\in P</span>. <span class="math inline">p</span> is called <em><span class="math inline">k</span>-reflection visible</em> to <span class="math inline">q</span> if and only if there is a ray of light from <span class="math inline">p</span> to <span class="math inline">q</span>, such that it reflects at most <span class="math inline">k</span> times on the boundary of the polygon. Each reflection follows the law of reflection. (angle of incidence = angle of reflection.)</p>
</section>
<section class="theorem-environment Definition" id="Definition-2">
<span class="theorem-header"><span class="type">Definition</span><span class="index">2</span><span class="name"><span class="math inline">k</span>-reflection guard</span></span>
<p>A <em><span class="math inline">k</span>-reflection guard</em> is a guard that can see all the points that are <span class="math inline">k</span>-reflection visible from himself.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>If <span class="math inline">G_k(n)</span> is the minimal number of <span class="math inline">k</span>-reflection guard required to guard any polygon of <span class="math inline">n</span> vertices. Then <span class="math inline">G_k(n)=\lfloor \frac{n}{3} \rfloor</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>By the art gallery theorem, we know <span class="math inline">G_0(n)\leq \lfloor \frac{n}{3} \rfloor</span>. <span class="math inline">G_k(n)\leq G_j(n)</span> if <span class="math inline">j\leq k</span>. Since a guards can only become stronger when they can see more reflections. <span class="math inline">G_k(n)\leq \lfloor \frac{n}{3} \rfloor</span></p>
<p>The lower bound can be proved with a Chvátal's comb with very thin teeth. A Chvátal's comb with 3 teeth is shown below.</p>
<figure>
<img src="/files/chvatals_comb.png" alt="Chvátal&#39;s comb" /><figcaption>Chvátal's comb</figcaption>
</figure>
<p>Since for each teeth, the result is symmetric. We only have to consider one teeth. Suppose we pick <span class="math inline">p</span> to be the teeth vertex. A ray can behave in 2 cases: Case 1: The ray escape the teeth after the first reflection, and bounce between the parallel lines for <span class="math inline">k-1</span> times. It's easy to see the furthest distance this ray can travel from the teeth is bounded by the angle of the teeth and the distance between the lines. One can always find a polygon, such that the distance between teeth is large enough, such that no visible region from case 1 can overlap.</p>
<p>Case 2: The ray went into the teeth after the first reflection. One can construct a teeth such that rays will bounce inside the teeth for at least <span class="math inline">k-1</span> times. If <span class="math inline">\alpha</span> is the angle of the teeth, the amount of times the ray hit the teeth is at least <span class="math inline">\frac{\pi}{2\alpha}</span> times. Convince yourself this is true by reflect entire teeth along it's edge repeatedly. The ray has to hit at least all the reflections lies between a <span class="math inline">\frac{\pi}{2}</span> sector. One can make <span class="math inline">\alpha</span> small enough, so <span class="math inline">\frac{\pi}{2\alpha}\geq k-1</span>. Thus all the rays in this case has to stay in the teeth, therefore it can't overlap with visible regions of other teeth.</p>
<figure>
<img src="/files/artgallery_proof.png" alt="proof" /><figcaption>proof</figcaption>
</figure>
<p>Each visible region is independent. There are <span class="math inline">\lfloor \frac{n}{3} \rfloor</span> visibility regions. This gives us the desired result <span class="math inline">\lfloor \frac{n}{3} \rfloor \leq G_k(n)\leq \lfloor \frac{n}{3} \rfloor</span>, <span class="math inline">G_k(n) = \lfloor \frac{n}{3} \rfloor</span>.</p>
</section>
<p>Just for fun. Here is another toy problem from last year's AMS 345 homework.</p>
<section class="theorem-environment Problem" id="Problem-4">
<span class="theorem-header"><span class="type">Problem</span><span class="index">4</span></span>
<p>Let <span class="math inline">P</span> be a simple polygon with <span class="math inline">n = 3k</span> vertices, for a positive integer <span class="math inline">k</span>. Starting with a vertex, color the vertices alternately around the polygon: red, blue, green, red, blue, green, etc. Find a counterexample to the following claim: There exist a monochromatic guard set.</p>
</section>
<p>Back then, the best known counterexample has 15 vertices(<span class="math inline">k=5</span>). Professor Mitchell asked if it was the smallest counterexample. I start to work on the following problem:</p>
<section class="theorem-environment Problem" id="Problem-5">
<span class="theorem-header"><span class="type">Problem</span><span class="index">5</span></span>
<p>Find the smallest counterexample, and prove it's the smallest.</p>
</section>
<p>A counterexample with <span class="math inline">k=3</span>. The colored region are the area can't be seen by vertices of that color.</p>
<figure>
<img src="/files/cg_counterexample.png" alt="counterexample" /><figcaption>counterexample</figcaption>
</figure>
<p>It is indeed the smallest possible.</p>
<section class="theorem-environment Lemma" id="Lemma-6">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">6</span></span>
<p>Any 2 vertices on a quadrilateral can guard the quadrilateral.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>There are only 2 cases, draw them and convince yourself.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-7">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p>There exist no counterexample for <span class="math inline">k=2</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Suppose there exist a polygon <span class="math inline">P</span> such that <span class="math inline">k=2</span> and it is a counterexample to the original conjecture. The vertices of <span class="math inline">P</span> are <span class="math inline">RGBrgb</span>.</p>
<p>Any triangulation of the polygon result 4 triangles. Since no color exist in all triangles(else that color guards <span class="math inline">P</span>), there is a triangle composed of only 2 colors. Therefore one side of that triangle have the same colored end points. It must be a diagonal because no edge of <span class="math inline">P</span> have the same colored end points.</p>
<p>wlog, let the diagonal be <span class="math inline">Rr</span>. Then <span class="math inline">P</span> is partitioned to 2 quadrilaterals <span class="math inline">RGBr</span> and <span class="math inline">rgbR</span>. Using the lemma, we see <span class="math inline">R</span> and <span class="math inline">r</span> can guard both quadrilaterals. It implies <span class="math inline">R</span> and <span class="math inline">r</span> guards <span class="math inline">P</span>. A contradiction.</p>
</section>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-06-06. </div>
    <div class="info">Tags: computational geometry, discrete geometry.</div>

</div>]]></description>
    <pubDate>Mon, 06 Jun 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-06-06-a-generalization-of-the-art-gallery-theorem-with-reflection-and-a-cool-problem.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>A riddle, guess the word from the sum</title>
    <link>https://chaoxuprime.com/blog/posts/2011-06-01-a-riddle-guess-the-word-from-the-sum.html</link>
    <description><![CDATA[<br />
<div>
<p>What is <span class="math display">\displaystyle 
\left(a\sum_{n=2}^\infty w^n\right)!
</span></p>
<p>If you can't figure it out, here are 2 hints.</p>
<p>Hint 1: What is <span class="math inline">\sum_{V\subseteq U} \dim(V)</span>? Where <span class="math inline">U</span> is a vector space of dishes for a yum cha.</p>
<p>Hint 2: On the internet, you will see the following variation. <span class="math display">\displaystyle 
\left(a\sum_{n=2}^\infty w^n\right)!!!!
</span></p>
<p>Answer: &quot;awesome!&quot; and the answer for the hint is &quot;dim sum&quot;</p>
<p>Here is an extra riddle for fun. <span class="math display">\displaystyle 
S = \set{&quot;p&quot;,&quot;e&quot;,&quot;r&quot;,&quot;s&quot;,&quot;o&quot;,&quot;n&quot;}
</span> What is <span class="math inline">\frac{1}{6} \sum_{s\in S} s</span>? A mean person...</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-06-01. </div>
    <div class="info">Tags: math, puzzle, joke.</div>

</div>]]></description>
    <pubDate>Wed, 01 Jun 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-06-01-a-riddle-guess-the-word-from-the-sum.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Simple keystroke counter</title>
    <link>https://chaoxuprime.com/blog/posts/2011-03-05-simple-keystroke-counter.html</link>
    <description><![CDATA[<br />
<div>
I wrote this script to count the amount of keystrokes I do on my computer. All updates will be posted <a href="https://gist.github.com/856198">here</a>.
<script src="https://gist.github.com/856198.js?file=keycounter.py"></script>
<p>It's simple. So simple it's have some bugs. For example, if you keep holding a key, it will be counted repeatedly.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2011-03-05. </div>
    <div class="info">Tags: python, tools.</div>

</div>]]></description>
    <pubDate>Sat, 05 Mar 2011 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2011-03-05-simple-keystroke-counter.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Find the square root of an integer with trigonometry and Lagrange's four-square theorem</title>
    <link>https://chaoxuprime.com/blog/posts/2010-11-07-find-the-square-root-of-an-integer-with-trigonometry-and-lagrange-s-four-square-theorem.html</link>
    <description><![CDATA[<br />
<div>
<p>My friend was solving the following problem during a interview for Citigroup's IT department.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Find the square root of a integer n, without using the built in sqrt function. (The range of the result was not specified, I assume it's double)</p>
</section>
<p>This is a common interview question.</p>
<p>There are <a href="http://en.wikipedia.org/wiki/Methods_of_computing_square_roots">many ways to do it</a>. I want to come up with a way no one else would think of, something that could amaze the interviewer. I mean, she might interviewed enough people to get bored with the standard answers.</p>
<p>I present the following highly inefficient but somewhat creative solution. <a href="https://github.com/chaoxu/mgccl-haskell/blob/master/random/sqrtOfInteger.hs">The code is here</a>.</p>
<p>How does it work?</p>
<p>We know <span class="math inline">n</span> is an integer. By <a href="http://en.wikipedia.org/wiki/Lagrange&#39;s_four-square_theorem">Lagrange's four-square theorem</a>, <span class="math inline">n=a^2+b^2+c^2+d^2</span> for integer <span class="math inline">a,b,c,d</span>. <span class="math inline">\sqrt{n} = \sqrt{a^2+b^2+c^2+d^2}</span>. Thus <span class="math inline">\sqrt{n}</span> is the magnitude of the vector <span class="math inline">[a,b,c,d]</span>. <span class="math inline">a,b,c,d</span> can be calculated by brute force search(therefore runs in <span class="math inline">O(n^2)</span> time).</p>
<p>Note a simple improvement of the naive algorithm can reduce the computation time to <span class="math inline">O(n^\frac{3}{2} \log n)</span> by doing a binary search for the last square.</p>
<p><a href="http://onlinelibrary.wiley.com/doi/10.1002/cpa.3160390713/abstract">A much smarter randomized algorithm</a> by Michael O. Rabin and Jeffrey Shallit have a running time of <span class="math inline">O(\log^2 n)</span>.</p>
<p>A recursive algorithm using the following relation can find the magnitude of any vector(assume <span class="math inline">a_i\neq 0</span>) <span class="math inline">|[a_0,...,a_{n-1},a_n]| = \frac{a_n}{\sin(\tan^{-1}(\frac{a_n}{|[a_0,...,a_{n-1}]|}))}</span> It's easy to see, this breaks a <span class="math inline">n</span>-dimension vector into orthogonal vectors of <span class="math inline">n-1</span>-dimensions and <span class="math inline">1</span>-dimension. We get a right triangle. Trigonometry comes in handy.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2010-11-07. </div>
    <div class="info">Tags: math.</div>

</div>]]></description>
    <pubDate>Sun, 07 Nov 2010 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2010-11-07-find-the-square-root-of-an-integer-with-trigonometry-and-lagrange-s-four-square-theorem.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>

    </channel>
</rss>
