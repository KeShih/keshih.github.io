<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>The Art Gallery Guardian</title>
        <link>https://chaoxuprime.com/blog</link>
        <description><![CDATA[Mostly notes on algorithms]]></description>
        <atom:link href="https://chaoxuprime.com/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 21 Jan 2019 00:00:00 UT</lastBuildDate>
        <item>
    <title>The high-degree low-degree technique and arboricity</title>
    <link>https://chaoxuprime.com/blog/posts/2019-01-21-high-degree-low-degree-technique.html</link>
    <description><![CDATA[<br />
<div>
<p>In this piece we demonstrate the high-degree low-degree technique in graphs. Often, we obtain running times that depends on the individual degrees of the vertices. If the graph has only low degree vertices, then a faster algorithm exists. For graph with only large degrees, then it is dense, and can often be handled in another way.</p>
<p>We will also use the information of <a href="https://en.wikipedia.org/wiki/Arboricity">arboricity</a>. Mainly, there are a few useful statements.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>For a graph <span class="math inline">G=(V,E)</span> with arboricity <span class="math inline">\alpha</span>, we have <span class="math display">\displaystyle 
    \sum_{uv\in E} \min(\deg(u),\deg(v)) \leq 2\alpha m
</span></p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>If the arboricity of a graph is <span class="math inline">\alpha</span>, then there exists a induced subgraph with minimum degree at least <span class="math inline">\alpha</span>.</p>
</section>
<p>Often, using the arboricity, we can obtain the same complexity algorithm without high-degree low-degree technique. Note the arboricity is <span class="math inline">O(\sqrt{m})</span>. The application of arboricity are from <span class="citation" data-cites="ChibaN85">[<a href="#ref-ChibaN85">1</a>]</span>.</p>
<p>Some of the algorithms described can be speedup by using matrix multiplication, or faster combinatorial boolean matrix multiplication. We avoid them for simplicity of exposition.</p>
<h1 id="dominating-set-with-few-edges"><span class="header-section-number">1</span> Dominating set with few edges</h1>
<p>The set cover problem, given <span class="math inline">\mathcal{S} = \set{S_1,\ldots,S_n}</span> are <span class="math inline">n</span> set contains a total of <span class="math inline">m</span> elements. <span class="math inline">U=\bigcup_{S\in \mathcal{S}} S</span> is the universe, with size <span class="math inline">u</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>There is a probability distribution <span class="math inline">D</span> over <span class="math inline">\mathcal{S}</span>, such that for each <span class="math inline">u</span>, the probability a random set <span class="math inline">S</span> covers <span class="math inline">u</span> is at least <span class="math inline">\e</span>. There exists a set cover of <span class="math inline">\ceil{\frac{\log u}{\e}}</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>There exists a set that covers at least <span class="math inline">\e |U&#39;|</span> for any <span class="math inline">U&#39; \subset U</span>. Therefore each greedy iteration decrease the size of uncovered universe by an <span class="math inline">\e</span> fraction. So there can be at most <span class="math inline">t</span> iterations, where <span class="math inline">(1-\e)^t&lt;1</span>. One can show <span class="math inline">\ceil{\frac{\log u}{\e}}</span> suffices.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-4">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">4</span></span>
<p>There is a dominating set incident to <span class="math inline">O(n\sqrt{n\log n})</span> edges.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Fix a <span class="math inline">\delta</span>. We repeatedly removing vertices with degree no more than <span class="math inline">\delta</span> from the graph, and add it into a set <span class="math inline">D</span>. The total degree of <span class="math inline">D</span> is at most <span class="math inline">n\delta</span>. Now the remaining vertices has degree at least <span class="math inline">\delta</span>. Using the set cover theorem, and let the distribution to be the uniform distribution. If all elements are covered at least by <span class="math inline">\e</span> fraction of the set, then we obtain a set cover of size <span class="math inline">O(\frac{\log u}{\e})</span>. Now, let the sets <span class="math inline">N(v)</span> for each <span class="math inline">v</span>. Since degree is bounded by at most <span class="math inline">n</span>, we can obtain a dominating set of size <span class="math inline">O(\frac{n\log n}{e})</span>. We set <span class="math inline">\e=\delta/n</span>. Since the degree of each vertex is at least <span class="math inline">\delta</span>, then there is a covering of <span class="math inline">O(\frac{n^2\log n}{\delta})</span>. Add the vertices induces this set cover to <span class="math inline">D</span>. <span class="math inline">D</span> is a dominating set, and its size is <span class="math inline">O(n\delta +\frac{n^2\log n}{\delta})</span>, set <span class="math inline">\delta=\sqrt{n\log n}</span> and we obtain the desired result.</p>
</section>
<p>One can show the above result is almost optimal, as there exists graphs where every dominating set incidents <span class="math inline">\Omega(n^{3/2})</span> edges. The same bound holds for weakly connected dominating set, that is a dominating set <span class="math inline">D</span> such that the edges incident to <span class="math inline">D</span> forms a connected graph. The stronger modification of this result was used in deciding the <span class="math inline">4</span>-connectivity of a matroid <span class="citation" data-cites="Rajan87">[<a href="#ref-Rajan87">2</a>]</span>.</p>
<h1 id="finding-small-subgraphs"><span class="header-section-number">2</span> Finding small subgraphs</h1>
<h2 id="finding-a-triangle"><span class="header-section-number">2.1</span> Finding a triangle</h2>
<p>A <em>triangle</em> is <span class="math inline">3</span> vertices pairwise adjacent to each other, another name for <span class="math inline">K_3</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-5">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">5</span></span>
<p>There is a <span class="math inline">O(m\Delta)</span> time algorithm to decide if the graph has a triangle, where <span class="math inline">\Delta</span> is the maximum degree.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Indeed, for each vertex <span class="math inline">v</span>, we consider its neighbors, see if any is adjacent to each other. We then delete <span class="math inline">v</span>. The algorithm takes <span class="math inline">O(\sum_{v} \deg^2(v)) = O(m\Delta)</span> time.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-6">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">6</span></span>
<p>There is a <span class="math inline">O(n^3)</span> time algorithm to decide if the graph has a triangle.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>The naive algorithm, for each <span class="math inline">3</span> vertices, we decide if it forms a triangle.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-7">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p>There is a <span class="math inline">O(m^{3/2})</span> time algorithm to decide if the graph has a triangle.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">t</span> be a parameter we will find later. Apply the above algorithm by picking the vertex with the smallest degree, until the next vertex has degree at least <span class="math inline">t</span>. It will use at most <span class="math inline">O(mt)</span> time. Now, for the remaining graph, it is clear the maximum degree is at least <span class="math inline">t</span>. Note, there can be at most <span class="math inline">n/t</span> vertices. We use the <span class="math inline">O(n^3)</span> time algorithm. The final running time is <span class="math inline">O(mt+(m/t)^3)</span>. Set <span class="math inline">t=\sqrt{m}</span> and we are done.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span><span class="name">Alternative</span></span>
<p>We modify the algorithm a little. For each vertex <span class="math inline">v</span>, we consider its neighbor <span class="math inline">u</span>, and check if <span class="math inline">u</span> has a neighbor that is in <span class="math inline">v</span>. Then we delete <span class="math inline">v</span>, and move on to next vertex. The running time become <span class="math inline">\sum_{v\in V} (\deg(v)+\sum_{u\in N(v)} \deg(u))</span>. Now, assume we pick vertices by the <em>largest</em> to <em>smallest</em> in term of degrees. We rearrange the sum and obtain <span class="math inline">\sum_{v\in V} (\deg(v)+\sum_{u\in N(v)} \deg(u)) = \sum_{v\in V} \deg(v) + 2 \sum_{uv\in E} \min(\deg(u),\deg(v)) = O(\alpha m)</span>. But <span class="math inline">\alpha\leq \sqrt{m}</span>, therefore we have the running time <span class="math inline">O(m^{3/2})</span>.</p>
</section>
<h2 id="finding-a-k_2ell-in-bipartite-graphs"><span class="header-section-number">2.2</span> Finding a <span class="math inline">K_{2,\ell}</span> in bipartite graphs</h2>
<p>This section we use technique that follows from <span class="citation" data-cites="AlonYZ97">[<a href="#ref-AlonYZ97">3</a>]</span>, which solved the special case <span class="math inline">K_{2,2}</span>. For two vertices <span class="math inline">u,v\in A</span>, decide if there is a intersection of the neighborhood of size at least <span class="math inline">\ell</span>. The claim is using the same argument as the triangle case with arboricity. Of course one need to be careful with designing the algorithm. However, the following would not be difficult to obtain.</p>
<section class="theorem-environment Theorem" id="Theorem-8">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">8</span></span>
<p>One can check if there exists a <span class="math inline">K_{2,\ell}</span> in the bipartite graph <span class="math inline">G=(A,B,E)</span> in <span class="math inline">O(\alpha m)</span> time.</p>
</section>
<p>Again, we directly obtain <span class="math inline">O(m^{3/2})</span> running time. However, we show something better using stronger theorems.</p>
<section class="theorem-environment Theorem" id="Theorem-9">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">9</span></span>
<p>One can check if there exists a <span class="math inline">K_{2,\ell}</span> in the bipartite graph <span class="math inline">G=(A,B,E)</span> in <span class="math inline">O(\ell n^2)</span> time.</p>
</section>
<p>Now, we combine the two algorithms. It requires a theorem in extremal graph theory can be found in <span class="citation" data-cites="Furedi96">[<a href="#ref-Furedi96">4</a>]</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-10">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">10</span><span class="name"><span class="math inline">K_{2,\ell}</span>-free theorem</span></span>
<p>There exists a constant <span class="math inline">c</span>, such that each <span class="math inline">n</span> vertex graph with <span class="math inline">c n^{3/2} \ell^{1/2}</span> edges contains a <span class="math inline">K_{2,\ell}</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-11">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">11</span></span>
<p>There is a <span class="math inline">O(\ell^{1/3}m^{4/3})</span> time algorithm to find a <span class="math inline">K_{2,\ell}</span> in the graph.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>If the arboricity is <span class="math inline">t</span>. We use the first algorithm and we get running time <span class="math inline">O(t m)</span>. Otherwise, we know there is a subgraph with minimum degree at least <span class="math inline">t</span>. The subgraph can be found by repeatedly deleting vertices of minimum degree. The subgraph <span class="math inline">G&#39;</span> with the previous property has <span class="math inline">n&#39;\leq n</span> vertices and <span class="math inline">m&#39;\leq n&#39;t</span> edges. One can see <span class="math inline">n&#39;\leq m&#39;/t\leq m/t</span>. If <span class="math inline">cn&#39;^{3/2}\ell^{1/2}\leq m&#39; \leq n&#39;t</span>, then we know there exists a <span class="math inline">K_{2,\ell}</span> in <span class="math inline">G&#39;</span> by the previous theorem, and we can apply the <span class="math inline">O(\ell n^2)</span> time algorithm in the subgraph to find the <span class="math inline">K_{2,\ell}</span>. The total running time is therefore <span class="math inline">O(tm + \ell n&#39;^2) = O(tm+\ell (m/t)^2)</span>. We set <span class="math inline">t=c^{3/2} (\ell m)^{1/3}</span>. One can check after lot of algebra, it make sure the condition <span class="math inline">cn&#39;^{3/2}\ell^{1/2}\leq n&#39;t</span> is satisfied. The algorithm takes <span class="math inline">O(\ell^{1/3}m^{4/3})</span> time.</p>
</section>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-ChibaN85">
<p>[1] N. Chiba, T. Nishizeki, <strong>Arboricity and Subgraph Listing Algorithms</strong>, SIAM Journal on Computing. 14 (1985) 210–223 <a href="https://doi.org/10.1137/0214017">10.1137/0214017</a>.</p>
</div>
<div id="ref-Rajan87">
<p>[2] A. Rajan, Algorithmic applications of connectivity and related topics in matroid theory, PhD thesis, Northwestern University, 1987.</p>
</div>
<div id="ref-AlonYZ97">
<p>[3] N. Alon, R. Yuster, U. Zwick, <strong>Finding and counting given length cycles</strong>, Algorithmica. 17 (1997) 209–223 <a href="https://doi.org/10.1007/BF02523189">10.1007/BF02523189</a>.</p>
</div>
<div id="ref-Furedi96">
<p>[4] Z. Füredi, <strong>New asymptotics for bipartite turán numbers</strong>, Journal of Combinatorial Theory, Series A. 75 (1996) 141–144 <a href="https://doi.org/https://doi.org/10.1006/jcta.1996.0067">https://doi.org/10.1006/jcta.1996.0067</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-21. </div>
    <div class="info">Tags: algorithm, graph.</div>

</div>]]></description>
    <pubDate>Mon, 21 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2019-01-21-high-degree-low-degree-technique.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Lights out game on a grid</title>
    <link>https://chaoxuprime.com/blog/posts/2019-01-12-lights-out-game.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Let <span class="math inline">G</span> be a graph, let <span class="math inline">A</span> be the adjacency matrix of <span class="math inline">G</span>. Solve the equation <span class="math inline">Ax=b</span> in <span class="math inline">\F_2</span>.</p>
</section>
<p>The problem is equivalent to the <a href="https://en.wikipedia.org/wiki/Lights_Out_%28game%29">lights out game</a>. Each vertex has state <span class="math inline">0</span> or <span class="math inline">1</span>. Activate a vertex flips the state of itself and all its neighbors. Find a set of activations that turns all state into <span class="math inline">0</span>. Originally I thought this problem can be solved in <span class="math inline">O(n^{\omega/2})</span> when <span class="math inline">G</span> is planar graph on <span class="math inline">n</span> vertices by <a href="https://en.wikipedia.org/wiki/Nested_dissection">nested dissection</a>. However, only recently I found out the matrix must be non-singular. Therefore nested dissection does not apply.</p>
<p>Recently I saw an algorithm that shows if the graph is a <span class="math inline">n\times n</span> grid, then it can be solved in <span class="math inline">O(n^3)</span> time. The solution in Chinese and can be seen <a href="https://zhuanlan.zhihu.com/p/53646257">here</a>.</p>
<p>Given a <span class="math inline">n\times n</span> grid graph. Let <span class="math inline">v_{i,j}</span> be the node on the <span class="math inline">i</span>th row and <span class="math inline">j</span>th column. Let <span class="math inline">b_{i,j}</span> be the state of the vertex <span class="math inline">v_{i,j}</span>. The state is in <span class="math inline">\F_2</span> If we activates a node, the state of the node and its neighbors change by <span class="math inline">1</span>. The set of activated node is called the activation set.</p>
<p>We are interested in finding an activation set <span class="math inline">S</span>, such the state of all nodes after activate <span class="math inline">S</span> is <span class="math inline">0</span>.</p>
<p>Let <span class="math inline">S</span> be the activation set, and <span class="math inline">S_1</span> to be the activation set of the first row.</p>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p><span class="math inline">S_1</span> uniquely determines <span class="math inline">S</span>. Moreover, One can compute <span class="math inline">S</span> from <span class="math inline">S_1</span> in <span class="math inline">O(n^2)</span> time.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Indeed, consider apply activation to the nodes in <span class="math inline">S_1</span>. Consider any vertex in row <span class="math inline">1</span>. If it <span class="math inline">0</span>, then the remaining neighbor (on the second row) cannot be activated. If it is <span class="math inline">1</span>, then the remaining neighbor has to be activated.</p>
</section>
<p>Let <span class="math inline">D[i,j]</span> indicates if we activate <span class="math inline">v_{i,j}</span> or not. We create formal variables <span class="math inline">Z=\set{z_1,\ldots,z_n}</span>. Here <span class="math inline">z_i</span> is an indicator variable that represents if <span class="math inline">v_{1,i}</span> is activated or not. The base case <span class="math inline">D[1,j] = z_j</span>. The observation shows that for each <span class="math inline">i</span> and <span class="math inline">j</span>, <span class="math inline">D[i+1,j] = 1 + D[i,j-1]+D[i,j]+D[i,j+1]+D[i-1,j]+b_{i,j}</span>. We can express <span class="math inline">D[i,j]</span> as a sum of elements in <span class="math inline">Z</span> and a constant, and we are summing a constant number of previous states. So it has size <span class="math inline">O(n)</span>. We can compute the expression of <span class="math inline">D[i,j]</span> in <span class="math inline">O(n)</span> time. So computing all <span class="math inline">D[i,j]</span> for <span class="math inline">i\geq 2</span> takes <span class="math inline">O(n^3)</span> time.</p>
<p>We are interested in <span class="math inline">D[n,1],\ldots,D[n,n]</span>. We can see it is of the following form.</p>
<p><span class="math display">\displaystyle 
\begin{aligned}
D[n,1] &amp;= c_{1,1} z_1+\ldots +c_{1,n} z_{n} + u_{1}\\
D[n,2] &amp;= c_{2,1} z_1+\ldots +c_{2,n} z_{n} + u_{2}\\
 \vdots &amp;\qquad  \vdots\\
D[n,n] &amp;= c_{m,1} z_1+\ldots + c_{m,n} z_n + u_{n}
\end{aligned}
</span></p>
<p>We solve the equation <span class="math inline">Cz=u</span>. Note here <span class="math inline">C</span> is just a <span class="math inline">n\times n</span> matrix. We finds <span class="math inline">z_1,\ldots,z_n</span>. So now we have found the activation set restricted on the first row. We can use it to find the entire activation set.</p>
<p>The total running time is <span class="math inline">O(n^3)</span>. Building the table <span class="math inline">D</span> and solving <span class="math inline">Cz=u</span>. One can generalize this a bit further. We can obtain <span class="math inline">O(m^2n)</span> running time for a <span class="math inline">m\times n</span> grid, where <span class="math inline">m\leq n</span>. Also, there is no reason we have to work in <span class="math inline">\F_2</span>, any arbitrary field is fine.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>Let <span class="math inline">G</span> be a <span class="math inline">m\times n</span> grid and <span class="math inline">A</span> is a matrix where the non-zero entires are precisely the position of <span class="math inline">1</span>s in the adjacency matrix of <span class="math inline">A</span>. Finding <span class="math inline">Ax=b</span> can be done in <span class="math inline">O(m^2n)</span> time.</p>
</section>
<p>I did not think too much into it, but maybe it works for all integral domains too. Interestingly, this algorithm is so special, that we have no idea how to extend it to other graphs. Maybe it works for directed graph, maybe it works for subgraph of the grid graphs.</p>
<p>It would be really interesting to see an algorithm with running time <span class="math inline">O(n^{3/2})</span> for a planar graph of <span class="math inline">n</span> vertices.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2019-01-12. </div>
    <div class="info">Tags: algorithm, algebra.</div>

</div>]]></description>
    <pubDate>Sat, 12 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2019-01-12-lights-out-game.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Strings with hamming distance exactly <span class="math inline">1</span></title>
    <link>https://chaoxuprime.com/blog/posts/2018-12-23-strings-with-hamming-distance-exactly-1.html</link>
    <description><![CDATA[<br />
<div>
<p><a href="http://darktef.github.io/">Lin Yang</a> asked me about the complexity for the following problem, which is the day 2 part 2 of the <a href="https://adventofcode.com/2018">advent of code 2018</a>. It is an elegant programming exercise, and also a clever algorithmic exercise. The problem can be summarized below.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a set <span class="math inline">W</span> of <span class="math inline">n</span> length <span class="math inline">m</span> strings. Decide if there are two of them that differs at exactly one position.</p>
</section>
<p>In other words, we want to find two strings in <span class="math inline">W</span> with <a href="https://en.wikipedia.org/wiki/Hamming_distance">hamming distance</a> <span class="math inline">1</span>.</p>
<p>The naive algorithm would have running time <span class="math inline">O(n^2m)</span>. The complexity of the problem have gathered a lot of attention a while ago, for example a <a href="https://dev.to/conectado/advent-of-code-day-2-part-2-complexity-556l">post in dev.to</a>, and <a href="https://www.reddit.com/r/adventofcode/comments/a2damm/2018_day2_part_2_a_linear_time_solution/">on reddit</a>. Some of them had a running time of <span class="math inline">O(nm^2)</span> instead. Some require hashing to get the <em>expected</em> running time of <span class="math inline">O(mn)</span>. Here we are interested in an algorithm with <em>worst case</em> <span class="math inline">O(mn)</span> time.</p>
<h1 id="an-omn-time-algorithm"><span class="header-section-number">1</span> An <span class="math inline">O(mn)</span> time algorithm</h1>
<p>First, we define some equivalent classes on the strings in <span class="math inline">W</span>.</p>
<ol type="1">
<li><span class="math inline">x\equiv^i y</span>, if <span class="math inline">x[1..i-1]=y[1..i-1]</span>. Namely, if the first <span class="math inline">i-1</span> elements of <span class="math inline">x</span> and <span class="math inline">y</span> match.</li>
<li><span class="math inline">x\equiv_i y</span> if <span class="math inline">x[i+1..m]=y[i+1..m]</span>. Namely, if the last <span class="math inline">m-i+1</span> elements of <span class="math inline">x</span> and <span class="math inline">y</span> match.</li>
</ol>
<p>The algorithm uses the following idea. For each <span class="math inline">i</span>, decide if there are any strings <span class="math inline">x</span> and <span class="math inline">y</span> such that differs in precisely position <span class="math inline">i</span>.</p>
<section class="theorem-environment Lemma" id="Lemma-2">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">2</span></span>
<p>For distinct <span class="math inline">x</span> and <span class="math inline">y</span>, they differ only in position <span class="math inline">i</span> if and only if <span class="math inline">x\equiv^i y</span> and <span class="math inline">x\equiv_i y</span>.</p>
</section>
<p>Let <span class="math inline">\mathcal{P}_i</span> and <span class="math inline">\mathcal{S}_i</span> be the collection of equivalent classes of <span class="math inline">\equiv^i</span> and <span class="math inline">\equiv_i</span>, respectively. We show a result related to the meet of partitions.</p>
<section class="theorem-environment Lemma" id="Lemma-3">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">3</span></span>
<p>Let <span class="math inline">\mathcal{A}</span> and <span class="math inline">\mathcal{B}</span> be partitions of <span class="math inline">[n]</span>. There is an <span class="math inline">O(n)</span> time algorithm to test find the sets in <span class="math inline">\set{ A\cap B | A\in \mathcal{A}, B\in \mathcal{B}}</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">\mathcal{A}=\set{A_1,\ldots,A_k}</span> and <span class="math inline">\mathcal{B} = \set{B_1,\ldots,B_\ell}</span>. We define <span class="math inline">I_i = (a,b)</span> such that <span class="math inline">i\in A_a</span> and <span class="math inline">i\in B_b</span>. Then we know <span class="math inline">i</span> is in <span class="math inline">A_a\cap B_b</span> if <span class="math inline">I_i=(a,b)</span>. Hence we are interested in find the largest set of elements such <span class="math inline">S</span> such that for <span class="math inline">i,j\in S</span>, <span class="math inline">I_i=I_j</span>. The simplified problem can be solved in <span class="math inline">O(n)</span> time. Indeed, the pair is just a base <span class="math inline">n</span> number with <span class="math inline">2</span> digits. We can apply radix sort with running time <span class="math inline">O(n)</span> and group by the result.</p>
</section>
<p>Note one can also directly use a <a href="https://en.wikipedia.org/wiki/Partition_refinement">partition refinement data structure</a> to get the same result.</p>
<p>As a corollary, consider <span class="math inline">\mathcal{A}=\mathcal{P}_i</span> and <span class="math inline">\mathcal{B}=\mathcal{S}_i</span>, then we obtain the following lemma.</p>
<section class="theorem-environment Lemma" id="Lemma-4">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">4</span></span>
<p>Given the collections <span class="math inline">\mathcal{P}_i</span> and <span class="math inline">\mathcal{S}_i</span>, there is an <span class="math inline">O(n)</span> time algorithm to test if there are two strings <span class="math inline">x,y\in W</span> that differs in precisely position <span class="math inline">i</span>.</p>
</section>
<section class="theorem-environment Lemma" id="Lemma-5">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">5</span></span>
<p>Finding <span class="math inline">\mathcal{P}_1,\ldots,\mathcal{P}_m</span> and <span class="math inline">\mathcal{S}_1,\ldots,\mathcal{S}_m</span> can be done in <span class="math inline">O(mn)</span> time.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>To find the equivalent classes, build two tries for the strings. Trie <span class="math inline">T_\mathcal{P}</span> for strings in <span class="math inline">W</span> and trie <span class="math inline">T_\mathcal{S}</span> for the reversal of strings in <span class="math inline">W</span>. Building the tries takes <span class="math inline">O(mn)</span> time. Inspect the nodes at depth <span class="math inline">i-1</span> in <span class="math inline">T_P</span> and nodes at depth <span class="math inline">m-i+1</span> in <span class="math inline">T_S</span> to recover <span class="math inline">\mathcal{P}_i</span> and <span class="math inline">\mathcal{S}_i</span> in <span class="math inline">O(n)</span> time.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-6">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">6</span></span>
<p>There is an <span class="math inline">O(mn)</span> time algorithm that solves <a href="#Problem-1">Problem 1</a>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Finding the sequence of equivalent classes takes <span class="math inline">O(mn)</span> time by <a href="#Lemma-4">Lemma 4</a>. For each <span class="math inline">i</span>, checking if there exists <span class="math inline">x,y\in W</span> differs in precisely position <span class="math inline">i</span> takes <span class="math inline">O(n)</span> time by <a href="#Lemma-3">Lemma 3</a>. Since <span class="math inline">i</span> ranges from <span class="math inline">1</span> to <span class="math inline">m</span>, we obtain the final running time is <span class="math inline">O(mn)</span>.</p>
</section>
<h1 id="remarks"><span class="header-section-number">2</span> Remarks</h1>
<p><a href="https://dblp.uni-trier.de/pers/hd/w/Wang:Ruosong">Ruosong Wang</a> communicated another <span class="math inline">O(mn)</span> solution. It is much easier to describe. Let <span class="math inline">\diamond</span> be a symbol not in the alphabet. Build a <a href="https://en.wikipedia.org/wiki/Generalized_suffix_tree">generalized suffix tree</a> over the set of strings <span class="math inline">S&#39;=\set{x\diamond x| x\in W}</span>. Traverse the suffix tree, up to level <span class="math inline">m</span>, and output <code>true</code> if a path that contains <span class="math inline">\diamond</span> was traversed, and can lead to more than <span class="math inline">2</span> leaves. Indeed, this means the substring <span class="math inline">x\diamond y</span> appears at least twice. Hence there are at least two strings of the form <span class="math inline">yax</span> and <span class="math inline">ybx</span> in <span class="math inline">W</span>. This definitely hits the optimal running time, but implementing a generalized suffix tree is fairly hard.</p>
<p>We do assume the alphabet size is constant. If the alphabet size is <span class="math inline">\sigma</span> and ordered, then there is an extra factor of <span class="math inline">\log \sigma</span> in building the tries. The the final running time will be <span class="math inline">O(mn\log \sigma)</span>.</p>
<p><a href="#Problem-1">Problem 1</a> also reduces to finding the closest pair of elements by hamming metric <span class="citation" data-cites="MinKZ09">[<a href="#ref-MinKZ09">1</a>]</span>. It does not get us the desired running time though.</p>
<h1 id="an-implementation-in-haskell"><span class="header-section-number">3</span> An implementation in Haskell</h1>
<p>The implementation is mostly faithful to the presentation in the article. We did not implement counting sort nor radix sort.</p>
<script src="https://gist.github.com/chaoxu/a4a60408a069edf3889e8328e685f700.js"></script>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-MinKZ09">
<p>[1] K. Min, M.-Y. Kao, H. Zhu, The closest pair problem under the hamming metric, in: H.Q. Ngo (Ed.), Computing and Combinatorics, Springer Berlin Heidelberg, Berlin, Heidelberg, 2009: pp. 205–214.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2018-12-23. </div>
    <div class="info">Tags: algorithms, strings, tries.</div>

</div>]]></description>
    <pubDate>Sun, 23 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2018-12-23-strings-with-hamming-distance-exactly-1.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Subset sum through balancing</title>
    <link>https://chaoxuprime.com/blog/posts/2018-12-18-subset-sum-through-balancing.html</link>
    <description><![CDATA[<br />
<div>
<p>This is a note for Pisinger's balancing algorithm for subset sum <span class="citation" data-cites="Pisinger19991">[<a href="#ref-Pisinger19991">1</a>]</span>. Let <span class="math inline">\mathcal{S}</span> be the set of all subset sums of <span class="math inline">S</span>. The subset sum problem, the input is <span class="math inline">S\subset \N</span>, and we are interested in checking if <span class="math inline">t\in \mathcal{S}</span>.</p>
<p>We define a variation of the subset sum problem. The <em>balanced subset sum problem</em>. In this problem, we are given a vector <span class="math inline">v</span> of integers(does not have to be positive). We let <span class="math inline">M=\|v\|_\infty</span>. We are interested in find a subset that sums to <span class="math inline">t\in [M]</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-1">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>Each subset sum problem on <span class="math inline">n</span> elements can be reduced to a balanced subset sum problem in <span class="math inline">n</span> elements in <span class="math inline">O(n)</span> time.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Consider the input to the subset sum problem <span class="math inline">S</span> and <span class="math inline">t</span>. Greedily find a subset of elements <span class="math inline">S&#39;</span>, such that adding any other element will exceed <span class="math inline">t</span>. Let <span class="math inline">\|S&#39;\|_1=t&#39;</span>. Now, we negate all the elements in <span class="math inline">S&#39;</span>, and ask for balanced subset sum with input set <span class="math inline">-S&#39; \cup (S\setminus S&#39;)</span> and target number <span class="math inline">t-t&#39;</span>.</p>
</section>
<p>We partition <span class="math inline">S</span> into <span class="math inline">A = [-M..0]\cap S</span> and <span class="math inline">B=S\setminus A</span>. We also define <span class="math inline">A_i = \set{a_1,\ldots,a_i}</span> and <span class="math inline">B_i=\set{b_1,\ldots,b_i}</span>.</p>
<p>A set is balanced by the following recursive definition. Let <span class="math inline">S</span> be a set.</p>
<ul>
<li><span class="math inline">S=\emptyset</span> is balanced.</li>
<li><span class="math inline">\|S\|_1&gt; t</span>, then <span class="math inline">S\cup \set{a}</span> is balanced, where <span class="math inline">a\in A</span>.</li>
<li><span class="math inline">\|S\|_1\leq t</span>, then <span class="math inline">S\cup \set{b}</span> is balanced, where <span class="math inline">b\in B</span>.</li>
</ul>
<p>Consider a set <span class="math inline">T</span>, such that <span class="math inline">(i,j,k)\in T</span> if and only if <span class="math inline">k</span> is a subset sum of <span class="math inline">A_i\cup B_j</span>. Certainly, we are interested if <span class="math inline">(|A|,|B|,t)</span> is in <span class="math inline">T</span>. However, the state space is already <span class="math inline">O(n^2M)</span>, which is no better than the standard dynamic programming algorithm.</p>
<p>There is a nice dominance relation. If <span class="math inline">(i,j,k)\in T</span>, then for <span class="math inline">(i&#39;,j&#39;)\geq (i,j)</span>, we have <span class="math inline">(i&#39;,j&#39;,k)\in T</span>. We can ask for each <span class="math inline">k</span>, what are all the minimal <span class="math inline">(i,j)</span> pairs where <span class="math inline">(i,j,k)\in T</span>. Such value will be <span class="math inline">g(j,k)</span>. Formally, <span class="math inline">g(j,k) = \min \set{i | (i,j,k)\in T}</span>, one can see that <span class="math inline">g(j,k) \geq g(j+1,k)</span>. Also, we know the solution corresponding to <span class="math inline">g(j,k)</span> must contain <span class="math inline">a_{g(j,k)}</span> as an element.</p>
<p>One can get a recurrence relation for <span class="math inline">g</span> as below.</p>
<p><span class="math display">\displaystyle 
g(j,k)= \min \begin{cases}
g(j-1,k)\\
g(j-1,k-b_j) &amp; \text{if }k-b_j\leq t\\
i &amp; \text{if }k-a_i &gt; t \text{ and } i&gt;g(j,k-a_i)
\end{cases}
</span></p>
<p>Fix a <span class="math inline">k</span> and <span class="math inline">j</span>, let <span class="math inline">i</span> to be as small as possible, such that there is <span class="math inline">A_i&#39;\subset A_i</span> and <span class="math inline">B_j&#39;\subset B_j</span> such that <span class="math inline">A_i&#39;\cup B_j&#39;</span> is balanced and sums to <span class="math inline">k</span>. Note that <span class="math inline">a_i\in A_i&#39;</span>.</p>
<p>We obtained <span class="math inline">A_i&#39;\cup B_j&#39;</span> by inserting an element in <span class="math inline">B</span> or <span class="math inline">A</span> to another balanced set. If the inserted element is in <span class="math inline">B</span>, but not <span class="math inline">b_j</span>, then we know <span class="math inline">i=g(j-1,k)</span>. If it is <span class="math inline">b_j</span>, then <span class="math inline">i=g(j-1,k-b_j)</span>. If the last inserted is <span class="math inline">a_i</span>, then <span class="math inline">g(j,k)=i</span>. Note we observe in this case, <span class="math inline">g(j,k-a_i)&lt;i</span>. A direct dynamic programming implementation seems to imply a <span class="math inline">O(n^2M)</span> time algorithm, since there does not seem to be a quick way to obtain <span class="math inline">i</span>.</p>
<p>On the other hand, if we think bottom up instead of top down, we can obtain a better result. Below is the algorithm.</p>
<figure>
<img src="/files/balanced_subsetsum.png" alt="The algorithm" /><figcaption>The algorithm</figcaption>
</figure>
<p>The value <span class="math inline">D[j,k]</span> eventually equals <span class="math inline">g(j,k)</span>. Note we can argue the running time is <span class="math inline">O(nM)</span>, since for each fixed <span class="math inline">k</span>, the final for loop can ran at most <span class="math inline">n</span> times. It is frustrating that the DP algorithm cannot be inferred directly from the recurrence relation. Indeed, we mainly obtained this through the fact that we can prune the search space if we start bottom up, which is unclear from the recurrence relation.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Pisinger19991">
<p>[1] D. Pisinger, <strong>Linear time algorithms for knapsack problems with bounded weights</strong>, Journal of Algorithms. 33 (1999) 1–14 <a href="https://doi.org/10.1006/jagm.1999.1034">10.1006/jagm.1999.1034</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2018-12-18. </div>
    <div class="info">Tags: algorithms, subset sum.</div>

</div>]]></description>
    <pubDate>Tue, 18 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2018-12-18-subset-sum-through-balancing.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Global min-cut with parity constraint on the edges</title>
    <link>https://chaoxuprime.com/blog/posts/2018-11-06-global-min-cut-with-parity-constraint-on-the-edges.html</link>
    <description><![CDATA[<br />
<div>
<p>In a discussion with <a href="https://patrickl.in/">Patrick Lin</a>, a nice problem was born.</p>
<p>Let <span class="math inline">\delta(S)</span> to be the set of edges with exactly one endpoint in <span class="math inline">S</span>. <span class="math inline">\delta^-(S)</span> to be the set of edges with its head in <span class="math inline">S</span> and tail in <span class="math inline">V\setminus S</span>. Given a non-negative weighted graph, we define the cut function <span class="math inline">f:2^V\to \R^+</span> to be <span class="math inline">f(S) = \sum_{e\in \delta(S)} w(e)</span>. For directed graphs, <span class="math inline">f(S) = \sum_{e\in \delta^-(S)} w(e)</span>. <span class="math inline">f(S)</span> is called the value of the cut <span class="math inline">S</span>.</p>
<p>Let <span class="math inline">k</span> be a constant, we consider the following problem.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Give a graph and <span class="math inline">k</span> set of edges <span class="math inline">F_1,\ldots,F_k</span>, <span class="math inline">a_1,\ldots,a_k,b</span>. Find a cut <span class="math inline">S</span> satisfies that <span class="math inline">|\delta(S)\cap F_i|\equiv a_i \pmod b</span> for all <span class="math inline">i</span>, and the value is minimized.</p>
</section>
<p>We will try to reduce this problem to the following</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span><span class="name">submodular minimization under congruence constraints</span></span>
<p>Given <span class="math inline">T_1,\ldots,T_k</span> and a submodular function <span class="math inline">f</span>. Find a set <span class="math inline">S</span> such that <span class="math inline">|T_i\cap S| \equiv a_i\pmod b_i</span>, and <span class="math inline">f(S)</span> is minimized.</p>
</section>
<p>The above problem is known as submodular minimization under congruence constraints. It is known to be solvable in polynomial time under certain conditions on the <span class="math inline">b_i</span>'s <span class="citation" data-cites="NageleSZ18">[<a href="#ref-NageleSZ18">1</a>]</span>. We sketch the reductions.</p>
<h1 id="undirected-case"><span class="header-section-number">1</span> Undirected case</h1>
<p>In the undirected case, we only consider when <span class="math inline">b=2</span>. Patrick showed a the following construction. Create a new graph <span class="math inline">G&#39;</span> as follows. For each <span class="math inline">uv</span> in <span class="math inline">E</span>, split it into edges <span class="math inline">ux</span>, <span class="math inline">xy</span>, <span class="math inline">yv</span>, <span class="math inline">w(ux)=w(yv)=\infty</span>, and <span class="math inline">w(xy)=w(uv)</span>. Let <span class="math inline">T_i</span> contains the vertex <span class="math inline">x</span> and <span class="math inline">y</span> if <span class="math inline">uv\in F_i</span>.<br />
We now solve the submodular minimization under congruence constraints problem on input <span class="math inline">f</span>, which is the cut function for <span class="math inline">G&#39;</span>, and same <span class="math inline">a_1,\ldots,a_k</span> and <span class="math inline">b_1,\ldots,b_k=2</span>.</p>
<h1 id="directed-case"><span class="header-section-number">2</span> Directed case</h1>
<p>In the directed case, a similar approach works. But now, instead of <span class="math inline">\mod 2</span>, we can do <span class="math inline">\mod b</span> for any <span class="math inline">b</span>. We consider the same approach.<br />
<span class="math inline">(u,v) \in E</span> split into <span class="math inline">(u,x_1),\ldots,(x_b,v)</span> and <span class="math inline">w(u,x_1)=w(u,v)</span>, <span class="math inline">w(x_i,x_{i+1})=\infty</span>, <span class="math inline">w(x_b,v)=\infty</span>. Now, let <span class="math inline">T_i</span> contain vertices <span class="math inline">x_1,\ldots,x_b</span> of <span class="math inline">uv\in F_i</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-NageleSZ18">
<p>[1] M. Nägele, B. Sudakov, R. Zenklusen, Submodular minimization under congruency constraints, in: Proceedings of the Twenty-Ninth Annual Acm-Siam Symposium on Discrete Algorithms, Society for Industrial; Applied Mathematics, Philadelphia, PA, USA, 2018: pp. 849–866.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2018-11-06. </div>
    <div class="info">Tags: algorithms, min-cut.</div>

</div>]]></description>
    <pubDate>Tue, 06 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2018-11-06-global-min-cut-with-parity-constraint-on-the-edges.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Computing the weighted h-index</title>
    <link>https://chaoxuprime.com/blog/posts/2018-02-23-weighted-h-index.html</link>
    <description><![CDATA[<br />
<div>
<p>A common algorithm problem is that given a sequence of numbers, find a h-index. Where h-index is the largest integer <span class="math inline">h</span> such there are at least <span class="math inline">h</span> integers in the sequence is at least as large as <span class="math inline">h</span>.</p>
<p>Formally, we have the following problem.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given <span class="math inline">a_1,\ldots,a_n</span>, find the largest <span class="math inline">h</span>, such that <span class="math inline">|\set{i \mid a_i\geq h}|\geq h</span>.</p>
</section>
<p>The <a href="https://leetcode.com/problems/h-index/description/">h-index problem is featured in leetcode</a>.</p>
<p>If we the numbers are sorted, then a trivial <span class="math inline">O(n)</span> time algorithm exists. If it is not sorted, then note that we can solve the problem on <span class="math inline">\min(a_1,n),\ldots,\min(a_n,n)</span>. In this case, the input numbers is at most <span class="math inline">n</span>, therefore can be sorted in <span class="math inline">O(n)</span> time. Hence the total running time is <span class="math inline">O(n)</span>.</p>
<p>Consider a weighted version of the problem where the above algorithm does not work.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given a sequence of pairs of non-negative positive reals <span class="math inline">(w_1,a_1),\ldots,(w_n,a_n)</span>. Find the largest <span class="math inline">h\in \R</span>, such that <span class="math inline">\sum_{i:a_i\geq h} w_i \geq h</span>.</p>
</section>
<p>An <span class="math inline">O(n)</span> time algorithm still exists. For simplicity, we assume all <span class="math inline">a_i</span>'s are distinct, so the input is a set. The case where <span class="math inline">a_i</span>'s are not distinct is left as an exercise to the reader.</p>
<p>Define <span class="math inline">f(t) = \sum_{i:a_i\geq t} w_i</span>. We want to find the largest <span class="math inline">t</span> such that <span class="math inline">f(t)\geq t</span>. First, we can find the median of <span class="math inline">a_1,\ldots,a_n</span>, say <span class="math inline">t</span>. If <span class="math inline">f(t) &lt; t</span>, then we recurse on <span class="math inline">\set{(w_i-f(t),a_i) \mid a_i&lt; t}</span>. Assume the optimum in the recursed solution is <span class="math inline">t&#39;</span>, we return <span class="math inline">t&#39;+f(t)</span> as the solution. If <span class="math inline">f(t)\geq t</span>, then we recurse and output the solution with input <span class="math inline">\set{(w_i,a_i) \mid a_i\geq t}</span>. The running time satisfies <span class="math inline">T(n)=T(n/2)+O(n)</span>, which is <span class="math inline">O(n)</span>.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2018-02-23. </div>
    <div class="info">Tags: algorithms.</div>

</div>]]></description>
    <pubDate>Fri, 23 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2018-02-23-weighted-h-index.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Small <span class="math inline">L_1</span> norm solution to a linear Diophantine equation</title>
    <link>https://chaoxuprime.com/blog/posts/2017-08-26-solution-to-linear-diophantine.html</link>
    <description><![CDATA[<br />
<div>
<p>Let <span class="math inline">a=(a_1,\ldots,a_n)</span> be <span class="math inline">n</span> integers with <span class="math inline">\gcd(a_1,\ldots,a_n)=1</span>. There exists a integral vector <span class="math inline">x=(x_1,\ldots,x_n)</span>, such that <span class="math inline">\sum_{i=1}^n x_ia_i = 1</span>. How large is the solution <span class="math inline">x</span>? By <a href="https://en.wikipedia.org/wiki/Bézout%27s_identity">Bézout's lemma</a>, when <span class="math inline">n=2</span>, we can obtain that <span class="math inline">\|x\|\leq \|a\|</span>. Here <span class="math inline">\|\cdot \|</span> is the <span class="math inline">L_1</span> norm.</p>
<p>However, I could not find a general bound of <span class="math inline">\|x\|</span> anywhere. Here we prove that the bound on <span class="math inline">\|x\|</span> is true in general. Before that, we first introduce a lemma from <span class="citation" data-cites="Ford1996">[<a href="#ref-Ford1996">1</a>]</span>.</p>
<section class="theorem-environment Lemma" id="Lemma-1">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">1</span></span>
<p>Let <span class="math inline">a=(a_1,\ldots,a_n)</span> be a vector of positive integers with at least <span class="math inline">2</span> elements, it does not contain <span class="math inline">1</span> and <span class="math inline">\gcd(a)=1</span>. If <span class="math inline">g_k = \gcd(a_k,\ldots,a_n)</span>, then there exist a solution to <span class="math display">\displaystyle 
\sum_{i=1}^n x_i a_i = 1
</span> such that for all <span class="math inline">1\leq i\leq n-1</span>, <span class="math display">\displaystyle 
|x_i|\leq \frac{g_{i+1}}{2g_i}
</span> and <span class="math inline">|x_n|\leq \frac{\max(a_1,\ldots,a_{n-1})}{2}</span>.</p>
</section>
<section class="theorem-environment Theorem" id="Theorem-2">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>Let <span class="math inline">a</span> be a vector of positive integers such that <span class="math inline">\gcd(a)=1</span>, then there exists a integral solution to <span class="math inline">x \cdot a=1</span> such that <span class="math inline">\|x\|\leq \frac{1}{2}(\min(a)+\max(a))</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Let <span class="math inline">a=(a_1,\ldots,a_n)</span>. Let <span class="math inline">a_n=\min(a)</span>. We can assume <span class="math inline">1</span> is not in <span class="math inline">a</span>, otherwise we can find <span class="math inline">x</span> such that <span class="math inline">\|x\|=1</span>. Let <span class="math inline">g_i = \gcd(a_i,\ldots,a_n)</span>. Hence <span class="math inline">g_n = \min(a)</span>. We consider a solution to <span class="math inline">\sum_{i=1}^n x_ia_i = 1</span> satisfies <a href="#Lemma-1">Lemma 1</a>. Let <span class="math inline">I = \set{i | g_{i+1}\geq 2g_{i}, i\leq n-1}</span> and <span class="math inline">j=\min(I)</span>. One can algebraically check that <span class="math inline">a/b\leq a-b</span> holds if both <span class="math inline">a\geq 2b</span> and <span class="math inline">b\geq 2</span>. In particular, we have <span class="math inline">\frac{g_{i+1}}{g_i} \leq g_{i+1}-g_i</span> for all <span class="math inline">i\in I\setminus \set{j}</span>. <span class="math display">\displaystyle 
\sum_{i\in I} |x_i| \leq \frac{1}{2} \sum_{i\in I} \frac{g_{i+1}}{g_i} \leq \frac{g_{j+1}}{2} + \frac{1}{2} \sum_{i\in I, i\neq j} g_{i+1} - g_i \leq \frac{g_{j+1}}{2} + \frac{1}{2} \sum_{i=j+1}^{n-1} g_{i+1}-g_i = \frac{1}{2}g_n = \frac{\min(a)}{2}.
</span></p>
<p><span class="math display">\displaystyle 
    \|x\| = \sum_{i=1}^n |x_i| = |x_n| + \sum_{i\in I} |x_i| \leq \frac{\min(a)+\max(a)}{2}
</span></p>
</section>
<section class="theorem-environment Corollary" id="Corollary-3">
<span class="theorem-header"><span class="type">Corollary</span><span class="index">3</span></span>
<p>Let <span class="math inline">a</span> be a vector of integers such that <span class="math inline">\gcd(a)=1</span>, then there exists a integral solution to <span class="math inline">x \cdot a=1</span> such that <span class="math inline">\|x\|\leq \|a\|</span>.</p>
</section>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Ford1996">
<p>[1] D. Ford, G. Havas, A new algorithm and refined bounds for extended gcd computation, in: H. Cohen (Ed.), Algorithmic Number Theory: Second International Symposium, Ants-Ii Talence, France, May 18–23, 1996 Proceedings, Springer Berlin Heidelberg, Berlin, Heidelberg, 1996: pp. 145–150 <a href="https://doi.org/10.1007/3-540-61581-4_50">10.1007/3-540-61581-4_50</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2017-08-26. </div>
    <div class="info">Tags: number theory.</div>

</div>]]></description>
    <pubDate>Sat, 26 Aug 2017 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2017-08-26-solution-to-linear-diophantine.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>List the smallest <span class="math inline">k</span> subset sums</title>
    <link>https://chaoxuprime.com/blog/posts/2017-04-20-list-the-smallest-k-subset-sums.html</link>
    <description><![CDATA[<br />
<div>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a set of positive reals <span class="math inline">\set{x_1,\ldots,x_n}</span> where <span class="math inline">x_1&lt;x_2&lt;\ldots&lt;x_n</span>, find the smallest <span class="math inline">k</span> subset sums.</p>
</section>
<p>We can assume <span class="math inline">n\leq k</span>, because we do not have to read <span class="math inline">x_j</span> if <span class="math inline">j&gt;k</span>.</p>
<p>Torsten Gross and Nils Blüthgen posted <a href="https://arxiv.org/abs/1704.05795">a <span class="math inline">O(k^2)</span> time solution on arXiv</a>.</p>
<p>We show a <span class="math inline">O(k\log k)</span> time algorithm, which is optimal if we want to output the numbers in order.</p>
<p>We list the sums one by one by maintaining a priority queue of sums. We start with the empty set. Assume that we added the sum induced by <span class="math inline">I\subset [n]</span> (that is, <span class="math inline">\sum_{i\in I} x_i</span>) into the output, let <span class="math inline">j=1+\max I</span>. Now we can consider two possibilities by extending the current solution: the sum induced by <span class="math inline">I\cup \set{j}</span> or the sum induced by <span class="math inline">I\cup \set{k}</span> where <span class="math inline">k&gt;j</span>. We will add both possibilities to the queue so that one can inspect them later. We can avoid storing the sets, only the values are required.</p>
<p>Here is a python implementation.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> first_k_subset_sums(x,k):
    n <span class="op">=</span> <span class="bu">len</span>(x)
    h <span class="op">=</span> []
    output <span class="op">=</span> [<span class="dv">0</span>] <span class="co"># need to account for the empty set</span>
    heapq.heappush(h,(x[<span class="dv">0</span>],<span class="dv">0</span>))
    <span class="cf">while</span> h <span class="kw">and</span> <span class="bu">len</span>(output)<span class="op">&lt;</span>k:
        (u,b) <span class="op">=</span> heapq.heappop(h)
        output.append(u)
        <span class="cf">if</span> b<span class="op">+</span><span class="dv">1</span><span class="op">&lt;</span>n:
            heapq.heappush(h,(u<span class="op">+</span>x[b<span class="op">+</span><span class="dv">1</span>],b<span class="op">+</span><span class="dv">1</span>))
            heapq.heappush(h,((u<span class="op">-</span>x[b])<span class="op">+</span>x[b<span class="op">+</span><span class="dv">1</span>],b<span class="op">+</span><span class="dv">1</span>))
    <span class="cf">return</span> output</code></pre></div>
<p>If we want to output the sets themselves, not just the values, does the running time change? If a set <span class="math inline">I</span> is in the output, then all subsets of <span class="math inline">I</span> must also be in the output. Hence the largest set we can ever output has size <span class="math inline">O(\log k)</span>. Therefore the total output length is at most <span class="math inline">O(k\log k)</span>.</p>
<p>This is also a lower bound. Consider when <span class="math inline">x_i=2^i</span>, then we will output all subsets of <span class="math inline">\set{x_1,\ldots,x_{\log k}}</span>, and we know that <span class="math inline">\sum_{i=1}^{\log k} i{\log k\choose i} = \Omega(\log k)</span>.</p>
<p>If we don't have to list the smallest <span class="math inline">k</span> subset sum values in order, then <span class="math inline">O(k)</span> is possible, see <a href="https://mathoverflow.net/a/222341/6886">this mathoverflow answer</a> by <a href="https://www.ics.uci.edu/~eppstein/">David Eppstein</a>.</p>
<p>If we are interested in the smallest <span class="math inline">k</span> <em>distinct</em> subset sum. I don't know of any algorithm that performs better than <span class="math inline">O(nk)</span>, even if we know that <span class="math inline">n=\Omega(k)</span>.</p>
<h1 id="acknowledgements" class="unnumbered">Acknowledgements</h1>
<p>I would like to thank Tana Wattanawaroon for helpful discussions and taking an interest in this problem.</p>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2017-04-20. </div>
    <div class="info">Tags: algorithm.</div>

</div>]]></description>
    <pubDate>Thu, 20 Apr 2017 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2017-04-20-list-the-smallest-k-subset-sums.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Filling up a bin using balls with divisible weights</title>
    <link>https://chaoxuprime.com/blog/posts/2017-03-09-filling-up-a-bin-using-balls-with-divisible-weight.html</link>
    <description><![CDATA[<br />
<div>
<p>This post shows how to solve the special case for <a href="http://cs.stackexchange.com/questions/12441/is-it-np-hard-to-fill-up-bins-with-minimum-moves">this problem</a>. The special case has exactly one bin, and each ball have weight a power of <span class="math inline">2</span>. It is one of the <a href="http://cs.stackexchange.com/unanswered">most popular unanswered problem on cs.stackexchange</a> as of writing.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>We are interested in solving the following integer program, <span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n |x_i-a_i| \\
\text{subject to:} &amp; \sum_{i=1}^n w_i x_i = c\\
&amp; 0\leq x_i \leq b_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>where each <span class="math inline">w_i</span> is a power of <span class="math inline">2</span> for all <span class="math inline">1\leq i\leq n</span>. Assume <span class="math inline">w_i\leq w_{i+1}</span>.</p>
</section>
<p>In fact, we do not require the <span class="math inline">w_i</span>s are powers of <span class="math inline">2</span>. We can establish polynomial time as long as <span class="math inline">w_{i+1}/w_i</span> is bounded by a polynomial in terms of the input size for all <span class="math inline">i</span>. However, for simplicity of exposition, assume <span class="math inline">w_i</span>s are powers of <span class="math inline">2</span>. We do not know the case when <span class="math inline">w_{i+1}/w_i</span> is unbounded.</p>
<p>Consider a more natural problem without the absolute values.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span><span class="name"><span class="math inline">0</span>-<span class="math inline">1</span> exact knapsack problem with divisible weights</span></span>
<p>We are interested in solving the following integer program, <span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n c_i x_i \\
\text{subject to:} &amp; \sum_{i=1}^n w_i x_i = t\\
&amp; x_i \in \{0,1\} \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>where <span class="math inline">w_i|w_{i+1}</span> for all <span class="math inline">1\leq i\leq n</span>. <span class="math inline">w_i</span> can be negative.</p>
</section>
<p>We show <a href="#Problem-1">Problem 1</a> reduces to <a href="#Problem-2">Problem 2</a> with polynomial blow up, and <a href="#Problem-2">Problem 2</a> can be solved in polynomial time.</p>
<h1 id="reduction"><span class="header-section-number">1</span> Reduction</h1>
<p>The reduction goes through a few steps. We start with the integer program in <a href="#Problem-1">Problem 1</a>, and let <span class="math inline">y_i = a_i-x_i</span>, and we get</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n |y_i| \\
\text{subject to:} &amp; \sum_{i=1}^n w_i y_i = \sum_{i=1}^n w_i a_i - c\\
&amp; a_i-b_i\leq y_i \leq a_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>Let <span class="math inline">c&#39; = \sum_{i=1}^n w_ia_i -c</span>, and <span class="math inline">l_i = a_i-b_i</span> and <span class="math inline">u_i = a_i</span>.</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n |y_i| \\
\text{subject to:} &amp; \sum_{i=1}^n w_i y_i = c&#39;\\
&amp; l_i \leq y_i \leq u_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>Let <span class="math inline">y_i=y_i^+ - y_i^-</span>, where <span class="math inline">y_i^-,y_i^+\geq 0</span>, we can remove the absolute value.</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n y_i^+ + y_i^- \\
\text{subject to:} &amp; \sum_{i=1}^n w_i y_i^+ + \sum_{i=1}^n -w_i y_i^- = c&#39;\\
&amp; l_i \leq y_i^+- y_i^- \leq u_i \text{ for all } 1\leq i \leq n\\
&amp; y_i^-, y_i^+\geq 0 \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>Observe that we can separate the inequalities involving <span class="math inline">y_i^+ - y_i^-</span>, because there is always an optimal where <span class="math inline">y_i^-</span> or <span class="math inline">y_i^+</span> is <span class="math inline">0</span>.</p>
<section class="theorem-environment Remark" id="Remark-">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>This observation fails when the number of bins is more than <span class="math inline">1</span>.</p>
</section>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n y_i^+ + y_i^- \\
\text{subject to:} &amp; \sum_{i=1}^n w_i y_i^+ + \sum_{i=1}^n -w_i y_i^- = c&#39;\\
&amp; 0 \leq y_i^+ \leq u_i \text{ for all } 1\leq i \leq n\\
&amp; 0 \leq y_i^- \leq -l_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>This is an integer program as a bounded exact knapsack problem.</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{i=1}^n x_i \\
\text{subject to:} &amp; \sum_{i=1}^n w_i x_i = c\\
&amp; 0 \leq x_i \leq b_i \text{ for all } 1\leq i \leq n\\
\end{aligned}</span></p>
<p>Finally, apply the standard technique that rewrites a bounded knapsack problem to <span class="math inline">0</span>-<span class="math inline">1</span>-knapsack problem (see Section 7.1.1 of <span class="citation" data-cites="9783540402862">[<a href="#ref-9783540402862">1</a>]</span>). The blow up in problem size is at most a factor of <span class="math inline">O(\log \max_i b_i)</span>. We can get the integer program in <a href="#Problem-2">Problem 2</a>, and also the weights are all powers of <span class="math inline">2</span>. The reduction runs in polynomial time with respect to input size.</p>
<h1 id="solving-problem-2"><span class="header-section-number">2</span> Solving <a href="#Problem-2">Problem 2</a></h1>
<p><a href="http://sevenkplus.com/">Yuzhou Gu</a> noted that the integer program in <a href="#Problem-2">Problem 2</a> has a dynamic programming solution.</p>
<p>Let <span class="math inline">D[m,k]</span> to be the optimal value to the following problem</p>
<p><span class="math display">\displaystyle \begin{aligned}
\text{Minimize:} &amp; \sum_{j=1}^m c_j x_j \\
\text{subject to:} &amp; \sum_{j=1}^m w_j x_j = k |w_m| + t \bmod |w_m|\\
&amp; x_j \in \{0,1\} \text{ for all } 1\leq j \leq m\\
\end{aligned}</span></p>
<p>The claim is that <span class="math inline">D[m,k]</span> can be expressed by the following recurrence relation.</p>
<p><span class="math display">\displaystyle 
D[m,k] = \min_{x_m\in \{0,1\}} D\left[m-1,\frac{|w_m|k- w_m x_m+(t\bmod |w_m| - t\bmod |w_{m-1}|)}{|w_{m-1}|}\right]
</span></p>
<p>Note that <span class="math inline">|k|</span> is at most <span class="math inline">m</span>. Therefore the table has at most <span class="math inline">O(n^2)</span> entries. To obtain the solution to the original equation, we find the minimum overall <span class="math inline">D[n, k]</span>. Clearly, this runs in polynomial time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-9783540402862">
<p>[1] H. Kellerer, U. Pferschy, D. Pisinger, <strong>Knapsack problems</strong>, Springer, 2004.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2017-03-09. </div>
    <div class="info">Tags: optimization, integer.</div>

</div>]]></description>
    <pubDate>Thu, 09 Mar 2017 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2017-03-09-filling-up-a-bin-using-balls-with-divisible-weight.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Processor distribution and proportional apportionment</title>
    <link>https://chaoxuprime.com/blog/posts/2016-08-02-proportional-apportionment.html</link>
    <description><![CDATA[<br />
<div>
<p>I saw an interview problem about assigning identical processors to embarrassingly parallel jobs. The running time of a job equals the running time on a single processor divided by the number of processors. We are interested in minimizing the maximum running time. Formally, we get the following problem.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given positive reals <span class="math inline">a_1,\ldots,a_n</span> and positive integer <span class="math inline">k</span>, find non-negative integers <span class="math inline">x_1,\ldots,x_n</span>, such that <span class="math inline">\sum_{i} x_i \leq k</span> and <span class="math inline">\theta = \max_{i} a_i/x_i</span> is minimized.</p>
</section>
<p>If there is no integral requirement on <span class="math inline">x_i</span>'s, then the problem is easy. Let <span class="math inline">A=\sum_{i} a_i</span>. There is a closed solution of <span class="math inline">x_i = k \frac{a_i}{A}</span>, and <span class="math inline">\theta = A / k</span>.</p>
<p>Otherwise, it is easy to check if <span class="math inline">\theta&#39;&gt;0</span> is a feasible solution. <span class="math inline">\theta&#39;</span> is feasible iff <span class="math inline">\sum_{i} \ceil{a_i/\theta&#39;} \leq k</span>. Therefore one can apply binary search, and get the result in <span class="math inline">O(n\log k)</span> time.</p>
<p>One can also get a <span class="math inline">O(n\log n)</span> time algorithm. First compute <span class="math inline">y_i = \ceil{k \frac{a_i}{A}}</span>. Greedily find a <span class="math inline">i</span> such that <span class="math inline">a_i/y_i</span> is maximized, and decrease <span class="math inline">y_i</span> by <span class="math inline">1</span>. We stop when we have <span class="math inline">\sum_{i} y_i=k</span>. This takes <span class="math inline">O(\log n)</span> per operation using a binary search tree.</p>
<p>Linear time algorithm also exists. It is connected to proportional apportionment. This is the problem of finding the smallest <span class="math inline">\lambda</span>, such that <span class="math inline">\sum_{i} \ceil{\lambda a_i} = k</span>. Cheng and Eppstein found a <span class="math inline">O(n)</span> time algorithm <span class="citation" data-cites="Cheng2014">[<a href="#ref-Cheng2014">1</a>]</span>. Reitzig and Wild found a simpler algorithm later <span class="citation" data-cites="Reitzig2017">[<a href="#ref-Reitzig2017">2</a>]</span>.</p>
<p>There is a similar interview problem. Given <span class="math inline">n</span> points on the real line, add <span class="math inline">k</span> more points, such that it minimizes the maximum length between adjacent points. The problem is the same as the following one.</p>
<section class="theorem-environment Problem" id="Problem-2">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given positive <span class="math inline">a_1,\ldots,a_n</span> and positive integer <span class="math inline">k</span>, find non-negative integers <span class="math inline">x_1,\ldots,x_n</span>, such that <span class="math inline">\sum_{i} x_i \leq k</span> and <span class="math inline">\theta = \max_{i} a_i/(x_i+1)</span> is minimized.</p>
</section>
<p>The linear time algorithm for proportional apportionment should also work for the above problem. It is interesting how much can we change the problem before the linear time algorithm no longer works.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Cheng2014">
<p>[1] Z. Cheng, D. Eppstein, Linear-time algorithms for proportional apportionment, in: H.-K. Ahn, C.-S. Shin (Eds.), Algorithms and Computation: 25th International Symposium, Isaac 2014, Jeonju, Korea, December 15-17, 2014, Proceedings, Springer International Publishing, Cham, 2014: pp. 581–592 <a href="https://doi.org/10.1007/978-3-319-13075-0_46">10.1007/978-3-319-13075-0_46</a>.</p>
</div>
<div id="ref-Reitzig2017">
<p>[2] R. Reitzig, S. Wild, <strong>Building fences straight and high: An optimal algorithm for finding the maximum length you can cut <span class="math inline">k</span> times from given sticks</strong>, Algorithmica. (2017) <a href="https://doi.org/10.1007/s00453-017-0392-3">10.1007/s00453-017-0392-3</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2016-08-02. </div>
    <div class="info">Tags: optimization, integer.</div>

</div>]]></description>
    <pubDate>Tue, 02 Aug 2016 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/blog/posts/2016-08-02-proportional-apportionment.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>

    </channel>
</rss>
